/// @event obj_basic_interpreter/Step
// ==============================
// obj_basic_interpreter → Step Event
// ==============================

// (Optional debug tap)
// if (keyboard_check_pressed(vk_enter)) {
//     show_debug_message("ENTER pressed - pause_in_effect: " + string(global.pause_in_effect) +
//                        ", awaiting_input: " + string(global.awaiting_input) +
//                        ", pause_mode: " + string(global.pause_mode));
// }

// ---------- Feed INKEY$ queue once per frame ----------
// (The function itself arbitrates INPUT vs. INKEY modal wait.)
inkey_capture_keys();

global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    if (dbg_on(DBG_PERF)) show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}

// --- SAFE DEFAULTS for INPUT state (avoid undefined lookups) ---
if (is_undefined(global.awaiting_input))     global.awaiting_input     = false;
if (is_undefined(global.pause_mode))         global.pause_mode         = false;
if (is_undefined(global.input_target_var))   global.input_target_var   = "";
if (is_undefined(global.interpreter_input))  global.interpreter_input  = "";

// ==============================
// Sort program lines in ascending order
// ==============================
if (ds_exists(global.line_list, ds_type_list)) {
    ds_list_sort(global.line_list, true);
}

// ==============================
// === Program Ended: Wait for user action ===
// ==============================
if (global.program_has_ended) {
    if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
    if (keyboard_check_pressed(vk_pagedown)) {
        var font_height = string_height("A");
        var visible_lines = floor(room_height / font_height) - 2;
        var total_lines = ds_list_size(global.output_lines);
        global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines - visible_lines));
    }

    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {

        // ==== INSERTED HELP RESTORE HOOK ====
        if (variable_global_exists("help_active") && global.help_active) {
            help_restore_program();   // puts the user's code back
            global.help_active = false;
        }
        // ==== END INSERT ====

        global.program_has_ended = false;
        global.current_mode = 0;

        var _ret = variable_global_exists("editor_return_room")
               ? global.editor_return_room
               : room_first;

        room_goto(_ret);
    }
    return;
}

//
//
// --- BREAK key for BEEP sequences: ESC aborts & ENDs program ---
//
if (global.beep_seq_active && keyboard_check_pressed(vk_escape)) {
    global.beep_break_requested = true; // lets _beep_seq_next() see it too
    beep_cancel(true);                  // hard-cancel now and end program
    return;                             // bail out of Step this frame
}

// ==============================
// INPUT mode (line editor) — commit on Enter (non-pause)
// ==============================
if (global.awaiting_input) {
    if (global.pause_mode) {
        if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: ENTER/ESC detected, resuming...");
            global.awaiting_input   = false;
            global.pause_mode       = false;
            global.pause_in_effect  = false;
            global.input_target_var = "";
            global.interpreter_input = "";
            // Existing behavior in pause-mode:
            global.interpreter_resume_stmt_index = global.interpreter_current_stmt_index + 1;
        }
    } else {
        // Enter commits; basic_cmd_input() already scheduled stmt-jump to p+1
        if (keyboard_check_pressed(vk_enter)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Enter pressed — committing value");

            var _name = basic_normvar(global.input_target_var);
            var _val  = global.interpreter_input;
            var _val_trim = string_trim(string(_val));

            // String typed variable → always store as string
            if (string_length(_name) > 0 && string_char_at(_name, string_length(_name)) == "$") {
                global.basic_variables[? _name] = _val;
            } else {
                if (is_numeric_string(_val_trim)) {
                    global.basic_variables[? _name] = real(_val_trim);
                } else {
                    global.basic_variables[? _name] = _val; // keep literal if non-numeric
                }
            }

            // Clear INPUT state; DO NOT set interpreter_resume_stmt_index here.
            global.awaiting_input    = false;
            global.input_expected    = false;
            global.input_target_var  = "";
            global.interpreter_input = "";

            return; // yield; next frame stmt-jump resumes tail of the line
        }

        // Normal typing & backspace
        for (var _k = 32; _k <= 126; _k++) {
            if (keyboard_check_pressed(_k)) handle_interpreter_character_input(_k);
        }
        if (keyboard_check_pressed(vk_backspace)) handle_interpreter_character_input(vk_backspace);
    }
    return;
}

// ==============================
// INKEY$ modal wait handler (blocking GET-style)
// Armed by LET when RHS is pure INKEY$ (your basic_cmd_let should set:
//   global.inkey_waiting = true; global.pause_in_effect = true;)
// This handler captures ONE key, stashes it, and lets the same LET re-run next frame.
// ==============================
if (global.inkey_waiting) {
    // If we ALREADY have a captured char, DO NOT pause or return here.
    if (string_length(global.inkey_captured) > 0) {
        global.pause_in_effect = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: resume for commit (cached='" + global.inkey_captured + "')");
        // fall through
    } else {
        var _ch = "";

        // Prefer queued key captured by inkey_capture_keys()
        if (ds_exists(global.__inkey_queue, ds_type_queue) && ds_queue_size(global.__inkey_queue) > 0) {
            _ch = ds_queue_dequeue(global.__inkey_queue);
            if (is_real(_ch)) _ch = chr(_ch);
        }

        // Fallback: direct pressed-edge scan this frame
        if (_ch == "") {
            for (var _kc = 32; _kc <= 126; _kc++) {
                if (keyboard_check_pressed(_kc)) { _ch = chr(_kc); break; }
            }
        }

        if (_ch != "") {
            global.inkey_captured  = string(_ch);
            global.pause_in_effect = false;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: captured '" + global.inkey_captured + "', resuming for commit");
            // fall through
        } else {
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: still waiting for key");
            return;
        }
    }
}

// ---- Beep wait release / sequence driver ----
if (variable_global_exists("beep_waiting") && global.beep_waiting) {
    if (current_time >= global.beep_release_time) {
        // stop instance for crisp cutoff
        if (variable_global_exists("beep_instance")) {
            if (is_real(global.beep_instance) && global.beep_instance >= 0) {
                audio_stop_sound(global.beep_instance);
            }
            global.beep_instance = -1;
        }

        global.beep_waiting = false;

        // If a sequence is active, either advance or finish
        if (variable_global_exists("beep_seq_active") && global.beep_seq_active) {
            if (ds_exists(global.beep_seq_queue, ds_type_queue) && ds_queue_size(global.beep_seq_queue) > 0) {
                // Play next note; remain paused
                _beep_seq_next(); // separate script
                global.pause_in_effect = true;
                return;
            } else {
                // Sequence finished → schedule resume at next colon segment
                global.beep_seq_active = false;

                global.interpreter_use_stmt_jump = true;
                global.interpreter_target_line   = global.beep_resume_line;
                global.interpreter_target_stmt   = global.beep_resume_stmt;

                global.pause_in_effect = false; // let interpreter proceed
                // fall through; interpreter loop can run this frame
            }
        } else {
            // Single-note case — just resume
            global.pause_in_effect = false;
            // fall through
        }
    } else {
        // Still waiting → keep interpreter paused and skip the loop this frame
        global.pause_in_effect = true;
        return;
    }
}






// ==============================
// Synchronize for structured IF…ELSE handling
// ==============================
global.interpreter_current_line_index = line_index;

// ==============================
// Handle Jumps (prefer legacy line jump)
// ==============================
if (global.interpreter_next_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: legacy line jump wins → line=" + string(global.interpreter_next_line));
    line_index = global.interpreter_next_line;
    global.interpreter_current_line_index = global.interpreter_next_line;
    global.interpreter_resume_stmt_index = 0;

    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line   = -1;
    global.interpreter_target_stmt   = 0;

    global.interpreter_next_line = -1;
} else if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: using statement-level jump → line=" + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt));
    line_index = global.interpreter_target_line;
    global.interpreter_current_line_index = global.interpreter_target_line;
    global.interpreter_resume_stmt_index = max(0, global.interpreter_target_stmt);
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line = -1;
    global.interpreter_target_stmt = 0;
    global.interpreter_next_line = -1;
}

// ==============================
// End of Program Check
// ==============================
if (line_index >= ds_list_size(global.line_list)) {
    global.interpreter_running = false;
}

// ==============================
// Execute BASIC Line
// ==============================
if (line_index < ds_list_size(global.line_list)) {
    var line_number = ds_list_find_value(global.line_list, line_index);
    var code        = ds_map_find_value(global.program_map, line_number);

    var trimmed = string_trim(code);
    var parts   = split_on_unquoted_colons(trimmed);

    global.current_line_number = line_number;
    if (dbg_on(DBG_FLOW)) show_debug_message("Running line " + string(line_number));

    var _start_stmt = 0;
    if (global.interpreter_resume_stmt_index > 0) {
        _start_stmt = global.interpreter_resume_stmt_index;
        if (dbg_on(DBG_FLOW)) show_debug_message("Resuming at statement index " + string(_start_stmt)
            + " on line " + string(line_number));
        global.interpreter_resume_stmt_index = 0;
    }

    for (var p = _start_stmt; p < array_length(parts); p++) {
        var stmt = string_trim(parts[p]);
        if (stmt == "") continue;

        var sp2  = string_pos(" ", stmt);
        var cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        var arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        // REM / apostrophe: stop the physical line
        if (cmd2 == "REM" || string_char_at(stmt, 1) == "'") {
            if (dbg_on(DBG_FLOW)) {
                show_debug_message("REM/' : stop parsing remainder of line "
                    + string(line_number) + " at part " + string(p) + "/"
                    + string(array_length(parts) - 1));
            }
            break;
        }

        // Strip inline remark then recompute verb/arg
        stmt = strip_basic_remark(stmt);
        sp2  = string_pos(" ", stmt);
        cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        global.interpreter_current_stmt_index = p;

        if (dbg_on(DBG_FLOW)) show_debug_message("Command: " + cmd2 + " | Arg: " + arg2);
        handle_basic_command(cmd2, arg2);

        // If a pause was armed (e.g., modal INKEY$), stop RIGHT HERE
        if (global.pause_in_effect) {
            global.interpreter_resume_stmt_index = p; // retry this colon slot next frame
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: engaged during statement; will retry stmt index " + string(p) + " next frame");
            break;
        }

        // Prefer legacy line jump; clear stale stmt-level flags
        if (global.interpreter_next_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for LEGACY LINE jump");
            global.interpreter_use_stmt_jump = false;
            global.interpreter_target_line   = -1;
            global.interpreter_target_stmt   = 0;
            break;
        }
        if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for STATEMENT-LEVEL jump request");
            break;
        }
    }

    // If no jump requested and NOT paused, advance to next line
    if (!(global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0)
     && !(global.interpreter_next_line >= 0)
     && !global.pause_in_effect) {
 var nxt = line_index + 1;

    // Skip any call-only subroutines unless we *jumped into* them
    while (nxt < ds_list_size(global.line_list)) {
        var next_ln = ds_list_find_value(global.line_list, nxt);
        if (ds_exists(global.gosub_targets, ds_type_map)
         && ds_map_exists(global.gosub_targets, string(next_ln))) {
            if (dbg_on(DBG_FLOW)) show_debug_message("SKIP subroutine line " + string(next_ln) + " in straight-line flow");
            nxt += 1;
        } else {
            break;
        }
    }

    line_index = nxt;

    }
} else {
    global.interpreter_running = false;
}

// ==============================
// Escape Returns to Editor
// ==============================
if (keyboard_check_pressed(vk_escape)) {
    global.current_mode = 0;
    room_goto(global.editor_return_room);
}

// ==============================
// F5 Dumps BASIC to Console
// ==============================
if (keyboard_check_released(vk_f5) && basic_run_to_console_flag == false) {
    basic_run_to_console_flag = true;
    basic_run_to_console();
}

// ==============================
// Manual Scroll (Always Available)
// ==============================
if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
if (keyboard_check_pressed(vk_pagedown)) {
    var font_height2 = string_height("A");
    var visible_lines2 = floor(room_height / font_height2) - 2;
    var total_lines2 = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);
    global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines2 - visible_lines2));
}

// (Legacy path retained; harmless with new flow)
if (global.pause_in_effect && global.inkey_mode) {
    handle_inkey_input();
}





// === END: obj_basic_interpreter.Step ===

/// @function handle_basic_command(cmd, arg)
/// @description Routes BASIC commands (and multiple colon-separated statements) to the correct functions
function handle_basic_command(cmd, arg) {
    // Rebuild the full statement (so we catch any colons in the original)
    var full = string_trim(cmd + (string_length(arg) ? " " + arg : ""));

    // Split on unquoted, top-level colons.
    var parts = split_on_unquoted_colons(full);

    // Dispatch each sub-statement in turn
    for (var i = 0; i < array_length(parts); i++) {
        var stmt = string_trim(parts[i]);
        if (stmt == "") continue;

        if (dbg_on(DBG_FLOW)) show_debug_message("DISPATCH PART: " + stmt);

        // Strip any trailing REM (apostrophe handled inside)
        stmt = strip_basic_remark(stmt);

        // Pull off the verb vs. the rest
        var sp = string_pos(" ", stmt);
        var _verb, _rest;
        if (sp > 0) {
            _verb = string_upper(string_copy(stmt, 1, sp - 1));
            _rest = string_trim(string_copy(stmt, sp + 1, string_length(stmt)));
        } else {
            _verb = string_upper(stmt);
            _rest = "";
        }

        // Skip INKEY$ as command (handled as function in evaluate_postfix)
        if (_verb == "INKEY$") {
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Ignored as command, treated as function");
            continue;
        }

        // ---------- SYNTAX GUARD: INKEY$ misuse (quote-aware) ----------
        {
            var _src  = stmt;   // stmt already had remarks stripped
            var _len  = string_length(_src);
            var _up   = string_upper(_src);

            var inq = false;
            var i2  = 1;
            var found_inkey = false;
            var eq_pos = 0;

            while (i2 <= _len) {
                var ch = string_char_at(_src, i2);
                if (ch == "\"") {
                    if (i2 < _len && string_char_at(_src, i2 + 1) == "\"") { i2 += 2; continue; }
                    inq = !inq; i2++; continue;
                }
                if (!inq) {
                    if (eq_pos == 0 && ch == "=") eq_pos = i2;
                    if (i2 + 5 <= _len && string_copy(_up, i2, 6) == "INKEY$") { found_inkey = true; break; }
                }
                i2++;
            }

            if (found_inkey) {
                var implicit_assign = false;
                if (eq_pos > 0) {
                    var lhs = string_trim(string_copy(_src, 1, eq_pos - 1));
                    if (string_length(lhs) > 0) {
                        var h  = string_upper(string_char_at(lhs, 1));
                        var oc = ord(h);
                        if (oc >= 65 && oc <= 90) implicit_assign = true;
                    }
                }
                if (!(_verb == "LET" || implicit_assign)) {
                    basic_syntax_error(
                        "INKEY$ may only appear on the right side of an assignment like  K$ = INKEY$",
                        global.current_line_number,
                        global.interpreter_current_stmt_index,
                        "INKEY_MISUSE"
                    );
                    return;
                }
            }
        }
        // ---------- END SYNTAX GUARD ----------

			// === INLINE IF COLLAPSE (robust; only within THIS colon segment) ===
			// (Do this before the generic "IF requires THEN" guard so inline IF is handled cleanly.)
			if (_verb == "IF") {
			    // Reconstruct the original physical line from the dispatcher’s position
			    var line_idx   = global.interpreter_current_line_index; // set by Step
			    var line_no    = global.line_list[| line_idx];
			    var src_line   = ds_map_find_value(global.program_map, line_no);
			    var parts_full = split_on_unquoted_colons(string_trim(src_line));

			    // Use ONLY the current colon segment
			    var p       = global.interpreter_current_stmt_index;  // set by Step
			    var segment = string_trim(parts_full[p]);
			    var seg_len = string_length(segment);
			    if (seg_len >= 2) {
			        // Find 'IF' at the true start (skip leading spaces)
			        var s = 1;
			        while (s <= seg_len && string_char_at(segment, s) == " ") s++;
			        var is_if = false;
			        if (s + 1 <= seg_len) {
			            var head2 = string_upper(string_copy(segment, s, 2));
			            is_if = (head2 == "IF");
			        }

			        if (is_if) {
			            // Position right after 'IF', then skip spaces to condition start
			            var cond_start = s + 2;
			            while (cond_start <= seg_len && string_char_at(segment, cond_start) == " ") cond_start++;
			            var after_if = (cond_start <= seg_len) ? string_copy(segment, cond_start, seg_len - cond_start + 1) : "";
			            var up_after = string_upper(after_if);

			            // Find top-level THEN (quote/paren aware)
			            var L = string_length(after_if);
			            var lvl = 0, inq = false, then_pos = 0;
			            for (var iTH = 1; iTH <= L - 4 + 1; iTH++) {
			                var chTH = string_char_at(after_if, iTH);
			                if (chTH == "\"") inq = !inq;
			                if (!inq) {
			                    if (chTH == "(") lvl++;
			                    else if (chTH == ")") lvl = max(0, lvl - 1);
			                    if (lvl == 0 && string_upper(string_copy(after_if, iTH, 4)) == "THEN") { then_pos = iTH; break; }
			                }
			            }

			            if (then_pos > 0) {

			                // --- LINT: illegal unconditional flow after inline IF on same line ---
			                // Inspect the *next* colon segment (if any). If it's an unconditional
			                // control-transfer, it will run regardless of IF truth and is almost
			                // always an authoring error.
			                if (p + 1 < array_length(parts_full)) {
			                    var next_seg_raw = string_trim(parts_full[p + 1]);
			                    next_seg_raw = strip_basic_remark(next_seg_raw);

			                    var spn  = string_pos(" ", next_seg_raw);
			                    var vraw = (spn > 0) ? string_copy(next_seg_raw, 1, spn - 1) : next_seg_raw;
			                    var vup  = string_upper(vraw);

			                    // Add more unconditional transfers if desired
			                    if (vup == "GOTO" || vup == "RETURN" || vup == "END") {
			                        basic_syntax_error(
			                            "Illegal inline flow: unconditional " + vup +
			                            " appears after an inline IF on the same line. " +
			                            "Move the " + vup + " into THEN/ELSE or onto the next line.",
			                            global.current_line_number,
			                            p + 1, // offending colon-segment index
			                            "INLINE_FLOW_HAZARD"
			                        );
			                        return;
			                    }
			                }
			                // --- END LINT ---

			                // Split condition and tail (still within this segment only)
			                var cond_src = string_trim(string_copy(after_if, 1, then_pos - 1));
			                var tail     = string_trim(string_copy(after_if, then_pos + 4, L - (then_pos + 4) + 1));

			                // Look for a top-level ELSE inside tail
			                var L2 = string_length(tail), lvl2 = 0, inq2 = false, else_pos = 0;
			                for (var iEL = 1; iEL <= L2 - 4 + 1; iEL++) {
			                    var chEL = string_char_at(tail, iEL);
			                    if (chEL == "\"") inq2 = !inq2;
			                    if (!inq2) {
			                        if (chEL == "(") lvl2++;
			                        else if (chEL == ")") lvl2 = max(0, lvl2 - 1);
			                        if (lvl2 == 0 && string_upper(string_copy(tail, iEL, 4)) == "ELSE") { else_pos = iEL; break; }
			                    }
			                }

			                var then_src = (else_pos > 0) ? string_trim(string_copy(tail, 1, else_pos - 1)) : tail;
			                var else_src = (else_pos > 0) ? string_trim(string_copy(tail, else_pos + 4, L2 - (else_pos + 4) + 1)) : "";

			                if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH (collapsed IF): IF | ARG: " + (cond_src + " THEN " + then_src + (else_src!="" ? " ELSE " + else_src : "")));

			                // Evaluate condition
			                var tok  = basic_tokenize_expression_v2(cond_src);
			                var post = infix_to_postfix(tok);
			                var val  = evaluate_postfix(post);
			                var truth = 0;
			                if (is_real(val))        truth = (val != 0);
			                else if (is_string(val)) truth = (string_length(val) > 0);

			                // Execute chosen arm via normal dispatcher (arm may contain colons)
			                if (truth) {
			                    if (then_src != "") handle_basic_command(then_src, "");
			                } else {
			                    if (else_src != "") handle_basic_command(else_src, "");
			                }

			                if (dbg_on(DBG_FLOW)) show_debug_message("INLINE IF (" + string(truth) + "): THEN='" + then_src + "' ELSE='" + else_src + "'");

			                // If INPUT/PAUSE occurred inside the THEN/ELSE arm,
			                // schedule resume at NEXT colon segment and yield now.
			                if (global.pause_in_effect || global.awaiting_input) {
			                    if (dbg_on(DBG_FLOW)) show_debug_message("INLINE IF: pausing after arm — scheduling resume at next segment");
			                    global.interpreter_use_stmt_jump = true;
			                    global.interpreter_target_line   = line_idx;
			                    global.interpreter_target_stmt   = p + 1;  // resume at next colon slot (or EOL)
			                    return; // yield now
			                }

			                // Normal path (no INPUT): advance to NEXT colon segment on this line
			                global.interpreter_use_stmt_jump = true;
			                global.interpreter_target_line   = line_idx;
			                global.interpreter_target_stmt   = p + 1;
			                break; // done with this segment
			            }
			            // If we didn’t find THEN, fall through to structured IF guard/handler below.
			        }
			    }
			}


        // Guard: IF must contain THEN in the same statement (only for non-inline handling)
        if (_verb == "IF" && string_pos("THEN", string_upper(_rest)) <= 0) {
            basic_syntax_error(
                "IF requires THEN",
                /* line_no */ undefined,
                /* stmt_idx */ global.interpreter_current_stmt_index,
                "IF REQUIRES THEN"
            );
            return;
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH: " + _verb + " | ARG: " + _rest);

        switch (_verb) {

            case "PRINT":
                if (global.current_mode >= 1) {
                    basic_cmd_print_mode1(_rest);
                } else {
                    basic_cmd_print(_rest, global.current_line_number);
                }
                break;

            case "LET":       basic_cmd_let(_rest); break;
            case "GOTO":      basic_cmd_goto(_rest); break;
            case "INPUT":     basic_cmd_input(_rest); break;
            case "COLOR":     basic_cmd_color(_rest); break;

            case "CLS":
                if (global.current_mode >= 1) { basic_cmd_cls_mode1(); }
                else                           { basic_cmd_cls(); }
                break;

            // Structured control flow (multi-line)
            case "IF":        basic_cmd_if(_rest); break;
            case "ELSEIF":    basic_cmd_elseif(_rest); break;
            case "ELSE":      basic_cmd_else(); break;
            case "ENDIF":     basic_cmd_endif(); break;

            case "FOR":       basic_cmd_for(_rest); break;
            case "NEXT":      basic_cmd_next(_rest); break;
            case "WHILE":     basic_cmd_while(_rest); break;
            case "WEND":      basic_cmd_wend(); break;

            case "GOSUB":     basic_cmd_gosub(_rest); break;
            case "RETURN":    basic_cmd_return(); break;

            case "BGCOLOR":   basic_cmd_bgcolor(_rest); break;
            case "PAUSE":     basic_cmd_pause(); break;
            case "MODE":      basic_cmd_mode(_rest); break;
            case "CLSCHAR":   basic_cmd_clschar(_rest); break;
            case "PSET":      basic_cmd_pset(_rest); break;
            case "CHARAT":    basic_cmd_charat(_rest); break;
            case "PRINTAT":   basic_cmd_printat(_rest); break;
            case "FONT":      basic_cmd_font(_rest); break;
            case "DIM":       basic_cmd_dim(_rest); break; // 1-D arrays

            case "END":       basic_cmd_end(); break;

            case "REM":
                // no-op
                break;

            case "DATA":
                // Runtime no-op (DATA was harvested at load time)
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA (runtime): no-op");
                break;

            case "READ":      basic_cmd_read(_rest); break;
            case "RESTORE":   basic_cmd_restore(_rest); break;

            case "LOCATE":    basic_cmd_locate(_rest); break;
            case "SCROLL":    basic_cmd_scroll(_rest); break;

            case "POS":
                // If it's being used as a variable assignment (e.g., "POS = 1"),
                // treat it as an implicit LET. Otherwise it's a function token in expressions,
                // so do nothing at command level.
                if (string_pos("=", _rest) > 0) {
                    basic_cmd_let(_verb + " " + _rest);
                }
                break;

            case "SCREEN":    // handled as function in expressions
            case "POINT":     // handled as function in expressions
            //case "POS":     // handled as function in expressions
            case "CSRLIN":    // handled as function in expressions
            case "TAB":       // handled in PRINT processing
            case "SPC":       // handled in PRINT processing
                break;

            case "FONTSET":   basic_cmd_fontset(_rest); break;

			case "BEEP":     basic_cmd_beep(_rest); break;

            default:
                // implicit LET?  e.g.  "X = 5"
                if (string_pos("=", _verb + " " + _rest) > 0) {
                    basic_cmd_let(_verb + " " + _rest);
                } else {
                    basic_syntax_error("Unknown command: " + _verb,
                        global.current_line_number,
                        global.interpreter_current_stmt_index,
                        "UNKNOWN_COMMAND");
                }
                break;
        }

        // === YIELD GATE: if any command armed INPUT/PAUSE, stop consuming this line’s remaining segments
        if (global.pause_in_effect || global.awaiting_input) {
            if (dbg_on(DBG_FLOW)) show_debug_message("DISPATCH: pause/input armed → yielding after segment");
            return;
        }
    }
}

/// scripts/save_program/save_program.gml
/// Robust save: finds program lines from several common containers and writes them.
/// Logs exactly what was written (count + source), so we can confirm why a file went empty.

function save_program_as(filename)
{
    // --- Normalize filename
    filename = string_trim(filename);
    if (string_length(filename) == 0) { show_error_message("NO FILENAME PROVIDED"); return; }
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename)-2);
    }
    filename = string_replace_all(filename, "/", "_");
    filename = string_replace_all(filename, "\\", "_");
    filename = string_replace_all(filename, "..", "_");
    filename = string_replace_all(filename, ".bas", "");

    // --- Resolve save directory (desktop-first)
    var save_dir = get_save_directory();
    if (!is_string(save_dir) || string_length(save_dir) == 0) {
        save_dir = working_directory;
        var _last = string_copy(save_dir, string_length(save_dir), 1);
        if (_last != "/" && _last != "\\") save_dir += (os_type == os_windows) ? "\\" : "/";
       if (dbg_on(DBG_FLOW)) show_debug_message("FALLBACK save_dir -> '" + save_dir + "'");
    }
    if (os_type == os_windows || os_type == os_macosx || os_type == os_linux) {
        if (!directory_exists(save_dir)) directory_create(save_dir);
        if (!directory_exists(save_dir)) { show_error_message("COULD NOT CREATE SAVE FOLDER:\n" + string(save_dir)); return; }
    }

    var save_path = save_dir + filename + ".bas";
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE -> " + save_path);

    // --- Collect lines from likely sources
    var lines_list = ds_list_create(); // will hold strings to write, in order
    var source_used = "NONE";
    var ed = instance_find(obj_editor, 0);

    if (ed != noone) {
        // 1) obj_editor.program_lines (array)
        if (variable_instance_exists(ed, "program_lines") && is_array(ed.program_lines)) {
            for (var i = 0; i < array_length(ed.program_lines); i++) {
                ds_list_add(lines_list, string(ed.program_lines[i]));
            }
            if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (array)";
        }

        // 2) obj_editor.program_lines (ds_list)
        if (source_used == "NONE" && variable_instance_exists(ed, "program_lines") &&
            ds_exists(ed.program_lines, ds_type_list)) {
            var n = ds_list_size(ed.program_lines);
            for (var j = 0; j < n; j++) {
                ds_list_add(lines_list, string(ds_list_find_value(ed.program_lines, j)));
            }
            if (n > 0) source_used = "obj_editor.program_lines (ds_list)";
        }

/// >>> INSERT START: 2c) obj_editor.program_lines (ds_map) <<<
        if (source_used == "NONE" && variable_instance_exists(ed, "program_lines") &&
            ds_exists(ed.program_lines, ds_type_map)) {

            // Gather keys
            var epl_keys = ds_list_create();
            var epl_k = ds_map_find_first(ed.program_lines);
            while (epl_k != undefined) {
                ds_list_add(epl_keys, epl_k);
                epl_k = ds_map_find_next(ed.program_lines, epl_k);
            }

            // Sort numerically if keys are numbers
            var epl_numeric = true;
            for (var ei = 0; ei < ds_list_size(epl_keys); ei++) {
                if (!is_real(ds_list_find_value(epl_keys, ei))) { epl_numeric = false; break; }
            }
            if (epl_numeric) ds_list_sort(epl_keys, true); // ascending

            // Emit "lineNum content" in key order
            for (var ej = 0; ej < ds_list_size(epl_keys); ej++) {
                var _ln  = ds_list_find_value(epl_keys, ej);
                var _val = ds_map_find_value(ed.program_lines, _ln);
                ds_list_add(lines_list, string(_ln) + " " + string(_val));
            }

            if (ds_list_size(lines_list) > 0) {
                source_used = "obj_editor.program_lines (ds_map)";
                if (dbg_on(DBG_IO)) show_debug_message("SAVE: pulled " + string(ds_list_size(lines_list)) + " lines from obj_editor.program_lines (map)");
            }
            ds_list_destroy(epl_keys);
        }
        /// <<< INSERT END <<<




        // 3) Common ds_map containers keyed by line numbers (we’ll join "lineNum + space + content")
        if (source_used == "NONE") {
            var map_names = [
                "program_map", "program_lines_map", "basic_program",
                "lines_map", "line_store", "program"
            ];
            for (var m = 0; m < array_length(map_names); m++) {
                var nm = map_names[m];
                if (variable_instance_exists(ed, nm) && ds_exists(ed[? nm], ds_type_map)) {
                    // Gather keys
                    var keys = ds_list_create();
                    var k = ds_map_find_first(ed[? nm]);
                    while (k != undefined) {
                        ds_list_add(keys, k);
                        k = ds_map_find_next(ed[? nm], k);
                    }
                    // Sort numerically if keys look like numbers
                    // (GameMaker sorts as strings; so we’ll bubble minimal numeric ordering)
                    var numeric = true;
                    for (var t = 0; t < ds_list_size(keys); t++) {
                        if (!is_real(ds_list_find_value(keys, t))) { numeric = false; break; }
                    }
                    if (numeric) ds_list_sort(keys, true); // ascending

                    // Emit "lineNum content" in key order
                    for (var t2 = 0; t2 < ds_list_size(keys); t2++) {
                        var _ln = ds_list_find_value(keys, t2);
                        var val = ds_map_find_value(ed[? nm], _ln);
                        // if val already includes line number, this will double it; but that’s rare.
                        ds_list_add(lines_list, string(_ln) + " " + string(val));
                    }
                    if (ds_list_size(lines_list) > 0) {
                        source_used = "obj_editor." + nm + " (ds_map)";
                        ds_list_destroy(keys);
                        break;
                    }
                    ds_list_destroy(keys);
                }
            }
        }
    }

    // 4) Global fallbacks
    if (source_used == "NONE" && variable_global_exists("program_lines")) {
        if (is_array(global.program_lines)) {
            for (var g1 = 0; g1 < array_length(global.program_lines); g1++) {
                ds_list_add(lines_list, string(global.program_lines[g1]));
            }
            if (ds_list_size(lines_list) > 0) source_used = "global.program_lines (array)";
        } else if (ds_exists(global.program_lines, ds_type_list)) {
            var gn = ds_list_size(global.program_lines);
            for (var g2 = 0; g2 < gn; g2++) {
                ds_list_add(lines_list, string(ds_list_find_value(global.program_lines, g2)));
            }
            if (gn > 0) source_used = "global.program_lines (ds_list)";
        }
    }
	
	/// >>> INSERT START: support global.program_lines when it's a MAP <<<
    if (source_used == "NONE" && variable_global_exists("program_lines") && ds_exists(global.program_lines, ds_type_map)) {
        var gpl_keys = ds_list_create();
        var gpl_k = ds_map_find_first(global.program_lines);
        while (gpl_k != undefined) {
            ds_list_add(gpl_keys, gpl_k);
            gpl_k = ds_map_find_next(global.program_lines, gpl_k);
        }
        // numeric-sort keys if they’re numbers
        var gpl_numeric = true;
        for (var gpi = 0; gpi < ds_list_size(gpl_keys); gpi++) {
            if (!is_real(ds_list_find_value(gpl_keys, gpi))) { gpl_numeric = false; break; }
        }
        if (gpl_numeric) ds_list_sort(gpl_keys, true);

        for (var gpj = 0; gpj < ds_list_size(gpl_keys); gpj++) {
            var gln  = ds_list_find_value(gpl_keys, gpj); // line number
            var gval = ds_map_find_value(global.program_lines, gln); // code
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        if (ds_list_size(lines_list) > 0) {
            source_used = "global.program_lines (ds_map)";
            if (dbg_on(DBG_IO)) show_debug_message("SAVE: pulled " + string(ds_list_size(lines_list)) + " lines from global.program_lines (map)");
        }
        ds_list_destroy(gpl_keys);
    }
    /// <<< INSERT END <<<
	
    if (source_used == "NONE" && variable_global_exists("program_map") && ds_exists(global.program_map, ds_type_map)) {
        var gkeys = ds_list_create();
        var gk = ds_map_find_first(global.program_map);
        while (gk != undefined) { ds_list_add(gkeys, gk); gk = ds_map_find_next(global.program_map, gk); }
        var gnum = true;
        for (var gg = 0; gg < ds_list_size(gkeys); gg++) if (!is_real(ds_list_find_value(gkeys, gg))) { gnum = false; break; }
        if (gnum) ds_list_sort(gkeys, true);
        for (var gh = 0; gh < ds_list_size(gkeys); gh++) {
            var gln = ds_list_find_value(gkeys, gh);
            var gval = ds_map_find_value(global.program_map, gln);
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        if (ds_list_size(lines_list) > 0) source_used = "global.program_map (ds_map)";
        ds_list_destroy(gkeys);
    }

    // --- Diagnostics before writing
    var total = ds_list_size(lines_list);
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE SOURCE -> " + source_used + " | lines=" + string(total));
    if (total > 0) {
        // show first couple lines for verification
        var preview_max = min(3, total);
        for (var pv = 0; pv < preview_max; pv++) {
           if (dbg_on(DBG_FLOW)) show_debug_message("LINE[" + string(pv) + "] -> " + string(ds_list_find_value(lines_list, pv)));
        }
    }

    // --- Open file and write
    var fh = file_text_open_write(save_path);
    if (fh < 0) { show_error_message("COULD NOT OPEN FILE FOR WRITE:\n" + filename + ".bas"); ds_list_destroy(lines_list); return; }

    for (var w = 0; w < total; w++) {
        file_text_write_string(fh, string(ds_list_find_value(lines_list, w)));
        file_text_writeln(fh); // newline
    }
    file_text_close(fh);

    var exists_after = file_exists(save_path);
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE EXISTS AFTER -> " + string(exists_after));

    if (total == 0) {
        show_error_message("NOTHING TO SAVE — no program lines found");
    } else if (!exists_after) {
        show_error_message("SAVE REPORTED OK BUT FILE NOT FOUND:\n" + save_path);
    } else if (ed != noone && variable_instance_exists(ed, "status_message")) {
        ed.status_message = "FILE SAVED: " + filename + ".bas (" + string(total) + " lines)";
    }

    ds_list_destroy(lines_list);
}

function run_program() {
    if (dbg_on(DBG_FLOW)) show_debug_message("RUN_PROGRAM START - color is: " + string(global.current_draw_color));
	// Always remember where we launched from (editor room)
	global.editor_return_room = rm_editor;

    // ── Guard: no program ────────────────────────────────────────────────
    if (!ds_exists(global.line_numbers, ds_type_list) || ds_list_size(global.line_numbers) == 0) {
        show_error_message("NO PROGRAM");
        return;
    }

    // ── Sync editor → runtime structures used by interpreter/validator ──
    // program_map (lineNo -> code)
    if (!ds_exists(global.program_map, ds_type_map)) {
        global.program_map = ds_map_create();
    } else {
        ds_map_clear(global.program_map);
    }
    ds_map_copy(global.program_map, global.program_lines);

    // line_list (sorted list of line numbers)
    if (!ds_exists(global.line_list, ds_type_list)) {
        global.line_list = ds_list_create();
    } else {
        ds_list_clear(global.line_list);
    }
    for (var _i = 0; _i < ds_list_size(global.line_numbers); _i++) {
        ds_list_add(global.line_list, global.line_numbers[| _i]);
    }
    ds_list_sort(global.line_list, true);

    // (Optional archival copies)
    if (!ds_exists(global.basic_program, ds_type_map)) {
        global.basic_program = ds_map_create();
    } else {
        ds_map_clear(global.basic_program);
    }
    ds_map_copy(global.basic_program, global.program_lines);

    if (!variable_global_exists("basic_line_numbers") || !ds_exists(global.basic_line_numbers, ds_type_list)) {
        global.basic_line_numbers = ds_list_create();
    } else {
        ds_list_clear(global.basic_line_numbers);
    }
    ds_list_copy(global.basic_line_numbers, global.line_numbers);
	
// === Build call-only subroutine index (gosub_targets) ===
// Place this RIGHT AFTER you finalize global.program_map & global.line_list
// (i.e., after ds_list_sort(global.line_list, true) / your copy steps)

// --- Build call-only subroutine set (targets of GOSUB) ---
// Make sure the variable exists before we touch it
if (!variable_global_exists("gosub_targets")) {
    global.gosub_targets = ds_map_create();
} else if (!ds_exists(global.gosub_targets, ds_type_map)) {
    // If something else used the name, reset it to a map
    global.gosub_targets = ds_map_create();
} else {
    ds_map_clear(global.gosub_targets);
}

// Scan the current program using the same ordering the interpreter uses
// (global.line_list must already be built & sorted)
for (var i = 0; i < ds_list_size(global.line_list); i++) {
    var _ln  = global.line_list[| i];
    var raw  = ds_map_find_value(global.program_map, _ln);
    if (is_undefined(raw)) continue;

    // Split the physical line into colon segments
    var parts = split_on_unquoted_colons(string_trim(raw));
    for (var p = 0; p < array_length(parts); p++) {
        var stmt = string_trim(parts[p]);
        if (stmt == "") continue;

        // Strip remarks BEFORE tokenizing (handles: GOSUB 1000 ' comment)
        stmt = strip_basic_remark(stmt);
        if (stmt == "") continue;

        // verb/rest
        var sp  = string_pos(" ", stmt);
        var v0  = (sp > 0) ? string_upper(string_copy(stmt, 1, sp - 1)) : string_upper(stmt);
        var r0  = (sp > 0) ? string_trim(string_copy(stmt, sp + 1, string_length(stmt))) : "";

        if (v0 == "GOSUB") {
            // Keep only first token after GOSUB; ignore expressions during pre-scan
            var tok = r0;
            var sp2 = string_pos(" ", tok);
            if (sp2 > 0) tok = string_copy(tok, 1, sp2 - 1);
            tok = string_trim(tok);

            if (is_numeric_string(tok)) {
                var tgt = real(tok);
                ds_map_set(global.gosub_targets, string(tgt), true);
            }
        }
    }
}
// --- end GOSUB pre-scan ---


	
	
	

    // ── Make sure output buffers exist BEFORE validation (errors print into them) ──
    if (!is_real(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)) {
        global.output_lines = ds_list_create();
    }
    if (!is_real(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        global.output_colors = ds_list_create();
    }

    // Per-run flag (safe init)
    if (is_undefined(global._syntax_error_just_emitted)) global._syntax_error_just_emitted = false;
    global._syntax_error_just_emitted = false;

    // ── Build helpers that validators/dispatchers rely on ─────────────────
    build_data_streams();     // harvest DATA / prep READ/RESTORE
    build_if_block_map();     // multi-line IF/ELSE structure
    if (dbg_on(DBG_FLOW)) show_debug_message("IF-block map built (" + string(ds_map_size(global.if_block_map)) + " blocks)");

// === GOSUB PRE-SCAN: build call-only subroutine set ===
// ANCHOR: place this immediately after your "IF-block map built (...)" log in run_program

// Ensure the map exists
if (!variable_global_exists("gosub_targets") || !ds_exists(global.gosub_targets, ds_type_map)) {
    global.gosub_targets = ds_map_create();
} else {
    ds_map_clear(global.gosub_targets);
}

// Walk physical line order used by the interpreter
for (var i = 0; i < ds_list_size(global.line_list); i++) {
    var _ln  = global.line_list[| i];
    var raw  = ds_map_find_value(global.program_map, _ln);
    if (is_undefined(raw)) continue;

    // Split line into colon segments
    var parts = split_on_unquoted_colons(string_trim(raw));
    for (var p = 0; p < array_length(parts); p++) {
        var stmt = string_trim(parts[p]);
        if (stmt == "") continue;

        // Strip inline remark BEFORE tokenizing (handles: GOSUB 1000 ' comment)
        stmt = strip_basic_remark(stmt);
        if (stmt == "") continue;

        // verb/rest
        var sp  = string_pos(" ", stmt);
        var v0  = (sp > 0) ? string_upper(string_copy(stmt, 1, sp - 1)) : string_upper(stmt);
        var r0  = (sp > 0) ? string_trim(string_copy(stmt, sp + 1, string_length(stmt))) : "";

        if (v0 == "GOSUB") {
            // consider only first token after GOSUB for pre-scan (numeric labels)
            var tok = r0;
            var sp2 = string_pos(" ", tok);
            if (sp2 > 0) tok = string_copy(tok, 1, sp2 - 1);
            tok = string_trim(tok);

            if (is_numeric_string(tok)) {
                ds_map_set(global.gosub_targets, string(real(tok)), true);
            }
        }
    }
}
// === end GOSUB PRE-SCAN ===


    // ── VALIDATE: visible errors + correct room ───────────────────────────
    // Assumes basic_validate_program() exists.
    if (!basic_validate_program()) {
        // Validator already printed a visible error & set end flags.
        // Ensure the user can see it.
        if (room != rm_basic_interpreter) room_goto(rm_basic_interpreter);
        return;
    }

    // ── Clean start: clear output buffers for a fresh run ─────────────────
    ds_list_clear(global.output_lines);
    ds_list_clear(global.output_colors);
    global.print_line_buffer = "";

    // ── Interpreter state ─────────────────────────────────────────────────
    global.interpreter_input    = "";
    global.awaiting_input       = false;
    global.input_target_var     = "";
    global.interpreter_running  = true;
    global.program_has_ended    = false;

    global.pause_in_effect      = false;
    global.pause_mode           = false;
    global.input_expected       = false;

    global.inkey_mode           = false;
    global.inkey_waiting        = false;
    global.inkey_captured       = "";
    global.inkey_target_var     = "";

    // Set draw color for this run (your existing choice)
    global.current_draw_color = make_color_rgb(255, 191, 64); // Amber

    // Line navigation
    global.interpreter_current_line_index = 0;
    global.interpreter_next_line          = -1;
    global.interpreter_use_stmt_jump      = false;
    global.interpreter_target_line        = -1;
    global.interpreter_target_stmt        = 0;
    global.interpreter_resume_stmt_index  = 0;
    global.current_line_number            = (ds_list_size(global.line_list) > 0)
                                           ? (global.line_list[| 0]) : -1;

    // Where to return when done
    global.editor_return_room = room;

    // Go to interpreter room (only if not already there)
    if (room != rm_basic_interpreter) room_goto(rm_basic_interpreter);
}

/// @event obj_globals/Create
// obj_globals → Create Event



var save_dir = get_save_directory();
if (save_dir != "") {
    if (!directory_exists(save_dir)) {
        directory_create(save_dir);
    }
}

global.debug_mask = DBG_ALL;// allow all debug;
//global.debug_mask = 0; //No Debug

global.dbg_dropped_count = 0;

global.justreturned = 0;
global.program_filename = "";
global.username = "";
global.editor_spawned = false;

// Program and source management
global.program_lines = ds_map_create();
global.basic_program = ds_map_create();
global.program_map  = ds_map_create();

// Line tracking
global.line_list    = ds_list_create();
global.line_numbers = ds_list_create();
global.undo_stack = ds_list_create();
global.output_lines = ds_list_create();
global.output_colors = ds_list_create();
global.input_history = ds_list_create();

// Interpreter control stacks
global.gosub_stack = ds_stack_create();
global.for_stack   = ds_stack_create();
global.while_stack = ds_stack_create();
global.history_index = -1;

// IF…ELSE block handling
global.if_block_map = ds_map_create();
global.if_stack     = ds_stack_create();

// Spawn the editor after globals are ready
instance_create_layer(0, 0, "Instances", obj_editor);

// Initialize variable store
if (!variable_global_exists("basic_variables")) {
    global.basic_variables = ds_map_create();
}

// Output buffer
global.print_line_buffer = "";

// Color settings
global.basic_text_color = make_color_rgb(255, 191, 64);
global.current_draw_color = c_green;
global.background_draw_color = c_black;
global.background_draw_enabled = false;

// Input / Pause
global.awaiting_input = false;
global.input_target_var = "";
global.interpreter_input = "";
global.interpreter_cursor_pos = 0;
global.interpreter_running = false;
global.last_interpreter_string = "";
global.program_has_ended = false;
global.pause_in_effect = false;
global.input_expected = false;
global.pause_mode = false;

// Scrolling control
global.scroll_offset = 0;
global.scroll_lock = false;

// Named colors
global.colors = ds_map_create();
global.colors[? "RED"]     = c_red;
global.colors[? "GREEN"]   = c_green;
global.colors[? "BLUE"]    = c_blue;
global.colors[? "CYAN"]    = c_teal;
global.colors[? "MAGENTA"] = c_fuchsia;
global.colors[? "YELLOW"]  = c_yellow;
global.colors[? "WHITE"]   = c_white;
global.colors[? "BLACK"]   = c_black;
global.colors[? "GRAY"]    = c_gray;
global.colors[? "ORANGE"]  = c_orange;
global.colors[? "LIME"]    = c_lime;
global.colors[? "NAVY"] = make_color_rgb(0, 0, 128);
global.colors[? "DKGRAY"] = make_color_rgb(64, 64, 64);

// MODE control
global.current_mode = 0; // 0 = Text, 1 = Tile graphics, 2 = Pixel graphics
global.mode_rooms = ds_map_create();
global.mode_rooms[? 0] = rm_basic_interpreter; // Text
global.mode_rooms[? 1] = rm_mode1_graphics;    // Tile graphics
global.mode_rooms[? 2] = rm_mode2_pixel;       // Pixel graphics

// MODE 1 sprite sheet container
// FONT registry for MODE 1
global.font_sheets = ds_map_create();

// Base character sheet
ds_map_add(global.font_sheets, "DEFAULT", spr_charactersheet);

// Special 32×32 or alt glyphs
ds_map_add(global.font_sheets, "SPECIAL", spr_charactersheet_special);

// 16×16 set
ds_map_add(global.font_sheets, "16x16", spr_charactersheet_16x16);
ds_map_add(global.font_sheets, "16x16_SPECIAL", spr_charactersheet_16x16_special);

// 8×8 set
ds_map_add(global.font_sheets, "8x8", spr_charactersheet_8x8);
ds_map_add(global.font_sheets, "DEFAULT_32", spr_charactersheet);
ds_map_add(global.font_sheets, "DEFAULT_16", spr_charactersheet_16x16);
ds_map_add(global.font_sheets, "DEFAULT_8",  spr_charactersheet_8x8);

ds_map_add(global.font_sheets, "SPECIAL_16", spr_charactersheet_16x16_special);

// Initialize active sheet
global.mode1_active_sprite   = global.font_sheets[? "DEFAULT_32"];
global.mode1_active_font_key = "DEFAULT_32";
global.mode1_cell_px         = 32;

global.active_font_name = "DEFAULT";
global.active_font_sprite = global.font_sheets[? global.active_font_name];

global.grid_refresh_needed = false;
global.grid_refresh_char = 32;

global.basic_arrays = ds_map_create(); // name (string) → ds_list

global.interpreter_target_line = -1;
global.interpreter_target_stmt = 0;
global.interpreter_use_stmt_jump = false;
global.interpreter_resume_stmt_index = 0;

global.interpreter_current_stmt_index = 0;

global.config = ds_map_create();
global.config[? "max_line_number"] = 65535;
global.config[? "max_history_size"] = 50;


// === DATA/READ globals ===
// Create once; the builder will clear/reuse it each run.
if (!variable_global_exists("data_streams") || !ds_exists(global.data_streams, ds_type_map)) {
    global.data_streams = ds_map_create();
    if (dbg_on(DBG_FLOW)) show_debug_message("globals: created global.data_streams");
}


if (!variable_global_exists("__inkey_queue")) {
    global.__inkey_queue = ds_queue_create();
}

global.inkey_mode = false; 
global.pause_in_effect = false; 
global.inkey_waiting    = false;
global.inkey_captured   = "";
global.inkey_target_var = "";
global.interpreter_current_line_index = 0; 

// Archival copy of line numbers used by run_program
global.basic_line_numbers = ds_list_create();
global._syntax_error_just_emitted = false;

// optional, if you use these
global._validator_header_emitted = false;
global._abort_after_validation   = false;

// Where to return when leaving the interpreter
global.editor_return_room = room; // whatever room the editor lives in at startup

global.config[? "show_error_hints"] = true; // show compact help lines under syntax errors

global.screen_edit_mode = false; //for scree editing
if (dbg_on(DBG_FLOW)) show_debug_message("GLOBALS: screen_edit_mode initialized to false");


/// Put near your other globals the first time you use them:
if (!variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;
if (!variable_global_exists("__html_dir_open_time")) global.__html_dir_open_time = 0;

if (!variable_global_exists("DEBUG_INPUT")) global.DEBUG_INPUT = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }
	
global.print_zone = 14; // width
global.print_tab_mode = 1; 
// 0 = zones (BASIC default), 1 = fixed-width tabs
// === Beep subsystem ===
global.beep_tempo = 120; // BPM
global.beep_waiting = false;
global.beep_release_time = 0;

// Point this at your middle-C piezo sample asset
global.beep_sound = snd_beep_c4;  // <-- replace with your actual sound asset name
// Map any you actually have; missing ones are auto-skipped
global.beep_samples = ds_map_create();
ds_map_set(global.beep_samples, "C2", snd_beep_c4_3);
ds_map_set(global.beep_samples, "C3", snd_beep_c4_2);
ds_map_set(global.beep_samples, "C4", snd_beep_c4);
ds_map_set(global.beep_samples, "C5", snd_beep_c4_5);
ds_map_set(global.beep_samples, "C6", snd_beep_c4_6);

// Fallback single-sample (still supported)
global.beep_sound = snd_beep_c4;
global.beep_seq_active = 0;
global.beep_break_requested = false;

 global.gosub_targets = ds_map_create();
/// @script basic_cmd_input
/// @description Prompt the user with a text and await input into a variable

/// @script basic_cmd_input
/// @description Simple INPUT command that works with existing keyboard handling
function basic_cmd_input(arg) {
    var s = string_trim(arg);
    var prompt = "";
    var varName = "";

    // Parse INPUT syntax: INPUT "prompt", VAR or INPUT VAR
    var comma_pos = string_pos(",", s);
    var semicolon_pos = string_pos(";", s);
    
    // Find first separator (comma or semicolon)
    var sep_pos = 0;
    if (comma_pos > 0 && semicolon_pos > 0) {
        sep_pos = min(comma_pos, semicolon_pos);
    } else if (comma_pos > 0) {
        sep_pos = comma_pos;
    } else if (semicolon_pos > 0) {
        sep_pos = semicolon_pos;
    }
    
    if (sep_pos > 0) {
        // Has prompt: INPUT "prompt", VAR
        prompt = string_trim(string_copy(s, 1, sep_pos - 1));
        varName = string_upper(string_trim(string_copy(s, sep_pos + 1, string_length(s) - sep_pos)));
        
        // Remove quotes from prompt if present
        if (string_length(prompt) >= 2 
            && string_char_at(prompt, 1) == "\"" 
            && string_char_at(prompt, string_length(prompt)) == "\"") {
            prompt = string_copy(prompt, 2, string_length(prompt) - 2);
        }
    } else {
        // No prompt: INPUT VAR
        varName = string_upper(s);
        //prompt = "? "; // Default prompt
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Variable='" + varName + "', Prompt='" + prompt + "'");
    
    // Display the prompt
    if (prompt != "") {
        ds_list_add(global.output_lines, prompt);
        ds_list_add(global.output_colors, global.basic_text_color);
    }
    
    // Set up input state for your existing keyboard handler
    global.awaiting_input = true;
    global.pause_mode = false;
    global.input_expected = true;
    global.input_target_var = varName;
    global.interpreter_input = ""; // Clear any existing input buffer
    
// Initialize the variable only if absent; avoid numeric 0 pre-seed
 varName = basic_normvar(varName); // ensure canonical now
if (!ds_map_exists(global.basic_variables, varName)) {
    // Seed both kinds to empty string; numeric coercion happens on commit
    global.basic_variables[? varName] = "";
}

    
    if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Awaiting input for variable " + varName);
	
	// NEW: schedule "resume at next colon segment" and yield now
	global.interpreter_use_stmt_jump = true;
	global.interpreter_target_line   = global.interpreter_current_line_index;
	global.interpreter_target_stmt   = global.interpreter_current_stmt_index + 1;
	if (dbg_on(DBG_FLOW)) show_debug_message(
	    "INPUT: scheduling resume at stmt " + string(global.interpreter_target_stmt)
	    + " on line-index " + string(global.interpreter_target_line)
	);
	return; // IMPORTANT: stop dispatching the rest of this line now	
	
	
	
	
}
/*function basic_cmd_input(arg) {
    var s = string_trim(arg);
    var rawPrompt = "";
    var varName   = "";

    // 1) Primary split: first top-level ';' or ',' (quote-aware)
    var sep_pos = 0;
    var sep_ch  = "";
    var in_q = false;
    var L = string_length(s);
    for (var i = 1; i <= L; i++) {
        var ch = string_char_at(s, i);
        if (ch == "\"") { in_q = !in_q; continue; }
        if (!in_q && (ch == ";" || ch == ",")) { sep_pos = i; sep_ch = ch; break; }
    }

    if (sep_pos > 0) {
        rawPrompt = string_trim(string_copy(s, 1, sep_pos - 1));
        varName   = string_upper(string_trim(string_copy(s, sep_pos + 1, L - sep_pos)));
    } else {
        // 2) Fallback: starts with a quoted prompt but no separator was detected (e.g., `"PROMPT" ; VAR`)
        if (L >= 2 && string_char_at(s, 1) == "\"") {
            // find closing quote
            var close = 0;
            for (var k = 2; k <= L; k++) {
                if (string_char_at(s, k) == "\"") { close = k; break; }
            }
            if (close > 0) {
                rawPrompt = string_copy(s, 2, close - 2); // inside quotes
                var rest = string_trim(string_copy(s, close + 1, L - close));
                // consume optional separator and following spaces
                if (string_length(rest) > 0) {
                    var first = string_char_at(rest, 1);
                    if (first == ";" || first == ",") {
                        rest = string_trim(string_delete(rest, 1, 1));
                    }
                }
                varName = string_upper(string_trim(rest));
            } else {
                // no closing quote → treat entire thing as var
                varName = string_upper(s);
            }
        } else {
            // no prompt provided; entire arg is the variable name
            varName = string_upper(s);
        }
    }

    // 3) If prompt still has surrounding quotes, strip them
    if (string_length(rawPrompt) >= 2
        && string_char_at(rawPrompt, 1) == "\""
        && string_char_at(rawPrompt, string_length(rawPrompt)) == "\"")
    {
        rawPrompt = string_copy(rawPrompt, 2, string_length(rawPrompt) - 2);
    }

    // 4) Emit the prompt (append a space if missing) 
    if (rawPrompt != "") {
        if (string_char_at(rawPrompt, string_length(rawPrompt)) != " ") rawPrompt += " ";
        ds_list_add(global.output_lines, rawPrompt);
        ds_list_add(global.output_colors, global.basic_text_color);
        if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Prompt='" + rawPrompt + "'");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: No prompt (default '? ')");
    }

    // 5) Seed the variable (string vars end with $, others numeric)
    if (string_length(varName) > 0 && string_char_at(varName, string_length(varName)) == "$") {
        global.basic_variables[? varName] = "";
    } else {
        global.basic_variables[? varName] = "0";
    }

    // 6) Enter input mode
    global.awaiting_input   = true;
    global.pause_mode       = false;
    global.input_expected   = true;
    global.input_target_var = varName;

    if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Awaiting input for variable " + varName);
}

/// @function basic_cmd_for(arg) 
/// @description Parses and handles BASIC FOR loop initialization (spacing-tolerant; optional STEP)
function basic_cmd_for(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Entering handler with argument: '" + string(arg) + "'");

    // 1) Parse "VAR = start TO end [STEP step]"
    var raw   = string_trim(string(arg));
    var eqpos = string_pos("=", raw);
    if (eqpos <= 0) {
        basic_syntax_error("FOR missing '=' - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var varname = string_upper(string_trim(string_copy(raw, 1, eqpos - 1)));
    if (varname == "") {
        basic_syntax_error("FOR missing variable name before '='",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var rhs = string_trim(string_copy(raw, eqpos + 1, string_length(raw) - eqpos));

    // find TO
    var to_at = -1;
    for (var p = 1; p <= string_length(rhs) - 1; p++) {
        if (string_upper(string_copy(rhs, p, 2)) == "TO") { to_at = p; break; }
    }
    if (to_at < 0) {
        basic_syntax_error("FOR missing TO - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var start_expr = string_trim(string_copy(rhs, 1, to_at - 1));
    var after_to   = string_trim(string_copy(rhs, to_at + 2, string_length(rhs) - (to_at + 1)));
    if (start_expr == "" || after_to == "") {
        basic_system_message("SYNTAX ERROR IN FOR (incomplete expressions): " + raw);
        global.interpreter_running = false;
        return;
    }

    // optional STEP
    var step_expr = "1";
    var to_expr   = after_to;

    var step_at = -1;
    for (var q = 1; q <= string_length(after_to) - 3; q++) {
        if (string_upper(string_copy(after_to, q, 4)) == "STEP") { step_at = q; break; }
    }
    if (step_at > 0) {
        to_expr   = string_trim(string_copy(after_to, 1, step_at - 1));
        step_expr = string_trim(string_copy(after_to, step_at + 4, string_length(after_to) - (step_at + 3)));
        if (step_expr == "") step_expr = "1";
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Header pieces → var='" + varname
        + "' | start='" + start_expr + "' | to='" + to_expr + "' | step='" + step_expr + "'");

    // 2) Evaluate start, to, step
    var start_tokens  = basic_tokenize_expression_v2(start_expr);
    var start_postfix = infix_to_postfix(start_tokens);
    var start_val     = evaluate_postfix(start_postfix);

    var to_val_eval   = basic_evaluate_expression_v2(to_expr);
    var step_val_eval = basic_evaluate_expression_v2(step_expr);

    // --- SAFE RESOLUTION: only accept string if it's a variable name; never call real() on text ---
    if (is_string(to_val_eval)) {
        var key_to = string_upper(string_trim(to_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_to)) {
            to_val_eval = global.basic_variables[? key_to];
        } else {
            basic_syntax_error("FOR ... TO must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_RANGE");
            return;
        }
    }
    if (is_string(step_val_eval)) {
        var key_step = string_upper(string_trim(step_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_step)) {
            step_val_eval = global.basic_variables[? key_step];
        } else {
            // if user wrote STEP "" or a non-var string, reject
            basic_syntax_error("FOR ... STEP must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_STEP");
            return;
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Eval → start=" + string(start_val)
        + " | to(eval)=" + string(to_val_eval) + " [raw='" + to_expr + "']"
        + " | step(eval)=" + string(step_val_eval) + " [raw='" + step_expr + "']");

    // 3) Initialize loop var
    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }
    global.basic_variables[? varname] = start_val;
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Initialized variable " + varname + " = " + string(start_val));

    // 4) Push frame (legacy + inline stmt coordinates)
    var legacy_return_line = line_index;
    var loop_line_idx = line_index;
    var loop_stmt_idx = -1;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        loop_stmt_idx = global.interpreter_current_stmt_index + 1;
    }

    if (!ds_exists(global.for_stack, ds_type_stack)) {
        global.for_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Safety — created global.for_stack");
    }

    var frame = {
        varname     : varname,
        to          : to_val_eval,
        step        : step_val_eval,
        to_raw      : to_expr,       // keep raw for dynamic re-eval in NEXT
        step_raw    : step_expr,     // keep raw for dynamic re-eval in NEXT
        return_line : legacy_return_line,
        loop_line   : loop_line_idx,
        loop_stmt   : loop_stmt_idx
    };
    ds_stack_push(global.for_stack, frame);

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Pushed frame → {var=" + varname
        + ", to=" + string(to_val_eval)
        + ", step=" + string(step_val_eval)
        + ", return_line=" + string(legacy_return_line)
        + ", loop=(" + string(loop_line_idx) + "," + string(loop_stmt_idx) + ")}");
}

/// === BEGIN: basic_cmd_let ===
/// LET handler with modal INKEY$ support and array handling
function basic_cmd_let(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("LET: Raw input: '" + arg + "'");

    // Split "NAME = EXPR"
    var eq = string_pos("=", arg);
    if (eq <= 0) {
        basic_syntax_error("LET requires '='", /*line*/ undefined, global.interpreter_current_stmt_index, "LET_MISSING_EQUALS");
        return;
    }

    var varName = string_trim(string_copy(arg, 1, eq - 1));
    var exprStr = string_trim(string_copy(arg, eq + 1, string_length(arg) - eq));

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("LET: Parsed variable name: '" + varName + "'");
        show_debug_message("LET: Parsed expression    : '" + exprStr + "'");
    }

    // ---------- MODAL INKEY$: pure RHS detection ----------
    var expr_uc = string_upper(exprStr);
    var is_pure_inkey = false;

    // Allow "INKEY$" or "INKEY$()" with arbitrary spaces
    // Strip whitespace
    var expr_compact = string_replace_all(string_replace_all(expr_uc, " ", ""), "\t", "");
    if (expr_compact == "INKEY$" || expr_compact == "INKEY$()") is_pure_inkey = true;

    if (is_pure_inkey) {

        // 1) If we are resuming from a prior wait and have a captured char, COMMIT now.
        if (variable_global_exists("inkey_waiting") && global.inkey_waiting) {
            if (variable_global_exists("inkey_captured") && string_length(global.inkey_captured) > 0) {
                var ch_commit = string(global.inkey_captured);
                
                // Handle array vs regular variable for INKEY$ assignment
                if (basic_is_array_reference(varName)) {
                    basic_assign_to_array(varName, ch_commit);
                } else {
                    var k = basic_normvar(varName);
                    global.basic_variables[? k] = ch_commit;
                }

                // Clear modal flags
                global.inkey_captured   = "";
                global.inkey_waiting    = false;
                global.pause_in_effect  = false;
                global.inkey_target_var = "";

                if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: committed '" + ch_commit + "' to " + varName + " (resume)");
                return;
            }

            // Still waiting, keep paused this frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: still waiting (no captured char yet)");
            return;
        }

        // 2) Not waiting yet – FAST PATH: assign immediately if queue already has a key
        // Support either queue name (__inkey_queue primary; inkey_queue legacy)
        var _q = undefined;
        if (ds_exists(global.__inkey_queue, ds_type_queue)) _q = global.__inkey_queue;
        else if (variable_global_exists("inkey_queue") && ds_exists(global.inkey_queue, ds_type_queue)) _q = global.inkey_queue;

        if (!is_undefined(_q) && ds_queue_size(_q) > 0) {
            var ch2 = ds_queue_dequeue(_q);
            if (is_real(ch2)) ch2 = chr(ch2);
            
            // Handle array vs regular variable for INKEY$ assignment
            if (basic_is_array_reference(varName)) {
                basic_assign_to_array(varName, string(ch2));
            } else {
                var k = basic_normvar(varName);
                global.basic_variables[? k] = string(ch2);
            }
            
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: fast-path assign '" + string(ch2) + "' to " + varName);
            return;
        }

        // 3) Arm modal wait: no key ready yet → pause interpreter and let Step capture ONE key
        global.inkey_waiting    = true;
        global.pause_in_effect  = true;
        global.inkey_target_var = varName; // Store the full variable name including array syntax
        global.inkey_captured   = "";
        if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: armed modal wait for " + varName);
        return;
    }
    // ---------- END MODAL INKEY$ special case ----------

    // ---------- Default LET path: evaluate expression and assign ----------
    var tokens  = basic_tokenize_expression_v2(exprStr);
    var postfix = infix_to_postfix(tokens);
    var val     = evaluate_postfix(postfix);

    // Check if this is an array assignment
    if (basic_is_array_reference(varName)) {
        basic_assign_to_array(varName, val);
        return;
    }

    // Regular variable assignment (existing logic)
    var k = basic_normvar(varName);

    // Coerce based on variable sigil: trailing $ means string var
    var is_string_var = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");
    if (is_string_var) {
        global.basic_variables[? k] = string(val);
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned string value: '" + string(val) + "' to '" + k + "'");
    } else {
        // Numeric: if it looks numeric, coerce to real; else 0 (or keep as-is if you prefer)
        if (is_real(val)) {
            global.basic_variables[? k] = val;
        } else if (basic_looks_numeric(string(val))) {
            global.basic_variables[? k] = real(val);
        } else {
            global.basic_variables[? k] = 0;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned value: '" + string(global.basic_variables[? k]) + "' to '" + k + "'");
    }
}


/// @script basic_cmd_if_inline
/// @description Single-line IF…THEN…ELSE. Executes THEN/ELSE here and tells Step which colon slot to resume at.
function basic_cmd_if_inline(arg) {
    // 1) Normalize and strip inline remarks first
    var s = string_trim(arg);
    s = strip_basic_remark(s);
    var s_upper = string_upper(s);

    // 2) Quote-safe, word-boundary keyword find
    var find_kw = function(_src, _up, _kw) {
        var L = string_length(_src), K = string_length(_kw), inq = false;
        for (var i = 1; i <= L - K + 1; i++) {
            var ch = string_char_at(_src, i);
            if (ch == "\"") { inq = !inq; continue; }
            if (inq) continue;

            if (string_copy(_up, i, K) == _kw) {
                var prev = (i == 1) ? " " : string_char_at(_up, i - 1);
                var next = (i + K <= L) ? string_char_at(_up, i + K) : " ";
                if ((prev == " " || prev == ":") && (next == " " || next == ":" || i + K - 1 == L)) {
                    return i;
                }
            }
        }
        return 0;
    };

    // 3) Require THEN
    var then_pos = find_kw(s, s_upper, "THEN");
		if (then_pos <= 0) {
		    basic_syntax_error("IF requires THEN", 
			basic_current_line_no(), 
			global.interpreter_current_stmt_index,
			"IF MISSING THEN");
		    return;
		}
    var else_pos = find_kw(s, s_upper, "ELSE");

    // 4) Slice parts
    var condition = string_trim(string_copy(s, 1, then_pos - 1));
    var then_action, else_action;
    if (else_pos > then_pos) {
        then_action = string_trim(string_copy(s, then_pos + 4, else_pos - (then_pos + 4)));
        else_action = string_trim(string_copy(s, else_pos + 4, string_length(s) - (else_pos + 3)));
    } else {
        then_action = string_trim(string_copy(s, then_pos + 4, string_length(s) - (then_pos + 3)));
        else_action = "";
    }

    // 5) Evaluate condition
    var cond = basic_evaluate_condition(condition);

    // 6) Split branches into colon segments
    var run_parts = cond ? (then_action != "" ? split_on_unquoted_colons(then_action) : []) 
                         : (else_action != "" ? split_on_unquoted_colons(else_action) : []);

    var p        = global.interpreter_current_stmt_index;
    var line_idx = global.interpreter_current_line_index;

    // 7) Runner: executes a single colon-segment with implicit-LET promotion
    var run_seg = function(seg) {
        seg = strip_basic_remark(string_trim(seg));
        if (seg == "") return;

        var sp = string_pos(" ", seg);
        var head = (sp > 0) ? string_upper(string_copy(seg, 1, sp - 1)) : string_upper(seg);

        var is_cmd =
              (head == "PRINT")   || (head == "LET")     || (head == "INPUT")   || (head == "CLS")
           || (head == "COLOR")   || (head == "BGCOLOR") || (head == "IF")      || (head == "FOR")
           || (head == "NEXT")    || (head == "WHILE")   || (head == "WEND")    || (head == "GOTO")
           || (head == "GOSUB")   || (head == "RETURN")  || (head == "DIM")     || (head == "END")
           || (head == "MODE")    || (head == "PSET")    || (head == "CHARAT")  || (head == "PRINTAT")
           || (head == "FONT")    || (head == "CLSCHAR") || (head == "PAUSE")
           || (head == "READ")    || (head == "RESTORE") || (head == "DATA")    || (head == "INKEY$");

        if (!is_cmd) {
            var d = 0, eq = 0, L = string_length(seg);
            for (var i = 1; i <= L; i++) {
                var ch = string_char_at(seg, i);
                if (ch == "(") d++;
                else if (ch == ")") d = max(0, d - 1);
                else if (ch == "=" && d == 0) { eq = i; break; }
            }
            if (eq > 0) seg = "LET " + seg;
        }

        var sp2 = string_pos(" ", seg);
        var cmd = (sp2 > 0) ? string_upper(string_copy(seg, 1, sp2 - 1)) : string_upper(seg);
        var arg = (sp2 > 0) ? string_trim(string_copy(seg, sp2 + 1, string_length(seg))) : "";

        if (cmd == "GOTO") {
            var line_target = real(arg);
            var idx = ds_list_find_index(global.line_list, line_target);
            if (idx >= 0) {
                global.interpreter_next_line = idx;
            } else {
                basic_syntax_error("GOTO target not found: " + string(line_target), 
				global.current_line_number, 
				p,
				"TARGET NOT FOUND");
            }
        } else {
            handle_basic_command(cmd, arg);
        }
    };

    // 8) Execute chosen branch (if any)
    for (var k = 0; k < array_length(run_parts); k++) {
        run_seg(run_parts[k]);
        if (global.program_has_ended || !global.interpreter_running) return; // error halted
    }

    // 9) Tell Step to resume after this IF colon-slot
    global.interpreter_use_stmt_jump = true;
    global.interpreter_target_line   = line_idx;
    global.interpreter_target_stmt   = p + 1;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function handle_command(command) {
//	show_debug_message("HANDLE_COMMAND called with: " + string(command) + " - paste_manager_exists: " + string(instance_exists(obj_paste_manager)));
   
var original_command = string_trim(command);
    command = string_upper(original_command);
    
    // Split command from parameters to preserve case in filenames
    var space_pos = string_pos(" ", command);
    var cmd_word = "";
    var cmd_params = "";
    
    if (space_pos > 0) {
        cmd_word = string_copy(command, 1, space_pos - 1);
        cmd_params = string_trim(string_copy(original_command, space_pos + 1, string_length(original_command)));
    } else {
        cmd_word = command;
    }
    
    switch (cmd_word) {
        case "LIST":
            if (cmd_params == "") {
                list_program();
            } else {
                list_program_range(cmd_params);
            }
            break;
            
        case "RUN":
            run_program();
            break;
            
        case "NEW":
            new_program();
            break;
            
        case "SAVE":
            if (os_browser != browser_not_a_browser) {
                // HTML build → use browser_file_tools download dialog
                if (cmd_params == "") {
                    editor_html_save_program();
                } else {
                    editor_html_save_program_as(cmd_params);
                }
            } else {
                // Desktop build → use file system save
                if (cmd_params == "") {
                    save_program();
                } else {
                    save_program_as(cmd_params);
                }
            }
            break;

case "CHECK_SAVE_FUNCS":
{
    var s = "browser_show_save_dialog";
    var r = "browser_show_save_dialog_raw";
   if (dbg_on(DBG_FLOW)) show_debug_message("[CHECK] wrapper exists=" + string(function_exists(s)));
   if (dbg_on(DBG_FLOW)) show_debug_message("[CHECK] raw exists=" + string(function_exists(r)));
    break;
}


            
        case "LOAD":
            if (cmd_params == "") {
                show_error_message("FILENAME REQUIRED");
            } else {
                load_program_from(cmd_params);
            }
            break;

		
case "DIR":
    if (os_browser != browser_not_a_browser) {
        var p = string_trim(cmd_params);
        var P = string_upper(p);
        if (P == "" || P == "PROMPT") {
            editor_html_dir_prompt();
        } else if (P == "SHOW") {
            editor_html_dir_show();
        } else if (string_copy(P, 1, 4) == "OPEN") {
            var arg = string_trim(string_delete(p, 1, 4)); // after "OPEN"
            if (string_length(arg) == 0) {
                show_message("Usage: DIR OPEN <index|filename>");
            } else {
                editor_html_dir_open(arg);
            }
        } else if (P != "") {  // Only try to open if there's actually a parameter
            // convenience: if they pass a number or name directly
            editor_html_dir_open(p);
        }
        // Remove the bare else clause that was causing the double call
    } else {
        // Windows: your original code path
        if (cmd_params == "") {
            list_saved_programs();
        } else {
            list_saved_programs(); // preserve your param behavior
        }
    }
    break;

case "HELP":
	help_launch();
	break

case ":PASTE":
{
    // Desktop build: native clipboard
    if (os_browser == browser_not_a_browser) {
        editor_handle_paste_command();
        break;
    }

		editor_html_handle_paste_command();

   if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Bound. Click the game, then press Ctrl/Cmd+V.");
}
break;





	    case ":LOADURL":
	        // Expect the rest of the input line to be the URL
	        // If your parser provides 'args', use that. Otherwise, adapt to your arg var.
	        import_from_url(string_trim(args));
	        break;
		
		

		case "QUIT":	
		case "Q":
		quit_program()
		break;

        case "SCREENEDIT":
        case "SE":
            start_screen_editor();
            break;


			
        default:
            show_error_message("SYNTAX ERROR");
            break;
    }
 }
/// @script build_if_block_map
/// @description Scan basic_program for IF…ELSEIF…ELSE…ENDIF block structure,
///              but skip inline IFs so they don’t trigger mismatches.

function build_if_block_map() {
    // 1) Destroy any old map
    if (variable_global_exists("if_block_map") && ds_exists(global.if_block_map, ds_type_map)) {
        ds_map_destroy(global.if_block_map);
    }
    global.if_block_map = ds_map_create();

    // 2) Temp stack for nested block IFs
    var openStack = ds_stack_create();
    var total     = ds_list_size(global.basic_line_numbers);

    // 3) Walk every line
    for (var idx = 0; idx < total; idx++) {
        var lineNum = global.basic_line_numbers[| idx];
        var rawText = string_trim(global.basic_program[? lineNum]);
        var text    = string_upper(rawText);
        var sp      = string_pos(" ", text);
        var kw      = (sp > 0) ? string_copy(text, 1, sp - 1) : text;

        switch (kw) {
            case "IF":
                // detect inline IF: IF … THEN <command> on same line
                var thenPos = string_pos("THEN", text);
                var after   = (thenPos > 0)
                              ? string_trim(string_copy(rawText, thenPos + 4, string_length(rawText)))
                              : "";
                if (thenPos > 0 && string_length(after) > 0) {
                    // Inline IF → skip block indexing entirely
                    if (dbg_on(DBG_FLOW)) show_debug_message("INLINE IF skip at line " + string(lineNum));
                    break;
                }
                // Block IF → record it
                var info = ds_map_create();
                ds_map_add(info, "startIndex",       idx);
                ds_map_add(info, "elseifIndices",    ds_list_create());
                ds_map_add(info, "elseIndex",        -1);
                ds_map_add(info, "endifIndex",       -1);
                ds_map_add(info, "firstBranchIndex", idx + 1);
                ds_stack_push(openStack, info);
                break;

            case "ELSEIF":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_top(openStack);
                    ds_list_add(top[? "elseifIndices"], idx);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: ELSEIF at line " + string(lineNum) + " without IF");
                }
                break;

            case "ELSE":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_top(openStack);
                    ds_map_replace(top, "elseIndex", idx);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: ELSE at line " + string(lineNum) + " without IF");
                }
                break;

            case "ENDIF":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_pop(openStack);
                    ds_map_replace(top, "endifIndex", idx);

                    // recompute firstBranchIndex
                    var eList = top[? "elseifIndices"];
                    var fb = (ds_list_size(eList) > 0)
                             ? eList[| 0]
                             : ((top[? "elseIndex"] >= 0) ? top[? "elseIndex"] : idx);
                    ds_map_replace(top, "firstBranchIndex", fb);

                    ds_map_add(global.if_block_map, top[? "startIndex"], top);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: ENDIF at line " + string(lineNum) + " without IF");
                }
                break;
        }
    }

    // 4) Any unclosed IFs left on the stack?
    while (!ds_stack_empty(openStack)) {
        var orphan = ds_stack_pop(openStack);
        var startIdx  = orphan[? "startIndex"];
        var startLine = global.basic_line_numbers[| startIdx];
        if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: IF at line " + string(startLine) + " missing ENDIF");
        ds_map_destroy(orphan);
    }
    ds_stack_destroy(openStack);

    if (dbg_on(DBG_FLOW)) show_debug_message("Built IF block map with " + string(ds_map_size(global.if_block_map)) + " entries.");
}

/// @function _beep_seq_next()
/// @desc Internal: dequeue next note/rest from global.beep_seq_queue and play; arms pause for its duration.
/// Expects: global.beep_samples map like {"C2": snd_beep_c2, "C3": snd_beep_c3, ..., "C6": snd_beep_c6}
function _beep_seq_next()
{
	
	// --- BREAK GUARD: allow ESC to abort mid-sequence ---
	if (variable_global_exists("beep_break_requested") && global.beep_break_requested) {
	    global.beep_break_requested = false;
	    beep_cancel(true); // stop and END
	    return;
	}


    if (!ds_exists(global.beep_seq_queue, ds_type_queue) || ds_queue_size(global.beep_seq_queue) == 0) {
        // Sequence finished: resume after the original statement
        global.beep_seq_active  = false;
        global.pause_in_effect  = false;

        global.interpreter_use_stmt_jump = true;
        global.interpreter_target_line   = global.beep_resume_line;
        global.interpreter_target_stmt   = global.beep_resume_stmt;
        return;
    }

    // --- Ensure the sample map exists; fall back to single sample if not ---
    if (!variable_global_exists("beep_samples") || !ds_exists(global.beep_samples, ds_type_map)) {
        // create a minimal map that points to the single C4 sample if available
        global.beep_samples = ds_map_create();
        if (variable_global_exists("beep_sound")) {
            ds_map_set(global.beep_samples, "C4", global.beep_sound);
        }
    }

    var pack = ds_queue_dequeue(global.beep_seq_queue);
    var n0   = pack[0]; // 'A'..'G' or 'R'
    var acc  = pack[1]; // -1,0,+1
    var beats= pack[2]; // real
    var oofs = pack[3]; // octave offset relative to C4

    // duration
    var bpm  = (is_real(global.beep_tempo) && global.beep_tempo > 0) ? global.beep_tempo : 120;
    var ms   = max(1, round(beats * (60.0 / bpm) * 1000));

    // rest
    if (n0 == "R") {
        if (dbg_on(DBG_FLOW)) show_debug_message("BEEP SEQ: rest " + string(ms) + "ms");
        _beep_arm_pause(ms);
        return;
    }

    // letter-to-semitone from C
    var base = 0;
    switch (n0) {
        case "C": base = 0;  break;
        case "D": base = 2;  break;
        case "E": base = 4;  break;
        case "F": base = 5;  break;
        case "G": base = 7;  break;
        case "A": base = 9;  break;
        case "B": base = 11; break;
    }

    // target octave (relative to C4)
    var target_oct = 4 + oofs;

    // ---- choose nearest base C sample (C2..C6) ----
    var base_oct = clamp(target_oct, 2, 6);
    var snd      = -1;
    var found    = false;

    // try exact, then walk outward to nearest available Cn in the map
    for (var d = 0; d <= 4 && !found; d++) {
        var o1 = clamp(base_oct - d, 2, 6);
        var o2 = clamp(base_oct + d, 2, 6);

        if (ds_map_exists(global.beep_samples, "C" + string(o1))) {
            snd = global.beep_samples[? "C" + string(o1)];
            base_oct = o1;
            found = true;
        }
        if (!found && ds_map_exists(global.beep_samples, "C" + string(o2))) {
            snd = global.beep_samples[? "C" + string(o2)];
            base_oct = o2;
            found = true;
        }
    }

    // absolute fallback: use single C4 sample if nothing mapped
    if (!found) {
        snd = variable_global_exists("beep_sound") ? global.beep_sound : -1;
        base_oct = 4;
    }

    // semitone distance from chosen base
    var semis = base + acc + ((target_oct - base_oct) * 12);

    // pitch factor (use power() in GML)
    var pitch = power(2, semis / 12);

    // play (legacy-safe path)
    if (snd != -1) {
        var inst = audio_play_sound(snd, 0, false);
        if (!is_undefined(audio_sound_pitch)) {
            // Many runtimes accept instance id here; if not, passing the asset id still works
            audio_sound_pitch(inst, pitch);
        }
    } else if (dbg_on(DBG_FLOW)) {
        show_debug_message("BEEP SEQ: no sound asset available; resting " + string(ms) + "ms");
    }

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("BEEP SEQ: " + n0 + " pitch=" + string_format(pitch, 0, 3) + " ms=" + string(ms));
    }

    _beep_arm_pause(ms);
}

/// handle_interpreter_character_input(key)
/// Processes editor keystrokes while awaiting BASIC INPUT.
/// Assumes helpers basic_normvar(name) and basic_looks_numeric(s) exist,
/// and global.basic_variables (ds_map) is initialized.
function handle_interpreter_character_input(key) {
    // --- PRINTABLE ASCII (uses keyboard_lastchar) ---
    if (key >= 32 && key <= 126) {
        var ch = string(keyboard_lastchar); // ensure string
        if (string_length(ch) > 0) {
            global.interpreter_input = string_insert(ch, global.interpreter_input, global.interpreter_cursor_pos + 1);
            global.interpreter_cursor_pos += 1;
        }
        return;
    }

    // --- BACKSPACE ---
    if (key == vk_backspace) {
        if (global.interpreter_cursor_pos > 0) {
            // Delete the character just to the left of the cursor
            global.interpreter_input = string_delete(global.interpreter_input, global.interpreter_cursor_pos, 1);
            global.interpreter_cursor_pos -= 1;
        }
        return;
    }

    // --- SPACE ---
    if (key == vk_space) {
        global.interpreter_input = string_insert(" ", global.interpreter_input, global.interpreter_cursor_pos + 1);
        global.interpreter_cursor_pos += 1;
        return;
    }

    // --- LEFT ARROW ---
    if (key == vk_left) {
        if (global.interpreter_cursor_pos > 0) {
            global.interpreter_cursor_pos -= 1;
        }
        return;
    }

    // --- RIGHT ARROW ---
    if (key == vk_right) {
        if (global.interpreter_cursor_pos < string_length(global.interpreter_input)) {
            global.interpreter_cursor_pos += 1;
        }
        return;
    }

    // --- ENTER: finalize INPUT and resume execution ---
    if (key == vk_enter) {
        var raw = string_trim(string(global.interpreter_input));
        var k   = basic_normvar(global.input_target_var);

        // String var if the normalized name ends with '$'
        var ends_with_dollar = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");

        var val;
        if (ends_with_dollar) {
            // String variable: commit exactly what the user typed
            val = raw;
        } else {
            // Numeric variable: only accept numeric-looking input (prevents silent 0 bugs)
            if (basic_looks_numeric(raw)) {
                val = real(raw);
            } else {
                // Stay in input mode; do not commit or advance
                if (!is_undefined(global.DEBUG_INPUT) && global.DEBUG_INPUT) {
                    show_debug_message("[INPUT] Type mismatch for " + k + " got '" + raw + "'. Still waiting.");
                }
                return;
            }
        }

        // Store under canonical key
        global.basic_variables[? k] = val;

        if (!is_undefined(global.DEBUG_INPUT) && global.DEBUG_INPUT) {
            show_debug_message("[INPUT] commit " + k + " <= '" + string(val) + "'");
        }

        // --- Post-commit housekeeping (keep these consistent with your existing flow) ---
        // Clear the input buffer and cursor
        global.interpreter_input      = "";
        global.interpreter_cursor_pos = 0;

        // Clear input mode flags/targets
        global.awaiting_input   = false;
        global.input_target_var = "";

        // If you echo the entered line to your output, do it here (optional):
        // ds_list_add(global.output_lines, string(val));
        // ds_list_add(global.output_colors, global.current_draw_color);

        return;
    }

    // (Optional) HOME / END support
    // if (key == vk_home) { global.interpreter_cursor_pos = 0; return; }
    // if (key == vk_end)  { global.interpreter_cursor_pos = string_length(global.interpreter_input); return; }
}

// FILE: scripts/inkey_capture_keys.gml
// FUNCTION: inkey_capture_keys
// PURPOSE: Feed the INKEY$ queue with a single key per frame.
// POLICY:
//   - Block capture while BASIC INPUT is active (awaiting_input = true)
//     UNLESS we are in an INKEY$ modal wait (inkey_waiting = true).
//   - During INKEY$ modal wait, keep capturing so the state machine can unblock.
//   - Otherwise capture printable ASCII (32..126) and (optionally) touch on Android.

function inkey_capture_keys() {
    /// inkey_capture_keys()

    // --- INPUT/INKEY arbitration guard -------------------------------------
    // Block capture only when INPUT is live and we are NOT in a modal INKEY wait.
    var _block_capture = false;

    if (variable_global_exists("awaiting_input") && global.awaiting_input) {
        var _inkey_waiting = (variable_global_exists("inkey_waiting") && global.inkey_waiting);
        if (!_inkey_waiting) {
            _block_capture = true;  // INPUT owns the keyboard; don't feed INKEY$ queue
        }
    }

    if (_block_capture) {
		//TEMPORARY: REMOVE WHEN TESTING INKEY$
        //if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: blocked (awaiting_input && !inkey_waiting)");
        exit;
    }
    // -----------------------------------------------------------------------

    // Initialize queue if not exists (use your current global.__inkey_queue)
    if (!ds_exists(global.__inkey_queue, ds_type_queue)) {
        global.__inkey_queue = ds_queue_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Initialized global.__inkey_queue");
    }

    // --- Scan for one printable key (ASCII 32..126) per frame ---------------
    for (var key = 32; key <= 126; key++) {
        if (keyboard_check_pressed(key)) {
            var ch = chr(key);
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Key " + string(key) + " pressed, char='" + ch + "'");

            // Limit queue length to 10 (same policy as before)
            if (ds_queue_size(global.__inkey_queue) < 10) {
                ds_queue_enqueue(global.__inkey_queue, ch);
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: '" + ch + "' queued. Size=" + string(ds_queue_size(global.__inkey_queue)));
            } else {
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Queue full (10), skipped '" + ch + "'");
            }
            break; // capture at most one key per frame
        }
    }

    // --- Optional: map simple touch regions to WASD on Android --------------
    if (os_type == os_android) {
        var w = display_get_width();
        var h = display_get_height();
        if (device_mouse_check_button_pressed(0, mb_left)) {
            var mx = device_mouse_x(0);
            var my = device_mouse_y(0);
            var ch2 = "";

            // Quadrant-ish mapping (center bands) → W/A/S/D
            if (my < h * 0.5 && mx > w * 0.25 && mx < w * 0.75) ch2 = "W";
            else if (my > h * 0.5 && mx > w * 0.25 && mx < w * 0.75) ch2 = "S";
            else if (mx < w * 0.5 && my > h * 0.25 && my < h * 0.75) ch2 = "A";
            else if (mx > w * 0.5 && my > h * 0.25 && my < h * 0.75) ch2 = "D";

            if (ch2 != "" && ds_queue_size(global.__inkey_queue) < 10) {
                ds_queue_enqueue(global.__inkey_queue, ch2);
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Touch→'" + ch2 + "', queued. Size=" + string(ds_queue_size(global.__inkey_queue)));
            }
        }
    }
}

/// @function basic_cmd_dim(rest)
/// @description DIM NAME(expr) or DIM NAME1(expr1), NAME2(expr2), ...
/// Allocates 1-D arrays in global.basic_arrays as zero-filled ds_lists.
/// Semantics: inclusive upper bound like C64 — DIM A(10) => valid indices 0..10.
/// Notes:
/// - Safe alongside LET auto-grow: DIM preallocates; LET keeps working the same.
/// - Multiple arrays supported, comma-separated at top level (commas inside () are ignored).
function basic_cmd_dim(rest) {
    var s  = string_trim(rest);
    if (s == "") {
        if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Missing arguments");
        return;
    }

    // Ensure array registry exists
    if (is_undefined(global.basic_arrays)) {
        global.basic_arrays = ds_map_create();
        if (dbg_on(DBG_FLOW))  show_debug_message("DIM: Created global.basic_arrays map");
    }

    // Split on top-level commas (ignore commas inside parentheses or quotes)
    var defs = [];
    {
        var _depth = 0;
        var in_q  = false;
        var start = 1;
        for (var i = 1; i <= string_length(s); i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { in_q = !in_q; }
            if (!in_q) {
                if (ch == "(") _depth++;
                else if (ch == ")") _depth = max(0, _depth - 1);
                else if (ch == "," && _depth == 0) {
                    array_push(defs, string_trim(string_copy(s, start, i - start)));
                    start = i + 1;
                }
            }
        }
        // tail
        if (start <= string_length(s)) {
            array_push(defs, string_trim(string_copy(s, start, string_length(s) - start + 1)));
        }
    }

    // Process each NAME(expr)
    for (var d = 0; d < array_length(defs); d++) {
        var item = defs[d];
        if (item == "") continue;

        var openPos  = string_pos("(", item);
        var closePos = string_last_pos(")", item);

        if (openPos <= 0 || closePos <= openPos) {
            if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Expected NAME(expr), got: " + item);
            continue;
        }

        var nm_raw  = string_trim(string_copy(item, 1, openPos - 1));
        var nm      = string_upper(nm_raw);
        var lenExpr = string_copy(item, openPos + 1, (closePos - openPos - 1));
        var lenVal  = basic_evaluate_expression_v2(lenExpr);

        if (!is_real(lenVal)) {
            if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Length expression not numeric for " + nm + " -> [" + lenExpr + "]");
            continue;
        }

        var n    = floor(max(0, lenVal));
        var size = n + 1; // inclusive upper bound (0..n)

        // Replace any existing ds_list to avoid leaks
        if (ds_map_exists(global.basic_arrays, nm)) {
            var _old = global.basic_arrays[? nm];
            if (ds_exists(_old, ds_type_list)) {
                ds_list_destroy(_old);
            }
        }

        // Create and zero-fill list
        var lst = ds_list_create();
        for (var i = 0; i < size; i++) ds_list_add(lst, 0);

        global.basic_arrays[? nm] = lst;

        if (dbg_on(DBG_FLOW))  {show_debug_message("DIM: " + nm + " sized to " + string(size) + " (indices 0.." + string(n) + ")"
            + " | lenExpr=[" + lenExpr + "] -> " + string(lenVal));}
    }
}

function basic_cmd_wend() {
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Entering handler...");

    if (!ds_exists(global.while_stack, ds_type_stack) || ds_stack_empty(global.while_stack)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: ERROR — while_stack missing or empty");
        basic_show_message("WEND without matching WHILE");
        return;
    }

    var while_line_index = ds_stack_top(global.while_stack); // Peek, do not pop yet
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Top of while_stack is line index: " + string(while_line_index));

    // Prefer exact condition & resume slot captured at WHILE time
    var have_meta = (variable_global_exists("while_meta") && ds_exists(global.while_meta, ds_type_map)
                     && ds_map_exists(global.while_meta, string(while_line_index)));

    var cond_str, stmt_after;

    if (have_meta) {
        var meta = global.while_meta[? string(while_line_index)];
        cond_str   = string(meta[? "cond_str"]);
        stmt_after = meta[? "stmt_after"];
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Using stored cond='" + cond_str + "', stmt_after=" + string(stmt_after));
    } else {
        // === Legacy fallback (keeps prior behavior if meta missing) ===
        var while_line_number = ds_list_find_value(global.line_list, while_line_index);
        var while_code        = ds_map_find_value(global.program_map, while_line_number);
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Fallback WHILE line " + string(while_line_number) + " code: '" + while_code + "'");

        cond_str = string_trim(string_delete(while_code, 1, string_pos(" ", while_code)));
        stmt_after = 0; // we’ll jump to start of line as before in fallback
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Fallback extracted condition: '" + cond_str + "'");
    }

    var condition_value = basic_evaluate_condition(string_upper(cond_str));
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Re-evaluated condition result: " + string(condition_value));

    if (condition_value) {
        if (have_meta) {
            // === FIX 2: loop back to the colon slot immediately AFTER the WHILE header ===
            global.interpreter_use_stmt_jump = true;
            global.interpreter_target_line   = while_line_index;
            global.interpreter_target_stmt   = max(0, stmt_after);
            global.interpreter_next_line     = -1;
            if (dbg_on(DBG_FLOW)) show_debug_message("WEND: TRUE → jump to (line="
                + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt) + ")");
        } else {
            // Legacy behavior
            if (dbg_on(DBG_FLOW)) show_debug_message("WEND: TRUE (fallback) — setting line_index = " + string(while_line_index - 1));
            line_index = while_line_index - 1; // causes Step to re-run the WHILE line
        }
    } else {
        // Exit loop
        ds_stack_pop(global.while_stack);
        if (have_meta) {
            // Clean up stored meta for this WHILE
            ds_map_delete(global.while_meta, string(while_line_index));
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: FALSE → pop and continue");
    }
}

function editor_html_dir__open_handler(data, name, type) {
    if (dbg_on(DBG_FLOW)) show_debug_message("[ENTER] editor_html_dir__open_handler");
    
    // clear the guard immediately on first callback
    if (variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;

    if (is_undefined(name)) { // defensive
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir__open_handler (undefined name)");
        return;
    }

    if (!variable_global_exists("html_dir_files")) global.html_dir_files = ds_list_create();
    var rec = ds_map_create();
    ds_map_set(rec, "name", name);
    ds_map_set(rec, "type", type);
    ds_map_set(rec, "data", data);

    // estimate size from base64 length (as before)
    var size_est = 0, comma = string_pos(",", data);
    if (comma > 0) {
        var b64 = string_copy(data, comma + 1, string_length(data) - comma);
        var L = string_length(b64), pad = 0;
        if (L >= 1 && string_char_at(b64, L) == "=") pad++;
        if (L >= 2 && string_char_at(b64, L - 1) == "=") pad++;
        size_est = max(0, floor(L * 3 / 4) - pad);
    }
    ds_map_set(rec, "size", size_est);

    ds_list_add(global.html_dir_files, rec);
    if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] added '" + name + "' (" + string(size_est) + " bytes)");

    // After all files are loaded, automatically show the directory overlay
    // Use call_later to ensure all files are processed first
    if (!variable_global_exists("__html_dir_auto_show_scheduled") || !global.__html_dir_auto_show_scheduled) {
        global.__html_dir_auto_show_scheduled = true;
        
        // Schedule the directory show for next frame
        call_later(1, time_source_units_frames, function() {
            // Only show if we have .bas files
            if (variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > 0) {
                var has_bas_files = false;
                var n = ds_list_size(global.html_dir_files);
                for (var i = 0; i < n; i++) {
                    var rec = global.html_dir_files[| i];
                    var filename = ds_map_find_value(rec, "name");
                    if (string_pos(".bas", string_lower(filename)) > 0) {
                        has_bas_files = true;
                        break;
                    }
                }
                
                if (has_bas_files) {
                    editor_html_dir_show();
                    basic_show_message("Files loaded. Use arrows to select, Enter to open.");
                } else {
                    basic_show_message("Files selected, but no .bas files found.");
                }
            }
            global.__html_dir_auto_show_scheduled = false;
        });
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir__open_handler");
}
/// @function basic_cmd_scroll(arg)
/// @description SCROLL [direction,] amount  -- direction defaults to UP when omitted or numeric-first.
function basic_cmd_scroll(arg) {
    if (global.current_mode < 1) {
        if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: Not implemented in text mode");
        return;
    }
    
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: No grid object found");
        return;
    }

    // Defaults
    var _direction = "UP";
    var amount     = 1;

    var s = string_trim(arg);
    if (s != "") {
        var args = basic_parse_csv_args(s);

        if (array_length(args) == 1) {
            var a0 = string_trim(args[0]);

            // If the single arg is numeric (or an identifier that evals numeric), treat it as AMOUNT, direction=UP
            var treat_as_amount = false;
            if (is_numeric_string(a0)) {
                treat_as_amount = true;
            } else {
                // try evaluator; if it yields a number, we accept it as amount
                var v = basic_evaluate_expression_v2(a0);
                if (is_real(v)) {
                    amount = max(1, floor(real(v)));
                    treat_as_amount = true;
                }
            }

            if (treat_as_amount) {
                // direction remains default "UP"
                if (is_numeric_string(a0)) amount = max(1, floor(real(a0)));
            } else {
                // Otherwise it’s a direction token
                _direction = string_upper(a0);
                // Remove quotes if present
                if (string_length(_direction) >= 2 && (string_char_at(_direction,1) == "\"" || string_char_at(_direction,1) == "'")) {
                    _direction = string_copy(_direction, 2, string_length(_direction) - 2);
                    _direction = string_upper(_direction);
                }
            }
        }
        else if (array_length(args) >= 2) {
            // direction, amount
            _direction = string_upper(string_trim(args[0]));
            if (string_length(_direction) >= 2 && (string_char_at(_direction,1) == "\"" || string_char_at(_direction,1) == "'")) {
                _direction = string_copy(_direction, 2, string_length(_direction) - 2);
                _direction = string_upper(_direction);
            }
            amount = max(1, floor(real(basic_evaluate_expression_v2(string_trim(args[1])))));
        }
    }

    // Hand off
    mode1_scroll_grid(grid_obj, _direction, amount);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: " + _direction + " by " + string(amount));
}

// FILE: scripts/basic_cmd_mode.gml
// FUNCTION: basic_cmd_mode(arg)
// BEHAVIOR: MODE 1 optionally accepts a size (8,16,32). Sets global.mode1_cell_px,
//           selects a size-matched default font from global.font_sheets, and switches rooms when needed.
function basic_cmd_mode(arg) {
    var mode    = 0;
    var size_px = -1;
    // --- Parse "1" or "1,16" (CSV-aware) ---
    var s = string_trim(arg);
    if (string_pos(",", s) > 0) {
        var parts = basic_parse_csv_args(s);
        mode = real(string_trim(parts[0]));
        if (array_length(parts) >= 2) size_px = real(string_trim(parts[1]));
    } else {
        mode = real(s);
    }
    // --- Validate mode key in registry ---
    if (!ds_map_exists(global.mode_rooms, mode)) {
        basic_show_message("Invalid MODE: " + string(mode));
        return;
    }
    // --- MODE 1: accept 8/16/32; default 32 for back-compat ---
// --- Only MODE 1 supports size selection (8/16/32), default 32 ---
if (mode == 1) {
    if (size_px != 8 && size_px != 16 && size_px != 32) size_px = 32;
    global.mode1_cell_px = size_px;
    if (dbg_on(DBG_FLOW)) show_debug_message("MODE 1: cell size set to " + string(size_px) + " px");

    // Pick a matching DEFAULT_* only if user hasn't FONTSET-locked a font
    if (!variable_global_exists("font_locked") || !global.font_locked) {
        var _key = "DEFAULT_32";
        if (size_px == 16) _key = "DEFAULT_16";
        else if (size_px == 8) _key = "DEFAULT_8";

        if (ds_map_exists(global.font_sheets, _key)) {
            global.active_font_name   = _key;
            global.active_font_sprite = global.font_sheets[? _key];
            if (dbg_on(DBG_FLOW)) show_debug_message("MODE: active font -> " + _key);
        }
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("MODE: font locked by user (" + global.active_font_name + "), leaving as-is");
    }
}

    // --- If mode already active, do not switch rooms (we still updated size/font above) ---
    if (mode == global.current_mode) {
        if (dbg_on(DBG_FLOW)) show_debug_message("MODE already set to " + string(mode) + "; no room switch needed.");
        return;
    }
    // --- Switch to the room for the requested mode ---
    global.current_mode = mode;
    var target_room = ds_map_find_value(global.mode_rooms, mode);
    if (dbg_on(DBG_FLOW)) show_debug_message("Switching to MODE " + string(mode) + " → room: " + string(target_room));
    room_goto(target_room);
}
function basic_cmd_clschar(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("=== CLSCHAR DEBUG START ===");
    if (dbg_on(DBG_FLOW))  show_debug_message("Raw arg: '" + string(arg) + "'");
    
    var args = string_split(arg, ",");
    if (dbg_on(DBG_FLOW))  show_debug_message("Split args count: " + string(array_length(args)));
    for (var i = 0; i < array_length(args); i++) {
        show_debug_message("Arg[" + string(i) + "]: '" + string(args[i]) + "'");
    }

    var char_index = 0;
    var fg_color = c_white;
    var bg_color = c_black;

    if (array_length(args) >= 1) {
        char_index = real(string_trim(args[0]));
        if (dbg_on(DBG_FLOW))  show_debug_message("Parsed char_index: " + string(char_index));
    }

    if (array_length(args) >= 2) {
        var fg_str = string_upper(string_trim(args[1]));
        if (dbg_on(DBG_FLOW))  show_debug_message("Looking for fg color: '" + fg_str + "'");
        if (ds_map_exists(global.colors, fg_str)) {
            fg_color = global.colors[? fg_str];
            if (dbg_on(DBG_FLOW))  show_debug_message("Found fg color: " + string(fg_color));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("FG COLOR NOT FOUND!");
        }
    }

    if (array_length(args) >= 3) {
        var bg_str = string_upper(string_trim(args[2]));
        if (dbg_on(DBG_FLOW))  show_debug_message("Looking for bg color: '" + bg_str + "'");
        if (ds_map_exists(global.colors, bg_str)) {
            bg_color = global.colors[? bg_str];
            if (dbg_on(DBG_FLOW))  show_debug_message("Found bg color: " + string(bg_color));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("BG COLOR NOT FOUND!");
        }
    }

    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("❌ CLSCHAR: No obj_mode1_grid found!");
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("✅ CLSCHAR: Found grid obj - calling fill...");
        if (dbg_on(DBG_FLOW))  show_debug_message("Calling fill with: char=" + string(char_index) + ", fg=" + string(fg_color) + ", bg=" + string(bg_color));
        grid_obj.mode1_grid_fill(char_index, fg_color, bg_color);
    }
    if (dbg_on(DBG_FLOW))  show_debug_message("=== CLSCHAR DEBUG END ===");
}
/// @script basic_syntax_error
/// Print a visible error line and stop the interpreter gracefully.
/// @param msg        string message explaining the error
/// @param line_no    (optional) line number; defaults to current
/// @param stmt_idx   (optional) colon-slot index; defaults to current
/// @param hint_key   (optional) short key for contextual hints, e.g. "INKEY_MISUSE"
function basic_syntax_error(msg, line_no, stmt_idx, hint_key) {
    if (is_undefined(line_no))  line_no  = global.current_line_number;
    if (is_undefined(stmt_idx)) stmt_idx = global.interpreter_current_stmt_index;
    // Flush any buffered PRINT so error doesn't glue to prior text
    if (is_string(global.print_line_buffer) && string_length(global.print_line_buffer) > 0) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        global.print_line_buffer = "";
    }
    var prev_col = global.current_draw_color;
    // Header + reason
    global.current_draw_color = c_red;
    basic_wrap_and_commit("SYNTAX ERROR at " + string(line_no) + ":", global.current_draw_color);
    basic_wrap_and_commit(string(msg), global.current_draw_color);
    // Compact hints
    if (ds_exists(global.config, ds_type_map) && global.config[? "show_error_hints"]) {
        var _h = basic_error_hint(hint_key);
        for (var i = 0; i < array_length(_h); i++) {
            if (_h[i] != "") basic_wrap_and_commit("  " + _h[i], global.current_draw_color);
        }
    }
    global.current_draw_color = prev_col;
    // Stop cleanly (no gates left engaged)
    global.pause_in_effect     = false;
    global.awaiting_input      = false;
    global.input_expected      = false;
    global.inkey_mode          = false;
    global.inkey_waiting       = false;
    global.interpreter_running = false;
    global.program_has_ended   = true;
    // Let run_program() know not to clear the screen immediately
    global._syntax_error_just_emitted = true;
    if (dbg_on(DBG_FLOW)) show_debug_message("SYNTAX: " + msg + " (line " + string(line_no) + ")");
}
// FILE: scripts/screen_editor_load_program/screen_editor_load_program.gml
/// @function screen_editor_load_program(editor_inst)
function screen_editor_load_program(editor_inst) {
    with (editor_inst) {
        //show_debug_message("SCREEN_EDITOR: Loading program to screen (scroll_offset=" + string(scroll_offset) + ")");
        
        // Clear screen first
        for (var i = 0; i < array_length(screen_buffer); i++) {
            screen_buffer[i] = ord(" ");
        }
        
        // Load program lines with scroll offset
        var total_lines = ds_list_size(global.line_numbers);
        var screen_row = 0;
        
        // Start from scroll_offset instead of 0
		for (var i = scroll_offset; i < total_lines && screen_row < screen_rows; i++) {
		    var line_num = ds_list_find_value(global.line_numbers, i);
		    var code = ds_map_find_value(global.program_lines, line_num);
		    var line_text = string(line_num) + " " + code;
    
		    // Apply horizontal offset ONLY to the current cursor line
		    var display_text = line_text;
		if (screen_row == cursor_y && horizontal_offset > 0) {
		    // Only scroll the line where the cursor currently is
		    display_text = string_copy(line_text, horizontal_offset + 1, screen_cols);
		    //show_debug_message("SCREEN_EDITOR: Applying h_offset=" + string(horizontal_offset) + " to cursor line " + string(cursor_y));
		}
            
		// Place line text on screen
		var text_len = min(string_length(display_text), screen_cols);  // Use display_text
		for (var j = 1; j <= text_len; j++) {
		    var ch = string_char_at(display_text, j);  // Use display_text
		    screen_editor_set_char_at(id, j - 1, screen_row, ord(ch));
		}
            
            screen_row++;
        }
        
        //show_debug_message("SCREEN_EDITOR: Loaded " + string(screen_row) + " lines starting from offset " + string(scroll_offset));
    }
}
/// @func split_on_unquoted_commas(s)
/// @desc Split a string on commas that are OUTSIDE quotes (and outside parentheses),
///       mirroring your colon-splitter behavior. Keeps empty fields trimmed out.
///       Examples:
///         split_on_unquoted_commas("1,2,\"a,b\",3") -> ["1","2","\"a,b\"","3"]
///         split_on_unquoted_commas("A(1,2),B")      -> ["A(1,2)","B"]
function split_on_unquoted_commas(s) {
    var parts = [];
    if (s == undefined) return parts;

    var L = string_length(s);
    var in_q = false;
    var _depth = 0;     // parentheses depth for safety (DATA can contain A(…), keep it intact)
    var start = 1;

    for (var i = 1; i <= L; i++) {
        var ch = string_char_at(s, i);

        if (ch == "\"") {
            // Handle doubled quotes "" inside strings -> treat as escaped, stay in same quote state
            var nxt = (i < L) ? string_char_at(s, i + 1) : "";
            if (in_q && nxt == "\"") { i++; continue; }
            in_q = !in_q;
            continue;
        }

        if (!in_q) {
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (ch == "," && _depth == 0) {
                var seg = string_trim(string_copy(s, start, i - start));
                if (seg != "") parts[array_length(parts)] = seg;
                start = i + 1;
            }
        }
    }

    // tail
    var tail = string_trim(string_copy(s, start, L - start + 1));
    if (tail != "") parts[array_length(parts)] = tail;

    if (dbg_on && is_undefined(dbg_on) == false) {} // no-op to avoid warnings if dbg_on is macro
    if (dbg_on(DBG_FLOW)) show_debug_message("split_on_unquoted_commas('" + s + "') -> " + string(parts));

    return parts;
}

/// @function basic_array_get(name, idx)
/// @description Retrieves a value from a 1D array stored in global.basic_arrays (1-based BASIC indexing)
/// @param name The name of the array (string)
/// @param idx  The index to access (1-based BASIC index)
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0
function basic_array_get(_name, _idx) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET: Accessing " + nm + "[" + string(_idx) + "] (BASIC 1-based)");
    // Must exist in the map
    if (!ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET ERROR: Array '" + nm + "' does not exist");
        return 0;
    }
    // Must be a valid ds_list handle
    var lst = global.basic_arrays[? nm];
    if (!ds_exists(lst, ds_type_list)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET ERROR: '" + nm + "' is not a ds_list");
        return 0;
    }
    // Convert BASIC 1-based index to ds_list 0-based index
    var idx_basic = max(1, floor(real(_idx))); // 1-based, clamped at 1
    var idx = idx_basic - 1;                   // convert to 0-based for ds_list
    
    // Bounds check
    var n = ds_list_size(lst);
    if (idx < 0 || idx >= n) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET ERROR: Index " + string(idx_basic) + " (0-based: " + string(idx) + ") out of bounds for " + nm + " (size=" + string(n) + ")");
        return 0;
    }
    // Fetch
    var value = ds_list_find_value(lst, idx);
    // OPTIONAL: verbose log (comment out if noisy)
    // show_debug_message("ARRAY_GET: " + nm + "[" + string(idx_basic) + "] = " + string(value));
    return value;
}
/// @function basic_run_to_console()
/// @description Executes the BASIC program in memory and prints the output to the console instead of the screen.
function basic_run_to_console() {
    // Check if debug function exists, otherwise create a fallback
    var debug_enabled = false;
    if (script_exists(asset_get_index("dbg_on"))) {
        debug_enabled = dbg_on(DBG_FLOW);
    }
    
    if (debug_enabled) show_debug_message("==== BEGIN PROGRAM CONSOLE OUTPUT ====");
    
    // Safety check - use correct global variable names
    if (!ds_exists(global.program_map, ds_type_map) || !ds_exists(global.line_list, ds_type_list)) {
        if (debug_enabled) show_debug_message("No program loaded.");
        show_debug_message("ERROR: No BASIC program in memory to dump.");
        return;
    }
    
    // Simple approach: just dump the raw program lines
    if (debug_enabled) show_debug_message("=== RAW BASIC PROGRAM DUMP ===");
    
    for (var i = 0; i < ds_list_size(global.line_list); i++) {
        var line_num = ds_list_find_value(global.line_list, i);
        var code = ds_map_find_value(global.program_map, line_num);
        
        // Output to console
        var line_output = string(line_num) + " " + code;
        show_debug_message(line_output);
        
        if (debug_enabled) {
            show_debug_message(">> LINE " + string(line_num) + ": " + code);
        }
    }
    
    if (debug_enabled) show_debug_message("=== END BASIC PROGRAM DUMP ===");
    
    // Reset the flag
    if (variable_global_exists("basic_run_to_console_flag")) {
        global.basic_run_to_console_flag = false;
    }
    
    if (debug_enabled) show_debug_message("==== END PROGRAM CONSOLE OUTPUT ====");
}
function basic_cmd_pset(arg) {
    var args = string_split(arg, ",");
    if (array_length(args) < 5) {
        if (dbg_on(DBG_FLOW))  show_debug_message("PSET requires 5 arguments: x, y, char, fg, bg");
        return;
    }
    
    // Evaluate expressions for x, y, and char (they might be variables or expressions)
    var x_val = real(basic_evaluate_expression_v2(string_trim(args[0])));
    var y_val = real(basic_evaluate_expression_v2(string_trim(args[1])));
    var char_index = real(basic_evaluate_expression_v2(string_trim(args[2])));
    
    var fg_str = string_upper(string_trim(args[3]));
    var bg_str = string_upper(string_trim(args[4]));
    
    var fg_color = ds_map_exists(global.colors, fg_str) ? global.colors[? fg_str] : c_white;
    var bg_color = ds_map_exists(global.colors, bg_str) ? global.colors[? bg_str] : c_black;
    
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (instance_exists(grid_obj)) {
        var cols = 40;
        var rows = 25;
        if (x_val >= 0 && x_val < cols && y_val >= 0 && y_val < rows) {
            var index = x_val + y_val * cols;
            grid_obj.grid[index].char = char_index;
            grid_obj.grid[index].fg = fg_color;
            grid_obj.grid[index].bg = bg_color;
            if (dbg_on(DBG_FLOW))  show_debug_message("PSET: Set tile at (" + string(x_val) + "," + string(y_val) + ") to char=" + string(char_index));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("PSET: coordinates out of bounds: (" + string(x_val) + "," + string(y_val) + ")");
        }
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("PSET: No grid object found");
    }
}
/// @function beep_cancel(_end_program)
/// @desc Immediately abort any active BEEP sequence, stop audio, clear pause, and (optionally) END.
function beep_cancel(_end_program)
{
    // Stop current beep (instance or asset-safe)
    if (variable_global_exists("beep_instance")) {
        var inst = global.beep_instance;
        if (!is_undefined(inst)) {
            if (audio_is_playing(inst)) audio_stop_sound(inst);
        }
        global.beep_instance = -1;
    }

    // Clear any queued notes
    if (variable_global_exists("beep_seq_queue") && ds_exists(global.beep_seq_queue, ds_type_queue)) {
        ds_queue_clear(global.beep_seq_queue);
    }

    // Reset beep/BEEP-seq state
    global.beep_seq_active  = false;
    global.beep_waiting     = false;
    global.pause_in_effect  = false;
    if (variable_global_exists("beep_deadline_ms")) global.beep_deadline_ms = 0;

    // Ensure we won’t “resume after this segment”
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line   = -1;
    global.interpreter_target_stmt   = 0;

    if (_end_program) {
        // Use your NW-BASIC system message helper (consistent wrap/color)
        var sys_col = variable_global_exists("system_message_color")
            ? global.system_message_color
            : (variable_global_exists("basic_text_color") ? global.basic_text_color : c_white);

        basic_system_message("ESC pressed, Beep sequence stopped, program ending.", sys_col);

        // End immediately (same effect as END)
        global.interpreter_running = false;
        global.program_has_ended   = true;
    }
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 // Functions for input handling
 function handle_character_input() {
    var key_string = keyboard_string;
    
    // Robust keyboard handling with fallback
    if (key_string != last_keyboard_string) {
        var new_chars = string_copy(key_string, string_length(last_keyboard_string) + 1, 
                                   string_length(key_string) - string_length(last_keyboard_string));
        
        // Filter out control characters and validate input
        var filtered_chars = "";
        for (var i = 1; i <= string_length(new_chars); i++) {
            var char = string_char_at(new_chars, i);
            var char_code = ord(char);
            // Accept printable ASCII characters (32-126)
            if (char_code >= 32 && char_code <= 126) {
                filtered_chars += char;
            }
        }
        
        if (filtered_chars != "") {
            current_input = string_insert(filtered_chars, current_input, cursor_pos + 1);
            cursor_pos += string_length(filtered_chars);
        }
        
        last_keyboard_string = key_string;
    }
    
    // Fallback: Direct key detection for special cases
  //  if (keyboard_check_pressed(vk_space)) {
        // Ensure space is captured even if keyboard_string fails
  //      if (string_char_at(current_input, cursor_pos + 1) != " ") {
   //         current_input = string_insert(" ", current_input, cursor_pos + 1);
   //         cursor_pos++;
   //     }
   // }
 }

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function load_program_from_path(file_path, filename) {
    if (!file_exists(file_path)) {
        show_error_message("DRAG FILE NOT FOUND");
        return;
    }
    
    try {
        save_undo_state();
        new_program_without_undo();
        
        var file = file_text_open_read(file_path);
        while (!file_text_eof(file)) {
            var line = file_text_read_string(file);
            file_text_readln(file);
            
            if (string_trim(line) != "") {
                var space_pos = string_pos(" ", line);
                if (space_pos > 0) {
                    var line_num_str = string_copy(line, 1, space_pos - 1);
					                    var line_num = real(line_num_str);
                    var code_content = string_copy(line, space_pos + 1, string_length(line));
                    
                    if (is_line_number(line_num_str) && is_valid_line_number(line_num)) {
                        ds_map_set(global.program_lines, line_num, code_content);
                        insert_line_number_ordered(line_num);
                    }
                }
            }
        }
        file_text_close(file);
        current_filename = filename;
        basic_show_message("LOADED via DRAG: " + filename);
        update_display();
    } catch (e) {
        show_error_message("DRAG LOAD ERROR");
    }
 }
/// @function editor_import_text_to_program(_text)
/// @desc Parse plain text into numbered BASIC lines and import.
/// Lines in form "NNN CODE..."; a bare "NNN" deletes that line.
function editor_import_text_to_program(_text) {
    if (!is_string(_text)) return 0;

    // Normalize line endings
    var blob = string_replace_all(string_replace_all(_text, "\r\n", "\n"), "\r", "\n");

    var count = 0;
    var i = 1, len = string_length(blob), start = 1;
    while (i <= len + 1) {
        if (i > len || string_char_at(blob, i) == "\n") {
            var line = string_trim(string_copy(blob, start, i - start));
            if (line != "") {
                var sp = string_pos(" ", line);
                var ln_str = (sp > 0) ? string_copy(line, 1, sp - 1) : line;
                var code   = (sp > 0) ? string_trim(string_copy(line, sp + 1, string_length(line))) : "";
                var _ln = real(ln_str);
                if (ln_str != "" && is_real(_ln) && _ln > 0) {
                    if (code == "") {
                        // delete empty-numbered line
                        if (function_exists("delete_program_line")) delete_program_line(_ln);
                    } else {
                        if (function_exists("add_or_update_program_line")) add_or_update_program_line(_ln, code);
                    }
                    count++;
                }
            }
            start = i + 1;
        }
        i++;
    }
    return count;
}

function editor_html_dir_show() {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("html_dir_files") || ds_list_size(global.html_dir_files) == 0) {
        basic_show_message("No files selected. Use DIR to choose files first.");
        return false;
    }

    var ed = instance_find(obj_editor, 0);
    if (ed == noone) return false;

    // Initialize directory variables
    ed.dir_listing = [];
    ed.showing_dir_overlay = false;
    ed.dir_save_dir = "";

    // Build listing from html_dir_files
    var n = ds_list_size(global.html_dir_files);
    for (var i = 0; i < n; i++) {
        var rec = global.html_dir_files[| i];
        var filename = ds_map_find_value(rec, "name");
        array_push(ed.dir_listing, filename);
    }
    
    if (n == 0) {
        array_push(ed.dir_listing, "No .bas files found.");
    }

    // Initialize overlay state
    ed.dir_sel = 0;
    ed.dir_page = 0;
    ed.dir_page_size = 1;
    ed.dir_sorted_by = "name";
    ed.dir_filter = "";
    ed.dir_preview_on = false;
    ed.dir_confirm_active = false;
    ed.dir_confirm_index = -1;
    ed.dir_mouse_hover_row = -1;
    ed.dir_mouse_hover_action = "";

    // Show the overlay
    ed.showing_dir_overlay = true;
    return true;
}
function save_undo_state() {
    // Placeholder for undo system
    // Eventually, you could push a copy of global.program_lines to a stack
	/// TODO: Implement undo functionality for BASIC editor
/// --------------------------------------------------
/// This function should snapshot the current program state so it can be restored later via an "UNDO" command.
/// A stack-based approach is recommended, where each saved state is pushed onto a list (e.g., global.undo_stack).
///
/// Suggested structure per snapshot:
/// - A ds_map with keys like "global.program_lines", "global.line_numbers", and optionally "cursor_pos"
/// - Each key maps to a *copy* (not a reference) of the original ds_map or ds_list
///
/// Pseudocode for future implementation:
/// ```gml
/// var snapshot = ds_map_create();
/// ds_map_add_list(snapshot, "global.line_numbers", ds_list_copy(global.line_numbers));
/// ds_map_add_map(snapshot, "global.program_lines", ds_map_copy(global.program_lines));
/// ds_stack_push(global.undo_stack, snapshot);
/// ```
///
/// Don't forget to:
/// - Create `global.undo_stack` once during initialization (e.g., in obj_globals)
/// - Clean up with `ds_map_destroy()` and `ds_list_destroy()` when popping or discarding states
///
/// For now, this is a placeholder to suppress runtime errors.

}

function basic_evaluate_expression(expr) {
    expr = string_trim(expr);

    // Variable lookup
    if (ds_map_exists(global.basic_variables, string_upper(expr))) {
        return global.basic_variables[? string_upper(expr)];
    }

    // Handle MOD
    if (string_pos("MOD", string_upper(expr)) > 0) {
        var parts = string_split(string_upper(expr), "MOD");
        if (array_length(parts) == 2) {
            var a = real(basic_evaluate_expression_v2(parts[0]));
            var b = real(basic_evaluate_expression_v2(parts[1]));
            return a mod b;
        }
    }

    // Handle RND(n)
    if (string_upper(string_copy(expr, 1, 4)) == "RND(" && string_char_at(expr, string_length(expr)) == ")") {
        var inner = string_copy(expr, 5, string_length(expr) - 5);
        return irandom(real(basic_evaluate_expression_v2(inner)));
    }

    // Handle ABS(x)
    if (string_upper(string_copy(expr, 1, 4)) == "ABS(" && string_char_at(expr, string_length(expr)) == ")") {
        var inner = string_copy(expr, 5, string_length(expr) - 5);
        return abs(real(basic_evaluate_expression_v2(inner)));
    }

    // Fallback to real()
    return real(expr);
}

/// @function screen_editor_display_line(editor_inst, line_text, screen_row)
function screen_editor_display_line(editor_inst, line_text, screen_row) {
    with (editor_inst) {
        // Clear the row first
        for (var clear_x = 0; clear_x < screen_cols; clear_x++) {
            screen_editor_set_char_at(id, clear_x, screen_row, ord(" "));
        }
        
        // Apply horizontal offset only to cursor line
        var display_text = line_text;
        if (screen_row == cursor_y && horizontal_offset > 0) {
            display_text = string_copy(line_text, horizontal_offset + 1, screen_cols);
        }
        
        // Display the text
        var text_len = min(string_length(display_text), screen_cols);
        for (var j = 1; j <= text_len; j++) {
            var ch = string_char_at(display_text, j);
            screen_editor_set_char_at(id, j - 1, screen_row, ord(ch));
        }
        
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Displayed line " + string(screen_row) + 
                          (screen_row == cursor_y ? " (with offset " + string(horizontal_offset) + ")" : " (no offset)"));
    }
}
// ===============================================
// FILE: scripts/refresh_current_line_display/refresh_current_line_display.gml
// NEW: Helper function to update display for current line
// ===============================================

/// @function refresh_current_line_display(editor_inst)
function refresh_current_line_display(editor_inst) {
    with (editor_inst) {
        var full_text = get_full_line_text(id, cursor_y);
        var display_text = string_copy(full_text, horizontal_offset + 1, screen_cols);
        
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Refreshing display - full_text='" + full_text + "', display='" + display_text + "', h_offset=" + string(horizontal_offset));
        
        // Clear the row
        screen_editor_clear_row(id, cursor_y);
        
        // Display the visible portion
        for (var i = 1; i <= string_length(display_text); i++) {
            var ch = string_char_at(display_text, i);
            screen_editor_set_char_at(id, i - 1, cursor_y, ord(ch));
        }
    }
}
/// @function basic_cmd_goto(arg)
/// @description Sets the program counter to a new line number if it exists.
function basic_cmd_goto(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("GOTO START — Raw arg: '" + arg + "'");

    var trimmed_arg = string_trim(arg);
    var target_line = real(trimmed_arg);

    if (dbg_on(DBG_FLOW)) show_debug_message("GOTO: Parsed target line number: " + string(target_line));

    // Find the index in your line_list
    var index = -1;
	for (var i = 0; i < ds_list_size(global.line_list); i++) {
	    if (real(ds_list_find_value(global.line_list, i)) == target_line) {
	        index = i;
	        break;
	    }
	}

	
    if (index >= 0) {
        global.interpreter_next_line = index;
        if (dbg_on(DBG_FLOW)) show_debug_message("GOTO SUCCESS → Jumping to line " + string(target_line) + " (list index " + string(index) + ")");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("?GOTO ERROR: Line number " + string(target_line) + " not found in global.line_list");
    }
}

/// @script basic_error_hint
/// Return an array of short hint lines (<= 3) for a given key.
function basic_error_hint(key) {
    var lines = [];
    switch (string_upper(string(key))) {
        case "INKEY_MISUSE":
            lines[0] = "INKEY$ must assign to a var.";
            lines[1] = "Use:  K$ = INKEY$";
            lines[2] = "Then PRINT K$ if desired.";
            break;

        case "IF_MISSING_THEN":
            lines[0] = "Use: IF cond THEN stmt";
            lines[1] = "Or multi-line IF...ENDIF";
            lines[2] = "Example: IF X=1 THEN PRINT X";
            break;

        case "FOR_MISMATCH":
            lines[0] = "FOR must have matching NEXT.";
            lines[1] = "Example: FOR I=1 TO 10 : ... : NEXT";
            break;

        case "WHILE_MISMATCH":
            lines[0] = "WHILE must end with WEND.";
            break;

        default:
            lines[0] = ""; lines[1] = ""; lines[2] = "";
            break;
    }
    return lines;
}

/// @event obj_globals/Async - HTTP
// This event only triggers when an HTTP request completes
// async_load is automatically valid here

var req_id = ds_map_find_value(async_load, "id");
if (!variable_global_exists("http_tags")) exit;
if (!ds_map_exists(global.http_tags, req_id)) exit;

var tag  = ds_map_find_value(global.http_tags, req_id);
var stat = ds_map_find_value(async_load, "status"); // 0 = OK
var body = ds_map_find_value(async_load, "result");

// Clean up the tag immediately
ds_map_delete(global.http_tags, req_id);

if (tag == ":LOADURL") {
    if (stat == 0 && is_string(body)) {
        var n = editor_import_text_to_program(body);
        show_error_message("Imported " + string(n) + " line(s) from URL.");
    } else {
        var sc = ds_map_find_value(async_load, "http_status");
        show_error_message("LOADURL failed (status=" + string(sc) + ").");
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function set_color_scheme(scheme) {
    scheme = string_upper(scheme);
    switch (scheme) {
        case "GREEN":
            keyword_color = c_lime;
            text_color = c_green;
            number_color = c_yellow;
            break;
        case "BLUE":
            keyword_color = c_cyan;
            text_color = c_blue;
            number_color = c_white;
            break;
        case "AMBER":
            keyword_color = c_orange;
            text_color = c_yellow;
            number_color = c_white;
            break;
        default:
            show_error_message("UNKNOWN COLOR SCHEME");
            return;
    }
    basic_show_message("COLOR SCHEME: " + scheme);
    update_display();
 }
// SCRIPT: basic_stop_execution
function basic_stop_execution() {
    if (dbg_on(DBG_FLOW)) show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    if (dbg_on(DBG_FLOW)) show_debug_message("BASIC_STOP_EXECUTION CALLED!");
    if (dbg_on(DBG_FLOW)) show_debug_message("Call Stack:");
    if (dbg_on(DBG_FLOW)) show_debug_message(debug_get_callstack()); // THIS IS THE KEY!
    if (dbg_on(DBG_FLOW)) show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

    global.interpreter_running = false;
    global.awaiting_input = false;
    global.program_has_ended = true;

    // Clear input buffer if input was pending
    if (global.input_buffer != undefined && ds_list_exists(global.input_buffer, ds_type_list)) {
        ds_list_clear(global.input_buffer);
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function process_input_line(input_text) {
    // Trim whitespace
    input_text = string_trim(input_text);
    
    if (input_text == "") return;
    
    // Check if line starts with a number
    var first_space = string_pos(" ", input_text);
    var potential_line_num = "";
    
    if (first_space > 0) {
        potential_line_num = string_copy(input_text, 1, first_space - 1);
    } else {
        potential_line_num = input_text;
    }
    
    // Check if it's a valid line number
    if (is_line_number(potential_line_num)) {
        handle_program_line(input_text);
    } else {
        handle_command(input_text);
    }
 }
/// @function inkey_enq(val, cap)
function inkey_enq(val, cap) {
    if (!variable_global_exists("inkey_queue") || !ds_exists(global.inkey_queue, ds_type_queue)) {
        global.inkey_queue = ds_queue_create();
    }
    while (ds_queue_size(global.inkey_queue) >= cap) ds_queue_dequeue(global.inkey_queue);
    ds_queue_enqueue(global.inkey_queue, val);

    if (variable_global_exists("DBG_PARSE") && dbg_on(DBG_PARSE)) {
        var s  = string(val);
        var a1 = (is_string(s) && string_length(s)>=1) ? ord(string_char_at(s,1)) : -1;
        var a2 = (is_string(s) && string_length(s)>=2) ? ord(string_char_at(s,2)) : -1;
        show_debug_message("##KEYFEED## ENQ='" + s + "' A1=" + string(a1) + " A2=" + string(a2));
    }
}
function dump_program_to_console() {
    if (dbg_on(DBG_FLOW)) show_debug_message("==== BASIC PROGRAM DUMP ====");

    var lines = global.line_numbers; // numeric line numbers
    var prog = global.program_lines;

    for (var i = 0; i < ds_list_size(lines); i++) {
        var linenum = ds_list_find_value(lines, i); // numeric
        if (ds_map_exists(prog, linenum)) {
            var code = ds_map_find_value(prog, linenum);
            if (dbg_on(DBG_FLOW)) show_debug_message(string(linenum) + " " + code);
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("Missing entry for key: " + string(linenum));
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("==== END OF DUMP ====");
}

function basic_parse_csv_args(str) {
    var args = [];
    var current = "";
    var in_quotes = false;
    var i = 1;
    var len = string_length(str);

    while (i <= len) {
        var c = string_char_at(str, i);

        if (c == "\"") {
            in_quotes = !in_quotes;
            current += c; // Preserve quote so later commands can detect strings
        }
        else if (c == "," && !in_quotes) {
            array_push(args, string_trim(current));
            current = "";
        }
        else {
            current += c;
        }

        i += 1;
    }

    if (string_length(current) > 0) {
        array_push(args, string_trim(current));
    }

    return args;
}

// FILE: scripts/screen_editor_get_row_text/screen_editor_get_row_text.gml
/// @function screen_editor_get_row_text(editor_inst, _row)
function screen_editor_get_row_text(editor_inst, _row) {
    with (editor_inst) {
        if (_row < 0 || _row >= screen_rows) return "";
        
        var text = "";
        var last_non_space = -1;
        
        for (var _x = 0; _x < screen_cols; _x++) {
            var ch = chr(screen_editor_get_char_at(id, _x, _row));
            text += ch;
            if (ch != " ") last_non_space = _x;
        }
        
        return (last_non_space >= 0) ? string_copy(text, 1, last_non_space + 1) : "";
    }
}
function get_precedence(op) {
    switch (string_upper(op)) {
        // Logical operators (lowest precedence)
        case "OR":
            return 0;
        case "AND": 
            return 1;
        // Relational comparisons
        case "=": case "<>": case "<": case ">": case "<=": case ">=":
            return 2;
        // Add/subtract
        case "+": case "-":
            return 3;
        // Multiply/divide/mod
        case "*": case "/": case "\\": case "%": case "MOD":
            return 4;
        // Exponentiation (highest precedence)
        case "^":
            return 5;
        default:
            return 0;
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function navigate_history_down() {
	 if (global.justreturned == 1) return; // 🛑 Block history on return
	 
    if (global.history_index != -1) {
        global.history_index++;
        if (global.history_index >= ds_list_size(global.input_history)) {
            global.history_index = -1;
            current_input = "";
        } else {
            current_input = ds_list_find_value(global.input_history, global.history_index);
        }
        cursor_pos = string_length(current_input);
    }
 }
/// @function import_from_url(_url)
/// @desc Fetch text at URL, then import into the editor as numbered lines.
function import_from_url(_url) {
    if (!is_string(_url) || _url == "") {
        show_error_message("Usage: :LOADURL <http(s)://...>");
        return;
    }
    if (!variable_global_exists("http_tags")) global.http_tags = ds_map_create();

    var req = http_get(_url);
    // Store a tag so we know why this request happened
    ds_map_replace(global.http_tags, req, ":LOADURL");
   if (dbg_on(DBG_FLOW)) show_debug_message("[LOADURL] GET -> " + _url + " (req=" + string(req) + ")");
}

/// Decode a data: URL (base64) into a text string (ASCII/UTF-8)
function editor_html_decode_data_url_to_text(data_url) {
    var comma = string_pos(",", data_url);
    if (comma <= 0) return "";
    var b64 = string_copy(data_url, comma + 1, string_length(data_url) - comma);

    var buf = buffer_base64_decode(b64); // native GMS
    if (buf <= 0) return "";
    buffer_seek(buf, buffer_seek_start, 0);

    var n = buffer_get_size(buf);
    var s = "";
    for (var i = 0; i < n; i++) {
        s += chr(buffer_read(buf, buffer_u8));
    }
    buffer_delete(buf);
    return s;
}

function split_on_unquoted_semicolons(s) {
    var result = [];
    var current = "";
    var in_string = false;
    for (var i = 1; i <= string_length(s); i++) {
        var c = string_char_at(s, i);
        if (c == "\"") in_string = !in_string;
        if (c == ";" && !in_string) {
            array_push(result, string_trim(current));
            current = "";
        } else {
            current += c;
        }
    }
    if (string_length(current) > 0) array_push(result, string_trim(current));
    return result;
}

// FILE: scripts/mode1_grid_clear.gml
// FUNCTION: mode1_grid_clear(char_index)
// CHANGE: Remove 15x18 constants; iterate over actual grid

/// @param char_index
function mode1_grid_clear(char_index) {
    var cols = grid_cols;
    var rows = grid_rows;

    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var i = row * cols + col;
            grid[i].char = char_index;
            grid[i].fg = c_white;
            grid[i].bg = c_black;
        }
    }
}

/// @function interpreter_cmd_print(argument)
/// @description Handles the BASIC PRINT command.
/// @param arg - The string argument from the BASIC code

function interpreter_cmd_print(arg) {
    // Remove surrounding double quotes if present
    if (string_length(arg) >= 2 &&
        string_char_at(arg, 1) == "\"" &&
        string_char_at(arg, string_length(arg)) == "\"") {
        arg = string_copy(arg, 2, string_length(arg) - 2);
    }

    ds_list_add(output_lines, arg);
}

/// @function mode1_get_color(col, row)
/// @description Get foreground color at grid position  
function mode1_get_color(col, row) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return c_white;
    
    var cols = 40;
    var rows = 25;
    
    if (col < 0 || col >= cols || row < 0 || row >= rows) {
        return c_white; // Return white for out of bounds
    }
    
    var i = col + row * cols;
    return grid_obj.grid[i].fg;
}
/// @function is_function_token(token)
/// @description Checks if a given token is a recognized BASIC function.
/// @param {string} token The token to check.
/// @returns {boolean} True if it's a function, false otherwise.
function is_function_token(token) {
    var upper_token = string_upper(token);
    // Add more functions here as you implement them in evaluate_postfix
    return upper_token == "RND" || upper_token == "ABS";
}
function dbg(cat, msg) {
    // Off fast-path
    if ((global.debug_mask & cat) == 0) return;

    // Per-frame quota (avoid tanking fps)
    if (global.dbg_frame_count >= global.dbg_frame_quota) {
        global.dbg_dropped_count++;
        return;
    }
    global.dbg_frame_count++;

    // ✅ Print unconditionally now that the category is enabled
   if (dbg_on(DBG_FLOW)) show_debug_message(msg);
}

function is_operator(op) {
    return (op == "+" || op == "-" || op == "*" || op == "/" || op == "\\" || op == "^" || 
            op == "%" || string_upper(op) == "MOD" ||
            op == "=" || op == "<>" || op == "<" || op == ">" || op == "<=" || op == ">=" ||
            string_upper(op) == "AND" || string_upper(op) == "OR");
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function toggle_syntax_highlighting() {
    syntax_highlighting = !syntax_highlighting;
    basic_show_message("SYNTAX HIGHLIGHTING: " + (syntax_highlighting ? "ON" : "OFF"));
    update_display();
 }


/// @param char_index
/// @param fg_color
/// @param bg_color
function mode1_grid_fill(char_index, fg_color, bg_color) {
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char_index;
        grid[i].fg = fg_color;
        grid[i].bg = bg_color;
    }
}

function basic_evaluate_expression_v2(expr) {
    var tokens = basic_tokenize_expression_v2(expr);
    if (dbg_on(DBG_FLOW)) show_debug_message("Tokens: " + string(tokens)); // for debug
    var postfix = infix_to_postfix(tokens);
    return evaluate_postfix(postfix);
}

/// scripts/gm_receive_paste.gml
function gm_receive_paste(_text) {
    global.import_text  = is_string(_text) ? _text : "";
    global.import_ready = (global.import_text != "");
    show_error_message("Import received."); // visible confirmation
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_current_colors() {
    basic_show_message("CURRENT SCHEME - USE: COLOR GREEN/BLUE/AMBER");
 }
// Call this to display a message for roughly 2 seconds (120 frames at 60 fps).
function basic_show_message(msg) {
    message_text  = msg;
    global.message_timer = 120;
}
/// @event obj_mode1_grid/Destroy
// You can write your code in this editor
reset_interpreter_state();
global.current_mode = 0;
show_message(" Unto the abyss I fall");
/// Persistent filter for YAL open dialog (files only)
function editor_html_dir__open_filter(kind, type) {
    return (kind == "file");
}

/// @function inkey_enqueue_char(kc, cap)
function inkey_enqueue_char(kc, cap) {
    inkey_enq(chr(kc), cap);
}
function dbg_on(cat) {
    return (global.debug_mask & cat) != 0;
}


function is_right_associative(op) {
    return (op == "^");
}
