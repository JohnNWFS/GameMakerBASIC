/// @file objects/obj_screen_editor/Step_0.gml
/// @event Step
/// Final corrected horizontal scrolling implementation

// Handle ESC key - exit screen editor
if (keyboard_check_pressed(vk_escape)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: ESC pressed - exiting");
    screen_editor_exit(id);
    exit;
}

// Initialize line_modified flag if it doesn't exist
if (!variable_instance_exists(id, "line_modified")) {
    line_modified = false;
}

// Initialize key repeat timer for smoother arrow key movement
if (!variable_instance_exists(id, "arrow_repeat_timer")) {
    arrow_repeat_timer = 0;
}

// Handle cursor movement with horizontal scrolling
if (keyboard_check(vk_left)) {
    if (arrow_repeat_timer <= 0) {
        if (cursor_x > 0) {
            cursor_x--;
        } else if (horizontal_offset > 0) {
            // At left edge of screen, scroll left
            horizontal_offset--;
            screen_editor_load_program(id);
            if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled left - new h_offset=" + string(horizontal_offset));
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cursor left to (" + string(cursor_x) + "," + string(cursor_y) + "), h_offset=" + string(horizontal_offset));
        arrow_repeat_timer = 4; // 4-frame delay between movements
    }
}

if (keyboard_check(vk_right)) {
    if (arrow_repeat_timer <= 0) {
        // Get the FULL line content directly from program storage, not from screen buffer
        var line_index = cursor_y + scroll_offset;
        var full_line_text = "";
        
        if (line_index < ds_list_size(global.line_numbers)) {
            var line_num = ds_list_find_value(global.line_numbers, line_index);
            var code = ds_map_find_value(global.program_lines, line_num);
            full_line_text = string(line_num) + " " + code;
        }
        
        var actual_cursor_pos = cursor_x + horizontal_offset;
        var full_line_length = string_length(full_line_text);
        
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Right arrow - cursor_x=" + string(cursor_x) + ", h_offset=" + string(horizontal_offset) + ", actual_pos=" + string(actual_cursor_pos) + ", full_line_len=" + string(full_line_length));
        
        // Allow scrolling through the entire line content
        if (actual_cursor_pos < full_line_length && actual_cursor_pos < 200) {
            if (cursor_x < 79) {  // Use 79 for your 80-character screen
                cursor_x++;
            } else {
                // At right edge of screen, scroll right
                horizontal_offset++;
                screen_editor_load_program(id);
                if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled right - new h_offset=" + string(horizontal_offset));
            }
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: After right - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), h_offset=" + string(horizontal_offset));
        arrow_repeat_timer = 4; // 4-frame delay between movements
    }
}

// Decrement the arrow key repeat timer
if (arrow_repeat_timer > 0) {
    arrow_repeat_timer--;
}

if (keyboard_check_pressed(vk_up)) {
    // If current line was modified, commit it first
    if (line_modified) {
        screen_editor_commit_row(id, cursor_y);
        line_modified = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Auto-committed modified line before moving up");
    }
    
    // Store the desired horizontal position
    var desired_x = cursor_x + horizontal_offset;
    
    // Clear ALL keyboard input to prevent character leakage
    keyboard_string = "";
    keyboard_lastchar = "";
    keyboard_lastkey = 0;
    
    // Reset horizontal scrolling - always show left edge of new line
    horizontal_offset = 0;
    
    if (cursor_y > 0) {
        cursor_y--;
    } else if (scroll_offset > 0) {
        scroll_offset--;
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled up - scroll_offset=" + string(scroll_offset));
    }
    
    // Smart cursor positioning for new line
    var new_line_text = screen_editor_get_row_text(id, cursor_y);
    var new_line_length = string_length(new_line_text);
    var target_pos = min(desired_x, new_line_length);
    cursor_x = min(target_pos, 79);
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Up - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), cleared input");
}

if (keyboard_check_pressed(vk_down)) {
    // If current line was modified, commit it first
    if (line_modified) {
        screen_editor_commit_row(id, cursor_y);
        line_modified = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Auto-committed modified line before moving down");
    }
    
    // Store the desired horizontal position
    var desired_x = cursor_x + horizontal_offset;
    
    // Clear ALL keyboard input to prevent character leakage
    keyboard_string = "";
    keyboard_lastchar = "";
    keyboard_lastkey = 0;
    
    // Reset horizontal scrolling - always show left edge of new line
    horizontal_offset = 0;
    
    var total_lines = ds_list_size(global.line_numbers);
    var visible_lines = min(screen_rows, total_lines - scroll_offset);
    
    if (cursor_y < visible_lines - 1 && cursor_y < screen_rows - 1) {
        cursor_y++;
    } else if (scroll_offset + screen_rows < total_lines) {
        scroll_offset++;
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled down - scroll_offset=" + string(scroll_offset));
    }
    
    // Smart cursor positioning for new line
    var new_line_text = screen_editor_get_row_text(id, cursor_y);
    var new_line_length = string_length(new_line_text);
    var target_pos = min(desired_x, new_line_length);
    cursor_x = min(target_pos, 79);
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Down - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), cleared input");
}

// Handle Page Up/Down
if (keyboard_check_pressed(vk_pageup)) {
    var old_offset = scroll_offset;
    scroll_offset = max(0, scroll_offset - screen_rows);
    if (scroll_offset != old_offset) {
        horizontal_offset = 0;
        cursor_x = min(cursor_x, 79);
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Page Up - scroll_offset " + string(old_offset) + " -> " + string(scroll_offset));
    }
}

if (keyboard_check_pressed(vk_pagedown)) {
    var old_offset = scroll_offset;
    var total_lines = ds_list_size(global.line_numbers);
    scroll_offset = min(max(0, total_lines - screen_rows), scroll_offset + screen_rows);
    if (scroll_offset != old_offset) {
        horizontal_offset = 0;
        cursor_x = min(cursor_x, 79);
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Page Down - scroll_offset " + string(old_offset) + " -> " + string(scroll_offset));
    }
}

// Home/End key support
if (keyboard_check_pressed(vk_home)) {
    cursor_x = 0;
    horizontal_offset = 0;
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Home pressed - jump to beginning");
}

if (keyboard_check_pressed(vk_end)) {
    var current_line_text = screen_editor_get_row_text(id, cursor_y);
    var line_length = string_length(current_line_text);
    
    if (line_length <= 80) {
        // Line fits on screen
        cursor_x = line_length;
        horizontal_offset = 0;
    } else {
        // Line is longer - scroll to show the end
        horizontal_offset = line_length - 80;
        cursor_x = 79;
    }
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: End pressed - jump to end, cursor=" + string(cursor_x) + ", h_offset=" + string(horizontal_offset));
}


// Character input
if (keyboard_check_pressed(vk_anykey)) {
    var k  = keyboard_lastkey;
    var ch = keyboard_lastchar;

    // Is this a printable keystroke (not pure modifier / not control)?
    var _is_printable =
        (k != vk_shift && k != vk_control && k != vk_alt) &&
        (!is_undefined(ch)) && (ch != "") && (ord(ch) >= 32);

    // CRITICAL: Ignore arrow keys and other navigation keys to prevent interference
    var _is_nav =
        keyboard_check(vk_left) || keyboard_check(vk_right) ||
        keyboard_check(vk_up)   || keyboard_check(vk_down)  ||
        keyboard_check_pressed(vk_left) || keyboard_check_pressed(vk_right) ||
        keyboard_check_pressed(vk_up)   || keyboard_check_pressed(vk_down)  ||
        keyboard_check_pressed(vk_home) || keyboard_check_pressed(vk_end)   ||
        keyboard_check_pressed(vk_pageup) || keyboard_check_pressed(vk_pagedown) ||
        keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_backspace) ||
        keyboard_check_pressed(vk_escape);

    // Only run the INSERT path for printable, non-nav keys.
    if (_is_printable && !_is_nav) {

        if (string_length(ch) == 1) {
            var ascii_code = ord(ch);
            if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Key pressed - char '" + ch + "', ASCII " + string(ascii_code));

            if (ascii_code >= 32 && ascii_code <= 126) {
                var current_line_text = screen_editor_get_row_text(id, cursor_y);
                var actual_cursor_pos = cursor_x + horizontal_offset;

                // Preserve intentional trailing spaces up to cursor (since get_row_text trims)
                if (string_length(current_line_text) < actual_cursor_pos) {
                    var pad = actual_cursor_pos - string_length(current_line_text);
                    repeat (pad) { current_line_text += " "; }
                }

                if (string_length(current_line_text) < 200) {
                    // Insert character at actual position
                    var before_cursor = string_copy(current_line_text, 1, actual_cursor_pos);
                    var after_cursor  = string_copy(current_line_text, actual_cursor_pos + 1, string_length(current_line_text));
                    var new_line      = before_cursor + ch + after_cursor;

                    // Update the actual BASIC program line
                    var line_index = cursor_y + scroll_offset;
                    if (line_index < ds_list_size(global.line_numbers)) {
                        var line_num  = ds_list_find_value(global.line_numbers, line_index);
                        var space_pos = string_pos(" ", new_line);
                        if (space_pos > 0) {
                            var code_part = string_copy(new_line, space_pos + 1, string_length(new_line));
                            ds_map_set(global.program_lines, line_num, code_part);
                        }
                    }

                    // Mark line as modified
                    line_modified = true;

                    // Advance cursor
                    if (cursor_x < 79) {
                        cursor_x++;
                    } else {
                        horizontal_offset++;
                    }

                    screen_editor_load_program(id);
                    // keep the live edit visible even if this is a not-yet-committed/new line
                    screen_editor_display_line(id, new_line, cursor_y);

                } else {
                    basic_show_message("Line too long (max 200 chars)");
                }
            }
        }
    }
    // IMPORTANT: do not exit here — lets Enter/Backspace handlers run later in Step
}



// Backspace
if (keyboard_check_pressed(vk_backspace)) {
    var current_line_text = screen_editor_get_row_text(id, cursor_y);
    var actual_cursor_pos = cursor_x + horizontal_offset;
	
	// ADD this padding block (so backspace can delete spaces you just typed):
	if (string_length(current_line_text) < actual_cursor_pos) {
	    var pad = actual_cursor_pos - string_length(current_line_text);
	    repeat (pad) { current_line_text += " "; }
	}
    
    if (actual_cursor_pos > 0) {
        // Delete character
        var before_cursor = string_copy(current_line_text, 1, actual_cursor_pos - 1);
        var after_cursor = string_copy(current_line_text, actual_cursor_pos + 1, string_length(current_line_text));
        var new_line = before_cursor + after_cursor;
        
        // Update program line
        var line_index = cursor_y + scroll_offset;
        if (line_index < ds_list_size(global.line_numbers)) {
            var line_num = ds_list_find_value(global.line_numbers, line_index);
            var space_pos = string_pos(" ", new_line);
            if (space_pos > 0) {
                var code_part = string_copy(new_line, space_pos + 1, string_length(new_line));
                ds_map_set(global.program_lines, line_num, code_part);
            }
        }
        
        // Mark line as modified
        line_modified = true;
        
        // Move cursor back
        if (cursor_x > 0) {
            cursor_x--;
        } else if (horizontal_offset > 0) {
            horizontal_offset--;
        }
        
        screen_editor_load_program(id);
		
		// re-assert the edited row on screen after the reload
		screen_editor_display_line(id, new_line, cursor_y);
    }
}

// Enter key
if (keyboard_check_pressed(vk_enter)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Enter pressed - committing row " + string(cursor_y));
    screen_editor_commit_row(id, cursor_y);
    
    horizontal_offset = 0;
    cursor_x = 0;
    
    screen_editor_load_program(id);
    
    if (cursor_y < screen_rows - 1) {
        cursor_y++;
    }
}

// Cursor blink
blink_timer++;
if (blink_timer >= 30) {
    cursor_visible = !cursor_visible;
    blink_timer = 0;
}
/// @function handle_basic_command(cmd, arg)
/// @description Routes BASIC commands (and multiple colon-separated statements) to the correct functions
function handle_basic_command(cmd, arg) {
    // Rebuild the full statement (so we catch any colons in the original)
    var full = string_trim(cmd + (string_length(arg) ? " " + arg : ""));

    // Split on unquoted, top-level colons.
    var parts = split_on_unquoted_colons(full);

    // Dispatch each sub-statement in turn
    for (var i = 0; i < array_length(parts); i++) {
        var stmt = string_trim(parts[i]);
        if (stmt == "") continue;

        if (dbg_on(DBG_FLOW)) show_debug_message("DISPATCH PART: " + stmt);

        // Strip any trailing REM (apostrophe handled inside)
        stmt = strip_basic_remark(stmt);

        // Pull off the verb vs. the rest
        var sp = string_pos(" ", stmt);
        var _verb, _rest;
        if (sp > 0) {
            _verb = string_upper(string_copy(stmt, 1, sp - 1));
            _rest = string_trim(string_copy(stmt, sp + 1, string_length(stmt)));
        } else {
            _verb = string_upper(stmt);
            _rest = "";
        }

        // Skip INKEY$ as command (handled as function in evaluate_postfix)
        if (_verb == "INKEY$") {
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Ignored as command, treated as function");
            continue;
        }

        // ---------- SYNTAX GUARD: INKEY$ misuse (quote-aware) ----------
        {
            var _src  = stmt;   // stmt already had remarks stripped
            var _len  = string_length(_src);
            var _up   = string_upper(_src);

            var inq = false;
            var i2  = 1;
            var found_inkey = false;
            var eq_pos = 0;

            while (i2 <= _len) {
                var ch = string_char_at(_src, i2);
                if (ch == "\"") {
                    if (i2 < _len && string_char_at(_src, i2 + 1) == "\"") { i2 += 2; continue; }
                    inq = !inq; i2++; continue;
                }
                if (!inq) {
                    if (eq_pos == 0 && ch == "=") eq_pos = i2;
                    if (i2 + 5 <= _len && string_copy(_up, i2, 6) == "INKEY$") { found_inkey = true; break; }
                }
                i2++;
            }

            if (found_inkey) {
                var implicit_assign = false;
                if (eq_pos > 0) {
                    var lhs = string_trim(string_copy(_src, 1, eq_pos - 1));
                    if (string_length(lhs) > 0) {
                        var h  = string_upper(string_char_at(lhs, 1));
                        var oc = ord(h);
                        if (oc >= 65 && oc <= 90) implicit_assign = true;
                    }
                }
                if (!(_verb == "LET" || implicit_assign)) {
                    basic_syntax_error(
                        "INKEY$ may only appear on the right side of an assignment like  K$ = INKEY$",
                        global.current_line_number,
                        global.interpreter_current_stmt_index,
                        "INKEY_MISUSE"
                    );
                    return;
                }
            }
        }
        // ---------- END SYNTAX GUARD ----------

        // Guard: IF must contain THEN in the same statement
        if (_verb == "IF" && string_pos("THEN", string_upper(_rest)) <= 0) {
            basic_syntax_error(
                "IF requires THEN",
                /* line_no */ undefined,
                /* stmt_idx */ global.interpreter_current_stmt_index,
                "IF REQUIRES THEN"
            );
            return;
        }

        // === INLINE IF COLLAPSE (only within THIS colon segment) ===
        if (_verb == "IF") {
            // Reconstruct the original physical line from the dispatcher’s position
            var line_idx   = global.interpreter_current_line_index; // set by Step
            var line_no    = global.line_list[| line_idx];
            var src_line   = ds_map_find_value(global.program_map, line_no);
            var parts_full = split_on_unquoted_colons(string_trim(src_line));

            // Use ONLY the current colon segment (do NOT append the rest of the line)
            var p       = global.interpreter_current_stmt_index;  // set by Step
            var segment = parts_full[p];

            // Text after the "IF" keyword within THIS segment only
            var after_if  = string_trim(string_copy(segment, 3, max(0, string_length(segment) - 2)));
            var up_after  = string_upper(after_if);

            var has_then = (string_pos("THEN", up_after) > 0);

            // Is there content after THEN within THIS segment?
            var has_content_after_then = false;
            if (has_then) {
                var then_pos   = string_pos("THEN", up_after);
                var after_then = string_trim(string_copy(after_if, then_pos + 4, string_length(after_if)));
                has_content_after_then = (string_length(after_then) > 0);
            }

            if (has_content_after_then) {
                // Inline: parse THEN/ELSE only inside this segment
                var arg_full = string_trim(string_copy(segment, 3, string_length(segment) - 2)); // after "IF"

                if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH (collapsed IF): IF | ARG: " + arg_full);

                // Find top-level THEN (quote/paren-aware)
                var _arg = arg_full;
                var _L   = string_length(_arg);
                var _lvl = 0, _inq = false, _then_pos = 0;
                for (var _i = 1; _i <= _L - 4 + 1; _i++) {
                    var _ch = string_char_at(_arg, _i);
                    if (_ch == "\"") _inq = !_inq;
                    if (!_inq) {
                        if (_ch == "(") _lvl++;
                        else if (_ch == ")") _lvl = max(0, _lvl - 1);
                        if (_lvl == 0 && string_upper(string_copy(_arg, _i, 4)) == "THEN") { _then_pos = _i; break; }
                    }
                }

                if (_then_pos == 0) {
                    // Fallback: old handler
                    basic_cmd_if_inline(arg_full);
                } else {
                    // Split condition and the THEN/ELSE tail (still within this segment only)
                    var _cond_src = string_trim(string_copy(_arg, 1, _then_pos - 1));
                    var _tail     = string_trim(string_copy(_arg, _then_pos + 4, _L - (_then_pos + 4) + 1));

                    // Look for a top-level ELSE
                    var _L2 = string_length(_tail), _lvl2 = 0, _inq2 = false, _else_pos = 0;
                    for (var _j = 1; _j <= _L2 - 4 + 1; _j++) {
                        var _ch2 = string_char_at(_tail, _j);
                        if (_ch2 == "\"") _inq2 = !_inq2;
                        if (!_inq2) {
                            if (_ch2 == "(") _lvl2++;
                            else if (_ch2 == ")") _lvl2 = max(0, _lvl2 - 1);
                            if (_lvl2 == 0 && string_upper(string_copy(_tail, _j, 4)) == "ELSE") { _else_pos = _j; break; }
                        }
                    }

                    var _then_src = (_else_pos > 0) ? string_trim(string_copy(_tail, 1, _else_pos - 1)) : _tail;
                    var _else_src = (_else_pos > 0) ? string_trim(string_copy(_tail, _else_pos + 4, _L2 - (_else_pos + 4) + 1)) : "";

                    // Evaluate condition
                    var _tok  = basic_tokenize_expression_v2(_cond_src);
                    var _post = infix_to_postfix(_tok);
                    var _val  = evaluate_postfix(_post);
                    var _truth = 0;
                    if (is_real(_val))        _truth = (_val != 0);
                    else if (is_string(_val)) _truth = (string_length(_val) > 0);

                    // Execute the chosen arm by reusing the normal dispatcher
                    if (_truth) {
                        if (_then_src != "") handle_basic_command(_then_src, "");
                    } else {
                        if (_else_src != "") handle_basic_command(_else_src, "");
                    }

                    if (dbg_on(DBG_FLOW)) show_debug_message(
                        "INLINE IF (" + string(_truth) + "): THEN='" + _then_src + "' ELSE='" + _else_src + "'"
                    );

                    // *** FIX: If INPUT/PAUSE occurred inside the THEN/ELSE arm,
                    // set a statement-level jump to the NEXT colon segment (p+1)
                    // and return immediately so Step resumes AFTER this IF segment.
                    if (global.pause_in_effect || global.awaiting_input) {
                        if (dbg_on(DBG_FLOW)) show_debug_message("INLINE IF: pausing after arm — scheduling resume at next segment");
                        global.interpreter_use_stmt_jump = true;
                        global.interpreter_target_line   = line_idx;
                        global.interpreter_target_stmt   = p + 1;  // resume at next colon slot (or EOL)
                        return; // yield now
                    }
                }

                // If the inline handler halted with an error, don't synthesize a jump
                if (global.program_has_ended || !global.interpreter_running) {
                    break; // stop dispatching
                }

                // Normal path (no INPUT): advance to the NEXT colon segment on this line.
                global.interpreter_use_stmt_jump = true;
                global.interpreter_target_line   = line_idx;
                global.interpreter_target_stmt   = p + 1;
                break;
            }
            // Else fall-through to the structured IF handler below.
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH: " + _verb + " | ARG: " + _rest);

        switch (_verb) {

            case "PRINT":
                if (global.current_mode >= 1) {
                    basic_cmd_print_mode1(_rest);
                } else {
                    basic_cmd_print(_rest, global.current_line_number);
                }
                break;

            case "LET":       basic_cmd_let(_rest); break;
            case "GOTO":      basic_cmd_goto(_rest); break;
            case "INPUT":     basic_cmd_input(_rest); break;
            case "COLOR":     basic_cmd_color(_rest); break;

            case "CLS":
                if (global.current_mode >= 1) { basic_cmd_cls_mode1(); }
                else                           { basic_cmd_cls(); }
                break;

            // Structured control flow (multi-line)
            case "IF":        basic_cmd_if(_rest); break;
            case "ELSEIF":    basic_cmd_elseif(_rest); break;
            case "ELSE":      basic_cmd_else(); break;
            case "ENDIF":     basic_cmd_endif(); break;

            case "FOR":       basic_cmd_for(_rest); break;
            case "NEXT":      basic_cmd_next(_rest); break;
            case "WHILE":     basic_cmd_while(_rest); break;
            case "WEND":      basic_cmd_wend(); break;

            case "GOSUB":     basic_cmd_gosub(_rest); break;
            case "RETURN":    basic_cmd_return(); break;

            case "BGCOLOR":   basic_cmd_bgcolor(_rest); break;
            case "PAUSE":     basic_cmd_pause(); break;
            case "MODE":      basic_cmd_mode(_rest); break;
            case "CLSCHAR":   basic_cmd_clschar(_rest); break;
            case "PSET":      basic_cmd_pset(_rest); break;
            case "CHARAT":    basic_cmd_charat(_rest); break;
            case "PRINTAT":   basic_cmd_printat(_rest); break;
            case "FONT":      basic_cmd_font(_rest); break;
            case "DIM":       basic_cmd_dim(_rest); break; // 1-D arrays

            case "END":       basic_cmd_end(); break;

            case "REM":
                // no-op
                break;

            case "DATA":
                // Runtime no-op (DATA was harvested at load time)
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA (runtime): no-op");
                break;

            case "READ":      basic_cmd_read(_rest); break;
            case "RESTORE":   basic_cmd_restore(_rest); break;

            case "LOCATE":    basic_cmd_locate(_rest); break;
            case "SCROLL":    basic_cmd_scroll(_rest); break;

		case "POS":
		    // If it's being used as a variable assignment (e.g., "POS = 1"),
		    // treat it as an implicit LET. Otherwise it's a function token in expressions,
		    // so do nothing at command level.
		    if (string_pos("=", _rest) > 0) {
		        basic_cmd_let(_verb + " " + _rest);
		    }
		    break;

            case "SCREEN":    // handled as function in expressions
            case "POINT":     // handled as function in expressions
        //    case "POS":       // handled as function in expressions
            case "CSRLIN":    // handled as function in expressions
            case "TAB":       // handled in PRINT processing
            case "SPC":       // handled in PRINT processing
                break;

            case "FONTSET":   basic_cmd_fontset(_rest); break;

            default:
                // implicit LET?  e.g.  "X = 5"
                if (string_pos("=", _verb + " " + _rest) > 0) {
                    basic_cmd_let(_verb + " " + _rest);
                } else {
                    basic_syntax_error("Unknown command: " + _verb,
                        global.current_line_number,
                        global.interpreter_current_stmt_index,
                        "UNKNOWN_COMMAND");
                }
                break;
        }
    }
}

/// scripts/save_program/save_program.gml
/// Robust save: finds program lines from several common containers and writes them.
/// Logs exactly what was written (count + source), so we can confirm why a file went empty.

function save_program_as(filename)
{
    // --- Normalize filename
    filename = string_trim(filename);
    if (string_length(filename) == 0) { show_error_message("NO FILENAME PROVIDED"); return; }
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename)-2);
    }
    filename = string_replace_all(filename, "/", "_");
    filename = string_replace_all(filename, "\\", "_");
    filename = string_replace_all(filename, "..", "_");
    filename = string_replace_all(filename, ".bas", "");

    // --- Resolve save directory (desktop-first)
    var save_dir = get_save_directory();
    if (!is_string(save_dir) || string_length(save_dir) == 0) {
        save_dir = working_directory;
        var _last = string_copy(save_dir, string_length(save_dir), 1);
        if (_last != "/" && _last != "\\") save_dir += (os_type == os_windows) ? "\\" : "/";
       if (dbg_on(DBG_FLOW)) show_debug_message("FALLBACK save_dir -> '" + save_dir + "'");
    }
    if (os_type == os_windows || os_type == os_macosx || os_type == os_linux) {
        if (!directory_exists(save_dir)) directory_create(save_dir);
        if (!directory_exists(save_dir)) { show_error_message("COULD NOT CREATE SAVE FOLDER:\n" + string(save_dir)); return; }
    }

    var save_path = save_dir + filename + ".bas";
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE -> " + save_path);

    // --- Collect lines from likely sources
    var lines_list = ds_list_create(); // will hold strings to write, in order
    var source_used = "NONE";
    var ed = instance_find(obj_editor, 0);

    if (ed != noone) {
        // 1) obj_editor.program_lines (array)
        if (variable_instance_exists(ed, "program_lines") && is_array(ed.program_lines)) {
            for (var i = 0; i < array_length(ed.program_lines); i++) {
                ds_list_add(lines_list, string(ed.program_lines[i]));
            }
            if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (array)";
        }

        // 2) obj_editor.program_lines (ds_list)
        if (source_used == "NONE" && variable_instance_exists(ed, "program_lines") &&
            ds_exists(ed.program_lines, ds_type_list)) {
            var n = ds_list_size(ed.program_lines);
            for (var j = 0; j < n; j++) {
                ds_list_add(lines_list, string(ds_list_find_value(ed.program_lines, j)));
            }
            if (n > 0) source_used = "obj_editor.program_lines (ds_list)";
        }

/// >>> INSERT START: 2c) obj_editor.program_lines (ds_map) <<<
        if (source_used == "NONE" && variable_instance_exists(ed, "program_lines") &&
            ds_exists(ed.program_lines, ds_type_map)) {

            // Gather keys
            var epl_keys = ds_list_create();
            var epl_k = ds_map_find_first(ed.program_lines);
            while (epl_k != undefined) {
                ds_list_add(epl_keys, epl_k);
                epl_k = ds_map_find_next(ed.program_lines, epl_k);
            }

            // Sort numerically if keys are numbers
            var epl_numeric = true;
            for (var ei = 0; ei < ds_list_size(epl_keys); ei++) {
                if (!is_real(ds_list_find_value(epl_keys, ei))) { epl_numeric = false; break; }
            }
            if (epl_numeric) ds_list_sort(epl_keys, true); // ascending

            // Emit "lineNum content" in key order
            for (var ej = 0; ej < ds_list_size(epl_keys); ej++) {
                var _ln  = ds_list_find_value(epl_keys, ej);
                var _val = ds_map_find_value(ed.program_lines, _ln);
                ds_list_add(lines_list, string(_ln) + " " + string(_val));
            }

            if (ds_list_size(lines_list) > 0) {
                source_used = "obj_editor.program_lines (ds_map)";
                if (dbg_on(DBG_IO)) show_debug_message("SAVE: pulled " + string(ds_list_size(lines_list)) + " lines from obj_editor.program_lines (map)");
            }
            ds_list_destroy(epl_keys);
        }
        /// <<< INSERT END <<<




        // 3) Common ds_map containers keyed by line numbers (we’ll join "lineNum + space + content")
        if (source_used == "NONE") {
            var map_names = [
                "program_map", "program_lines_map", "basic_program",
                "lines_map", "line_store", "program"
            ];
            for (var m = 0; m < array_length(map_names); m++) {
                var nm = map_names[m];
                if (variable_instance_exists(ed, nm) && ds_exists(ed[? nm], ds_type_map)) {
                    // Gather keys
                    var keys = ds_list_create();
                    var k = ds_map_find_first(ed[? nm]);
                    while (k != undefined) {
                        ds_list_add(keys, k);
                        k = ds_map_find_next(ed[? nm], k);
                    }
                    // Sort numerically if keys look like numbers
                    // (GameMaker sorts as strings; so we’ll bubble minimal numeric ordering)
                    var numeric = true;
                    for (var t = 0; t < ds_list_size(keys); t++) {
                        if (!is_real(ds_list_find_value(keys, t))) { numeric = false; break; }
                    }
                    if (numeric) ds_list_sort(keys, true); // ascending

                    // Emit "lineNum content" in key order
                    for (var t2 = 0; t2 < ds_list_size(keys); t2++) {
                        var _ln = ds_list_find_value(keys, t2);
                        var val = ds_map_find_value(ed[? nm], _ln);
                        // if val already includes line number, this will double it; but that’s rare.
                        ds_list_add(lines_list, string(_ln) + " " + string(val));
                    }
                    if (ds_list_size(lines_list) > 0) {
                        source_used = "obj_editor." + nm + " (ds_map)";
                        ds_list_destroy(keys);
                        break;
                    }
                    ds_list_destroy(keys);
                }
            }
        }
    }

    // 4) Global fallbacks
    if (source_used == "NONE" && variable_global_exists("program_lines")) {
        if (is_array(global.program_lines)) {
            for (var g1 = 0; g1 < array_length(global.program_lines); g1++) {
                ds_list_add(lines_list, string(global.program_lines[g1]));
            }
            if (ds_list_size(lines_list) > 0) source_used = "global.program_lines (array)";
        } else if (ds_exists(global.program_lines, ds_type_list)) {
            var gn = ds_list_size(global.program_lines);
            for (var g2 = 0; g2 < gn; g2++) {
                ds_list_add(lines_list, string(ds_list_find_value(global.program_lines, g2)));
            }
            if (gn > 0) source_used = "global.program_lines (ds_list)";
        }
    }
	
	/// >>> INSERT START: support global.program_lines when it's a MAP <<<
    if (source_used == "NONE" && variable_global_exists("program_lines") && ds_exists(global.program_lines, ds_type_map)) {
        var gpl_keys = ds_list_create();
        var gpl_k = ds_map_find_first(global.program_lines);
        while (gpl_k != undefined) {
            ds_list_add(gpl_keys, gpl_k);
            gpl_k = ds_map_find_next(global.program_lines, gpl_k);
        }
        // numeric-sort keys if they’re numbers
        var gpl_numeric = true;
        for (var gpi = 0; gpi < ds_list_size(gpl_keys); gpi++) {
            if (!is_real(ds_list_find_value(gpl_keys, gpi))) { gpl_numeric = false; break; }
        }
        if (gpl_numeric) ds_list_sort(gpl_keys, true);

        for (var gpj = 0; gpj < ds_list_size(gpl_keys); gpj++) {
            var gln  = ds_list_find_value(gpl_keys, gpj); // line number
            var gval = ds_map_find_value(global.program_lines, gln); // code
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        if (ds_list_size(lines_list) > 0) {
            source_used = "global.program_lines (ds_map)";
            if (dbg_on(DBG_IO)) show_debug_message("SAVE: pulled " + string(ds_list_size(lines_list)) + " lines from global.program_lines (map)");
        }
        ds_list_destroy(gpl_keys);
    }
    /// <<< INSERT END <<<
	
    if (source_used == "NONE" && variable_global_exists("program_map") && ds_exists(global.program_map, ds_type_map)) {
        var gkeys = ds_list_create();
        var gk = ds_map_find_first(global.program_map);
        while (gk != undefined) { ds_list_add(gkeys, gk); gk = ds_map_find_next(global.program_map, gk); }
        var gnum = true;
        for (var gg = 0; gg < ds_list_size(gkeys); gg++) if (!is_real(ds_list_find_value(gkeys, gg))) { gnum = false; break; }
        if (gnum) ds_list_sort(gkeys, true);
        for (var gh = 0; gh < ds_list_size(gkeys); gh++) {
            var gln = ds_list_find_value(gkeys, gh);
            var gval = ds_map_find_value(global.program_map, gln);
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        if (ds_list_size(lines_list) > 0) source_used = "global.program_map (ds_map)";
        ds_list_destroy(gkeys);
    }

    // --- Diagnostics before writing
    var total = ds_list_size(lines_list);
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE SOURCE -> " + source_used + " | lines=" + string(total));
    if (total > 0) {
        // show first couple lines for verification
        var preview_max = min(3, total);
        for (var pv = 0; pv < preview_max; pv++) {
           if (dbg_on(DBG_FLOW)) show_debug_message("LINE[" + string(pv) + "] -> " + string(ds_list_find_value(lines_list, pv)));
        }
    }

    // --- Open file and write
    var fh = file_text_open_write(save_path);
    if (fh < 0) { show_error_message("COULD NOT OPEN FILE FOR WRITE:\n" + filename + ".bas"); ds_list_destroy(lines_list); return; }

    for (var w = 0; w < total; w++) {
        file_text_write_string(fh, string(ds_list_find_value(lines_list, w)));
        file_text_writeln(fh); // newline
    }
    file_text_close(fh);

    var exists_after = file_exists(save_path);
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE EXISTS AFTER -> " + string(exists_after));

    if (total == 0) {
        show_error_message("NOTHING TO SAVE — no program lines found");
    } else if (!exists_after) {
        show_error_message("SAVE REPORTED OK BUT FILE NOT FOUND:\n" + save_path);
    } else if (ed != noone && variable_instance_exists(ed, "status_message")) {
        ed.status_message = "FILE SAVED: " + filename + ".bas (" + string(total) + " lines)";
    }

    ds_list_destroy(lines_list);
}

/// @func build_data_streams()
/// @desc Pre-scan the loaded program for DATA statements and harvest values
///       into named streams: global.data_streams[stream_name] = { list, ptr }.
///       Default stream name is "" (empty). Named stream: DATA @name: v1, v2, ...
function build_data_streams() {
    // Ensure the container map exists; clear any prior contents safely
    // We rely on obj_globals to have created global.data_streams (a ds_map).
    // Here we only clear/recycle it between runs by destroying per-stream lists.
    if (!ds_exists(global.data_streams, ds_type_map)) {
        // Safety net (shouldn't happen if obj_globals set it up)
        global.data_streams = ds_map_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("DATA: safety-created global.data_streams (missing map)");
    }

    // Destroy any old lists then clear the map for a fresh build
    var _k = ds_map_find_first(global.data_streams);
    while (!is_undefined(_k)) {
        var _st = ds_map_find_value(global.data_streams, _k);
        if (is_struct(_st)) {
            if (ds_exists(_st.list, ds_type_list)) ds_list_destroy(_st.list);
        }
        _k = ds_map_find_next(global.data_streams, _k);
    }
    ds_map_clear(global.data_streams);

    var total_vals = 0, added_lines = 0;

    // Iterate by physical line order using your runtime copies
    // (run_program() already did ds_map_copy → basic_program and ds_list_copy → basic_line_numbers)
    for (var i = 0; i < ds_list_size(global.basic_line_numbers); i++) {
        var line_no = global.basic_line_numbers[| i];
        var raw     = ds_map_find_value(global.basic_program, line_no);
        if (is_undefined(raw)) continue;

        var parts = split_on_unquoted_colons(string_trim(raw));

        for (var p = 0; p < array_length(parts); p++) {
            // *** CHANGE: look at the raw colon slot first (before stripping remarks)
            var stmt_full = string_trim(parts[p]);
            if (stmt_full == "") continue;

            var sp0   = string_pos(" ", stmt_full);
            var verb0 = (sp0 > 0) ? string_upper(string_copy(stmt_full, 1, sp0 - 1)) : string_upper(stmt_full);

            // *** CHANGE: if this part is REM or starts with apostrophe, stop scanning the rest of THIS line
            if (verb0 == "REM" || string_char_at(stmt_full, 1) == "'") {
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA scan: REM/' stops line " + string(line_no) + " at part " + string(p));
                break; // stop processing parts[] for this physical line
            }

            // Now strip inline remarks (so code like: DATA 1,2 'comment keeps "DATA 1,2")
            var part_raw = strip_basic_remark(stmt_full);
            if (part_raw == "") continue;

            var sp   = string_pos(" ", part_raw);
            var verb = (sp > 0) ? string_upper(string_copy(part_raw, 1, sp - 1)) : string_upper(part_raw);
            var rest = (sp > 0) ? string_trim(string_copy(part_raw, sp + 1, string_length(part_raw))) : "";

            if (verb != "DATA") continue;

            // --- collapse the remainder of THIS physical line so ':' after @name doesn't split the DATA ---
            // *** CHANGE: also stop collapse if we hit a REM/' part later on the same line.
            var remainder = part_raw;
            for (var t = p + 1; t < array_length(parts); t++) {
                var tail_full = string_trim(parts[t]);
                if (tail_full == "") continue;

                var spT   = string_pos(" ", tail_full);
                var verbT = (spT > 0) ? string_upper(string_copy(tail_full, 1, spT - 1)) : string_upper(tail_full);

                // *** CHANGE: if a later colon slot is a whole-line comment, stop collapse here
                if (verbT == "REM" || string_char_at(tail_full, 1) == "'") {
                    if (dbg_on(DBG_FLOW)) show_debug_message("DATA collapse: hit REM/' at part " + string(t) + " on line " + string(line_no));
                    break;
                }

                var tail = strip_basic_remark(tail_full);
                if (tail != "") remainder += ":" + tail;
            }
            if (dbg_on(DBG_FLOW) && remainder != part_raw) show_debug_message("DATA: collapsed line parts → '" + remainder + "'");

            // Recompute 'rest' from the collapsed DATA statement
            var sp2  = string_pos(" ", remainder);
            rest     = (sp2 > 0) ? string_trim(string_copy(remainder, sp2 + 1, string_length(remainder))) : "";
            added_lines++;

            var stream_name = "";     // default stream
            var values_text = rest;   // may be rewritten if @name: is present

            // Optional named stream: DATA @name: v1, v2, ...
            if (string_length(rest) > 0 && string_char_at(rest, 1) == "@") {
                var _depth = 0, inq = false, cut = 0, L = string_length(rest);
                for (var j = 1; j <= L; j++) {
                    var ch = string_char_at(rest, j);
                    if (ch == "\"") {
                        var nxt = (j < L) ? string_char_at(rest, j + 1) : "";
                        if (inq && nxt == "\"") { j++; continue; }
                        inq = !inq; continue;
                    }
                    if (inq) continue;
                    if (ch == "(") { _depth++; continue; }
                    if (ch == ")") { _depth = max(0, _depth - 1); continue; }
                    if (ch == ":" && _depth == 0) { cut = j; break; }
                }
                if (cut == 0) {
                   if (dbg_on(DBG_FLOW)) show_debug_message("?DATA ERROR: expected ':' after @name — line " + string(line_no) + " text: '" + part_raw + "'");
                    continue;
                }
                stream_name = string_trim(string_copy(rest, 2, cut - 2)); // exclude '@'
                values_text = string_trim(string_copy(rest, cut + 1, L - cut));
            }

            var vals = split_on_unquoted_commas(values_text);

            if (!ds_map_exists(global.data_streams, stream_name)) {
                var stream = { list: ds_list_create(), ptr: 0 };
                ds_map_add(global.data_streams, stream_name, stream);
            }
            var sref = ds_map_find_value(global.data_streams, stream_name);

            for (var vi = 0; vi < array_length(vals); vi++) {
                var token = vals[vi];
                var v = parse_data_value(token);
                ds_list_add(sref.list, v);
                total_vals++;
                if (dbg_on(DBG_FLOW)) show_debug_message(
                    "DATA: +" + (is_string(v) ? ("\"" + string(v) + "\"") : string(v)) +
                    " -> stream='" + stream_name + "' (line " + string(line_no) + ")"
                );
            }

            // we consumed the collapsed remainder of this physical line for this DATA
            break;
        }
    }

    if (dbg_on(DBG_FLOW)) {
        var summary = "DATA SUMMARY — streams: ";
        var k2 = ds_map_find_first(global.data_streams);
        while (!is_undefined(k2)) {
            var st2 = ds_map_find_value(global.data_streams, k2);
            var cnt = ds_list_size(st2.list);
            summary += "'" + string(k2) + "'=" + string(cnt) + "  ";
            k2 = ds_map_find_next(global.data_streams, k2);
        }
       if (dbg_on(DBG_FLOW)) show_debug_message(summary + "| values=" + string(total_vals) + " | data_lines=" + string(added_lines));
    }

    // TEMP: verify default stream size
    if (ds_map_exists(global.data_streams, "")) {
        var _def = ds_map_find_value(global.data_streams, "");
       if (dbg_on(DBG_FLOW)) show_debug_message("DATA DEFAULT SIZE = " + string(ds_list_size(_def.list)));
    }
}

// === BEGIN: basic_cmd_print ===
function basic_cmd_print(arg, line_number) {

    if (!ds_exists(global.output_lines, ds_type_list))  global.output_lines  = ds_list_create();
    if (!ds_exists(global.output_colors, ds_type_list)) global.output_colors = ds_list_create();

    var suppress_newline = false;
    var tabw = max(1, is_undefined(global.print_zone) ? 14 : global.print_zone);
    var line_accum = "";
    var col = 0;

    // Trailing semicolon → no newline
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Trailing semicolon detected; suppressing newline");
    }

    arg = string_trim(arg);

    // 1) Split by unquoted semicolons (these do NOT tab)
    var semi_parts = split_on_unquoted_semicolons(arg);

    // 2) Flatten, preserving WHICH separator preceded each part
    //    sep[i] ∈ { "START", "SEMI", "COMMA" }
    var parts = [];
    var seps  = [];

    var have_any = false;
    for (var si = 0; si < array_length(semi_parts); si++) {
        var seg = string_trim(semi_parts[si]);
        if (seg == "") {
            // if there are consecutive semicolons, they just concatenate nothing
            continue;
        }

        var comma_parts = split_on_unquoted_commas(seg);
        if (array_length(comma_parts) <= 1) {
            parts[array_length(parts)] = seg;
            seps[array_length(seps)]   = (have_any ? "SEMI" : "START");
            have_any = true;
        } else {
            for (var cj = 0; cj < array_length(comma_parts); cj++) {
                var p = string_trim(comma_parts[cj]);
                if (p == "") continue;
                parts[array_length(parts)] = p;
                var sep_kind = "START";
                if (have_any) {
                    // first item of this segment is after a semicolon; others after commas
                    sep_kind = (cj == 0) ? "SEMI" : "COMMA";
                }
                seps[array_length(seps)] = sep_kind;
                have_any = true;
            }
        }
    }

    // Column-aware appender with "\t" expansion (inline, no local functions)
    var _append_string = 0; // dummy to allow block reuse via comments

    // 3) Evaluate/emit each part with separator behavior
    for (var i = 0; i < array_length(parts); i++) {

        // --- Insert padding if previous separator was a COMMA (tab to next zone)
		if (seps[i] == "COMMA") {
		    var pad_comm;
		    if (global.print_tab_mode == 1) {
		        // Fixed-width tab (equal every time)
		        pad_comm = tabw;
		    } else {
		        // Zone tab (classic BASIC)
		        var next_zone = ((col div tabw) + 1) * tabw;
		        pad_comm = max(1, next_zone - col);
		    }
		    line_accum += string_repeat(" ", pad_comm);
		    col += pad_comm;
		}

        // "SEMI" and "START" add nothing (plain concatenation)

        var part = parts[i];
        var treat_as_literal = false;

        if (is_quoted_string(part)) {
            var inner = string_copy(part, 2, string_length(part) - 2);
            if (!string_pos("+", inner) && !string_pos("-", inner) && !string_pos("*", inner) && !string_pos("/", inner)) {
                treat_as_literal = true;
            }
        }

        var text_piece = "";

        if (treat_as_literal) {
            text_piece = string_copy(part, 2, string_length(part) - 2);
            text_piece = string_replace_all(text_piece, "\"\"", "\""); // "" → "
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " literal → " + text_piece);
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " expr → " + part);
            var tokens  = basic_tokenize_expression_v2(part);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Tokens = " + string(tokens));
            var postfix = infix_to_postfix(tokens);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Postfix = " + string(postfix));
            var result  = evaluate_postfix(postfix);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Evaluated result = " + string(result));

            // INKEY$ modal sentinel — defer PRINT until resume
            if (is_string(result) && result == "<<INKEY_WAIT>>") {
                if (is_undefined(global.inkey_waiting))  global.inkey_waiting  = false;
                if (is_undefined(global.inkey_captured)) global.inkey_captured = "";
                global.inkey_waiting   = true;
                global.inkey_captured  = "";
                global.pause_in_effect = true;
                global.awaiting_input  = false;
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY_WAIT: Deferring PRINT until a key is captured.");
                return;
            }

            if (is_real(result)) {
                if (array_length(parts) > 1) {
                    text_piece = string(result); // compact for multi-arg print
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (compact) → '" + text_piece + "'");
                } else {
                    if (frac(result) == 0) text_piece = string(round(result));
                    else                   text_piece = string_format(result, 12, 8);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (padded) → '" + text_piece + "'");
                }
            } else {
                text_piece = string(result);
            }
        }

        // Treat CHR$(9) as a tab (optional, harmless)
        if (text_piece == chr(9)) text_piece = "\t";

        // Append with "\t" expansion and column tracking
        var s = string(text_piece);
        for (var k = 1; k <= string_length(s); k++) {
            var ch = string_char_at(s, k);
			if (ch == "\t") {
			    var pad = (global.print_tab_mode == 1)
			        ? tabw
			        : max(1, (((col div tabw) + 1) * tabw) - col);
			    line_accum += string_repeat(" ", pad);
			    col += pad;
			} else {
                line_accum += ch;
                col += 1;
            }
        }
    }

    // 4) Wrap + commit using your existing buffer
    var wrap_width = 40;
    var full_line  = global.print_line_buffer + line_accum;

    while (string_length(full_line) > wrap_width) {
        var line = string_copy(full_line, 1, wrap_width);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, global.current_draw_color);
        full_line = string_copy(full_line, wrap_width + 1, string_length(full_line) - wrap_width);
    }

    global.print_line_buffer = full_line;

    if (!suppress_newline) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Line committed → " + global.print_line_buffer);
        global.print_line_buffer = "";
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Output buffered without newline → " + global.print_line_buffer);
    }
}
// === END: basic_cmd_print ===

/// @event obj_editor/Draw
// Pause regular editor drawing when screen editor is active
if (global.screen_edit_mode) {
    //if (dbg_on(DBG_FLOW)) show_debug_message("EDITOR: Screen edit mode active, pausing regular editor draw");
    exit;
}


// Set font and calculate actual height
draw_set_font(fnt_basic);
var actual_font_height = string_height("A"); // Get real font height
draw_set_color(make_color_rgb(255, 191, 64));
draw_rectangle_color(0, 0, room_width, room_height, c_black, c_black, c_black, c_black, false);

if (showing_dir_overlay) {
    // Modal backdrop
    draw_set_color(c_black);
    draw_rectangle(0, 0, room_width, room_height, false);

	draw_set_font(fnt_basic_12); // smaller font for directory overlay
	draw_set_color(c_lime);


    var x_pad = 16;
    var y_pad = 16;

	// Split header across two lines for readability
	var header1 = "DIR: " + dir_save_dir;
	var header2 = "Files: " + string(array_length(dir_listing))
	    + " | Sel: " + string(dir_sel + 1) + "/" + string(max(1, array_length(dir_listing)))
	    + " | Keys: Arrows Move  Enter=>Load  D/X=>Delete  ESC Close";

	draw_text(x_pad, y_pad, header1);
	draw_text(x_pad, y_pad + string_height("A"), header2);


    // Compute rows/page (ASCII)
    var row_h       = string_height("A");
    var top_y       = y_pad + row_h * 3;
    var bottom_y    = room_height - y_pad - row_h * 2;
    var list_height = max(row_h, bottom_y - top_y);
    var rows_per_pg = max(1, floor(list_height / row_h));
    dir_page_size   = rows_per_pg; // expose for Step input

    // Clamp selection and compute page from sel
    var total = array_length(dir_listing);
    dir_sel = clamp(dir_sel, 0, max(0, total - 1));
    var first_index = (dir_sel div rows_per_pg) * rows_per_pg;
    var last_index  = min(total - 1, first_index + rows_per_pg - 1);

    // Borders (ASCII box)
    var left_x  = x_pad;
    var right_x = room_width - x_pad;
    // top border
    draw_text(left_x, top_y - row_h, "+-------------------------------------------+");
    // list rows
    var draw_y = top_y;
    for (var i = first_index; i <= last_index; i++) {
        var idx3 = string_format(string(i + 1), 3, 0); // 001, 002...
        var name = dir_listing[i];

        // Assemble row: index, filename (trim), actions
        var action_txt = "   >  X";
        var max_name_px = (right_x - left_x) - string_width(idx3 + " ") - string_width(action_txt) - 24;
        var name_trim = name;

        // crude pixel trimming to fit line
        while (string_width(name_trim) > max_name_px && string_length(name_trim) > 3) {
            name_trim = string_copy(name_trim, 1, string_length(name_trim) - 1);
        }
        if (name_trim != name) name_trim += "...";

        var row_text = idx3 + " " + name_trim;

        // Selected row highlight (inverse via black rect + lime text)
        if (i == dir_sel) {
            draw_set_color(c_dkgray);
            draw_rectangle(left_x - 6, draw_y - 2, right_x - 6, draw_y + row_h, false);
            draw_set_color(c_lime);
        }

        draw_text(left_x, draw_y, row_text);
        // draw actions at right
        var act_x = right_x - string_width(">  X") - 16;
        draw_text(act_x, draw_y, ">  X");

        draw_y += row_h;
    }
    // bottom border
    draw_text(left_x, draw_y, "+-------------------------------------------+");

    // Paging markers
    if (first_index > 0)      draw_text(right_x - 40, top_y - row_h, "^");
    if (last_index < total-1) draw_text(right_x - 40, draw_y, "v");

    // Confirm dialog (modal)
    if (dir_confirm_active) {
        var cx = room_width  div 2;
        var cy = room_height div 2;
        var w  = 520;
        var h  = row_h * 4;
        var l  = cx - w div 2;
        var t  = cy - h div 2;
        var r  = cx + w div 2;
        var b  = cy + h div 2;

        draw_set_color(c_black);
        draw_rectangle(l, t, r, b, false);
        draw_set_color(c_lime);

        var _nm = (dir_confirm_index >= 0 && dir_confirm_index < total) ? dir_listing[dir_confirm_index] : "";
        draw_text(l + 12, t + row_h, "Delete \"" + _nm + "\" ?");
        draw_text(l + 12, t + row_h * 2, "[Y]es  [N]o");

        // Note: modal—input handled in Step; draw only here
    }

    // Short help/footer
    draw_set_color(c_dkgray);
    draw_text(x_pad, room_height - row_h - y_pad, "(ASCII dir) Load: Enter/>   Delete: D/X (Desktop only)   Close: ESC");

    return; // overlay draws above everything
}


// Draw program lines with proper spacing
var y_pos = 32;
var lines_shown = 0;
var total_lines = ds_list_size(global.line_numbers);

// Calculate how many lines fit on screen
var available_height = room_height - 128; // Leave space for prompt and messages
var max_lines = floor(available_height / actual_font_height);

for (var i = display_start_line; i < total_lines && lines_shown < max_lines; i++) {
    var line_num = ds_list_find_value(global.line_numbers, i);
    var code = ds_map_find_value(global.program_lines, line_num);
    var display_text = string(line_num) + " " + code;
    
    draw_text(16, y_pos, display_text);
    y_pos += actual_font_height; // Use actual font height
    lines_shown++;
}

// Draw input prompt with proper spacing
draw_text(16, room_height - (actual_font_height * 2), "READY");
draw_text(16, room_height - actual_font_height, "> " + current_input);

// Draw cursor
var cursor_x = 16 + string_width("> " + string_copy(current_input, 1, cursor_pos));
if (current_time % 1000 < 500) { // Blinking cursor
    draw_text(cursor_x, room_height - actual_font_height, "_");
}

// Draw message with proper spacing
if (message_text != "") {
    draw_set_color(c_yellow);
    draw_text(16, room_height - (actual_font_height * 3), message_text);
    draw_set_color(make_color_rgb(255, 191, 64)); // Reset color
}
#define browser_file_tools_init
global.__browser_file_tools_paste_handler = -1;
global.__browser_file_tools_paste_filter = -1;
global.__browser_file_tools_drop_handler = -1;
global.__browser_file_tools_drop_filter = -1;
global.__browser_file_tools_open_handler = -1;
global.__browser_file_tools_open_filter = -1;

#define browser_file_tools_callback_get_name
var _script = argument0;
if (_script != undefined && script_exists(_script)) {
	var _name = script_get_name(_script);
	if (string_pos("gmcallback_", _name) != 1) {
		show_error("Callback script names must start with `gmcallback_` in GMS1", 1);
		return undefined;
	}
	return _name;
} else return undefined;

#define browser_file_tools_callback_is_valid
var _func = argument0;
if (_func == undefined) return false;
// GMS >= 2.3:
if (is_method(_func)) return true;
//*/
return script_exists(_func);

#define browser_file_tools_callback_invoke3
// GMS >= 2.3:
if (is_method(argument0)) {
	var _func = argument0;
	return _func(argument1, argument2, argument3);
}
//*/
return script_execute(argument0, argument1, argument2, argument3);

#define browser_file_tools_cb_invoke
var _script = argument0;

#define gmcallback_browser_file_tools_paste_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_paste_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_paste_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_paste_filter, _data, _name, _type);

#define browser_paste_bind
/// (?handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _handler = argument_count > 0 ? argument[0] : undefined;
var _filter = argument_count > 1 ? argument[1] : undefined;
// GMS >= 2:
global.__browser_file_tools_paste_handler = _handler;
global.__browser_file_tools_paste_filter = _filter;
return browser_paste_bind_raw(
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_paste_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_paste_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_paste_bind_raw(
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define gmcallback_browser_file_tools_drop_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_drop_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_drop_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_drop_filter, _data, _name, _type);

#define browser_drop_bind
/// (?handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _handler = argument_count > 0 ? argument[0] : undefined;
var _filter = argument_count > 1 ? argument[1] : undefined;
// GMS >= 2:
global.__browser_file_tools_drop_handler = _handler;
global.__browser_file_tools_drop_filter = _filter;
return browser_drop_bind_raw(
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_drop_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_drop_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_drop_bind_raw(
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define gmcallback_browser_file_tools_open_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_open_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_open_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_open_filter, _data, _name, _type);

#define browser_show_open_dialog
/// (accept:string, multiselect:bool, handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _accept = argument[0], _multiselect = argument[1], _handler = argument[2];
var _filter = argument_count > 3 ? argument[3] : undefined;
// GML >= 2:
global.__browser_file_tools_open_handler = _handler;
global.__browser_file_tools_open_filter = _filter;
return browser_show_open_dialog_raw(_accept, _multiselect,
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_open_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_open_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_show_open_dialog_raw(_accept,
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define browser_show_save_dialog
/// (buffer, name, ?type, ?size)
var _buffer = argument[0], _name = argument[1];
var _type = argument_count > 2 ? argument[2] : undefined;
var _size = argument_count > 3 ? argument[3] : buffer_get_size(_buffer);
if (_type == undefined) _type = "application/octet-stream";
return browser_show_save_dialog_raw(buffer_get_address(_buffer), _name, _type, _size);
/// @function editor_html_build_program_text
/// @desc Serialize the current BASIC program into canonical lines: "<line> <code>\r\n"
///       Uses the same sources your desktop save_program_as() already prefers.
/// @returns {string}
function editor_html_build_program_text() {
    var lines_list = ds_list_create(); // ordered strings to emit
    var source_used = "NONE";
    var ed = instance_find(obj_editor, 0);

    // === Try obj_editor.program_lines (array) ===
    if (ed != noone && variable_instance_exists(ed, "program_lines") && is_array(ed.program_lines)) {
        for (var i = 0; i < array_length(ed.program_lines); i++) {
            ds_list_add(lines_list, string(ed.program_lines[i]));
        }
        if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (array)";
    }

    // === Try obj_editor.program_lines (ds_list) ===
    if (source_used == "NONE" && ed != noone && variable_instance_exists(ed, "program_lines") &&
        ds_exists(ed.program_lines, ds_type_list)) {
        var n = ds_list_size(ed.program_lines);
        for (var j = 0; j < n; j++) {
            ds_list_add(lines_list, string(ds_list_find_value(ed.program_lines, j)));
        }
        if (n > 0) source_used = "obj_editor.program_lines (ds_list)";
    }

    // === Try obj_editor.program_lines (ds_map keyed by line numbers) ===
    if (source_used == "NONE" && ed != noone && variable_instance_exists(ed, "program_lines") &&
        ds_exists(ed.program_lines, ds_type_map)) {

        var epl_keys = ds_list_create();
        var e_k = ds_map_find_first(ed.program_lines);
        while (e_k != undefined) { ds_list_add(epl_keys, e_k); e_k = ds_map_find_next(ed.program_lines, e_k); }

        var epl_numeric = true;
        for (var ei = 0; ei < ds_list_size(epl_keys); ei++) {
            if (!is_real(ds_list_find_value(epl_keys, ei))) { epl_numeric = false; break; }
        }
        if (epl_numeric) ds_list_sort(epl_keys, true);

        for (var ej = 0; ej < ds_list_size(epl_keys); ej++) {
            var _ln  = ds_list_find_value(epl_keys, ej);
            var _val = ds_map_find_value(ed.program_lines, _ln);
            ds_list_add(lines_list, string(_ln) + " " + string(_val));
        }
        if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (ds_map)";

        ds_list_destroy(epl_keys);
    }

    // === Try common ds_map containers keyed by line numbers ===
    if (source_used == "NONE") {
        var map_names = [
            "program_map", "program_lines_map", "basic_program",
            "lines_map", "line_store", "program"
        ];
        for (var mi = 0; mi < array_length(map_names); mi++) {
            var mn = map_names[mi];
            if (variable_instance_exists(ed, mn) && ds_exists(ed[? mn], ds_type_map)) {
                var keys = ds_list_create();
                var k = ds_map_find_first(ed[? mn]);
                while (k != undefined) { ds_list_add(keys, k); k = ds_map_find_next(ed[? mn], k); }
                var numeric = true;
                for (var ki = 0; ki < ds_list_size(keys); ki++) {
                    if (!is_real(ds_list_find_value(keys, ki))) { numeric = false; break; }
                }
                if (numeric) ds_list_sort(keys, true);
                for (var kj = 0; kj < ds_list_size(keys); kj++) {
                    var _ln  = ds_list_find_value(keys, kj);
                    var val = ds_map_find_value(ed[? mn], _ln);
                    ds_list_add(lines_list, string(_ln) + " " + string(val));
                }
                ds_list_destroy(keys);
                if (ds_list_size(lines_list) > 0) { source_used = "obj_editor." + mn; break; }
            }
        }
    }

    // === Try global.program_lines (ds_map keyed by line numbers) ===
    if (source_used == "NONE" && variable_global_exists("program_lines") && ds_exists(global.program_lines, ds_type_map)) {
        var gpl_keys = ds_list_create();
        var gpl_k = ds_map_find_first(global.program_lines);
        while (gpl_k != undefined) { ds_list_add(gpl_keys, gpl_k); gpl_k = ds_map_find_next(global.program_lines, gpl_k); }
        var gpl_numeric = true;
        for (var gpi = 0; gpi < ds_list_size(gpl_keys); gpi++) {
            if (!is_real(ds_list_find_value(gpl_keys, gpi))) { gpl_numeric = false; break; }
        }
        if (gpl_numeric) ds_list_sort(gpl_keys, true);
        for (var gpj = 0; gpj < ds_list_size(gpl_keys); gpj++) {
            var gln  = ds_list_find_value(gpl_keys, gpj);
            var gval = ds_map_find_value(global.program_lines, gln);
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        ds_list_destroy(gpl_keys);
        if (ds_list_size(lines_list) > 0) source_used = "global.program_lines (ds_map)";
    }

    // --- Emit CRLF text
    var out = "";
    var total = ds_list_size(lines_list);
    for (var ii = 0; ii < total; ii++) {
        out += string(ds_list_find_value(lines_list, ii)) + "\r\n";
    }
    ds_list_destroy(lines_list);
    return out; // empty if nothing found
}

/// @script basic_cmd_if_inline
/// @description Single-line IF…THEN…ELSE. Executes THEN/ELSE here and tells Step which colon slot to resume at.
function basic_cmd_if_inline(arg) {
    // 1) Normalize and strip inline remarks first
    var s = string_trim(arg);
    s = strip_basic_remark(s);
    var s_upper = string_upper(s);

    // 2) Quote-safe, word-boundary keyword find
    var find_kw = function(_src, _up, _kw) {
        var L = string_length(_src), K = string_length(_kw), inq = false;
        for (var i = 1; i <= L - K + 1; i++) {
            var ch = string_char_at(_src, i);
            if (ch == "\"") { inq = !inq; continue; }
            if (inq) continue;

            if (string_copy(_up, i, K) == _kw) {
                var prev = (i == 1) ? " " : string_char_at(_up, i - 1);
                var next = (i + K <= L) ? string_char_at(_up, i + K) : " ";
                if ((prev == " " || prev == ":") && (next == " " || next == ":" || i + K - 1 == L)) {
                    return i;
                }
            }
        }
        return 0;
    };

    // 3) Require THEN
    var then_pos = find_kw(s, s_upper, "THEN");
		if (then_pos <= 0) {
		    basic_syntax_error("IF requires THEN", 
			basic_current_line_no(), 
			global.interpreter_current_stmt_index,
			"IF MISSING THEN");
		    return;
		}
    var else_pos = find_kw(s, s_upper, "ELSE");

    // 4) Slice parts
    var condition = string_trim(string_copy(s, 1, then_pos - 1));
    var then_action, else_action;
    if (else_pos > then_pos) {
        then_action = string_trim(string_copy(s, then_pos + 4, else_pos - (then_pos + 4)));
        else_action = string_trim(string_copy(s, else_pos + 4, string_length(s) - (else_pos + 3)));
    } else {
        then_action = string_trim(string_copy(s, then_pos + 4, string_length(s) - (then_pos + 3)));
        else_action = "";
    }

    // 5) Evaluate condition
    var cond = basic_evaluate_condition(condition);

    // 6) Split branches into colon segments
    var run_parts = cond ? (then_action != "" ? split_on_unquoted_colons(then_action) : []) 
                         : (else_action != "" ? split_on_unquoted_colons(else_action) : []);

    var p        = global.interpreter_current_stmt_index;
    var line_idx = global.interpreter_current_line_index;

    // 7) Runner: executes a single colon-segment with implicit-LET promotion
    var run_seg = function(seg) {
        seg = strip_basic_remark(string_trim(seg));
        if (seg == "") return;

        var sp = string_pos(" ", seg);
        var head = (sp > 0) ? string_upper(string_copy(seg, 1, sp - 1)) : string_upper(seg);

        var is_cmd =
              (head == "PRINT")   || (head == "LET")     || (head == "INPUT")   || (head == "CLS")
           || (head == "COLOR")   || (head == "BGCOLOR") || (head == "IF")      || (head == "FOR")
           || (head == "NEXT")    || (head == "WHILE")   || (head == "WEND")    || (head == "GOTO")
           || (head == "GOSUB")   || (head == "RETURN")  || (head == "DIM")     || (head == "END")
           || (head == "MODE")    || (head == "PSET")    || (head == "CHARAT")  || (head == "PRINTAT")
           || (head == "FONT")    || (head == "CLSCHAR") || (head == "PAUSE")
           || (head == "READ")    || (head == "RESTORE") || (head == "DATA")    || (head == "INKEY$");

        if (!is_cmd) {
            var d = 0, eq = 0, L = string_length(seg);
            for (var i = 1; i <= L; i++) {
                var ch = string_char_at(seg, i);
                if (ch == "(") d++;
                else if (ch == ")") d = max(0, d - 1);
                else if (ch == "=" && d == 0) { eq = i; break; }
            }
            if (eq > 0) seg = "LET " + seg;
        }

        var sp2 = string_pos(" ", seg);
        var cmd = (sp2 > 0) ? string_upper(string_copy(seg, 1, sp2 - 1)) : string_upper(seg);
        var arg = (sp2 > 0) ? string_trim(string_copy(seg, sp2 + 1, string_length(seg))) : "";

        if (cmd == "GOTO") {
            var line_target = real(arg);
            var idx = ds_list_find_index(global.line_list, line_target);
            if (idx >= 0) {
                global.interpreter_next_line = idx;
            } else {
                basic_syntax_error("GOTO target not found: " + string(line_target), 
				global.current_line_number, 
				p,
				"TARGET NOT FOUND");
            }
        } else {
            handle_basic_command(cmd, arg);
        }
    };

    // 8) Execute chosen branch (if any)
    for (var k = 0; k < array_length(run_parts); k++) {
        run_seg(run_parts[k]);
        if (global.program_has_ended || !global.interpreter_running) return; // error halted
    }

    // 9) Tell Step to resume after this IF colon-slot
    global.interpreter_use_stmt_jump = true;
    global.interpreter_target_line   = line_idx;
    global.interpreter_target_stmt   = p + 1;
}

function basic_cmd_while(arg) {
    // Keep your original behavior & logging
    var condition = string_upper(string_trim(arg));
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Raw condition string: '" + condition + "'");

    var value = basic_evaluate_condition(condition);
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Evaluated result of '" + condition + "' → " + string(value));

    // ---- Lazy-init tiny metadata store for WHILE frames (no global file edits required)
    if (!variable_global_exists("while_meta") || !ds_exists(global.while_meta, ds_type_map)) {
        global.while_meta = ds_map_create();
    }

    if (!value) {
        // === FIX 1: robust skip ahead that inspects colon-separated statements, not only first token ===
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Condition is FALSE — skipping ahead to matching WEND");
        var _depth = 1;

        var li_max = ds_list_size(global.line_list);
        var li     = global.interpreter_current_line_index;         // current physical line index
        var stmt   = global.interpreter_current_stmt_index + 1;     // start after the WHILE header

        while (li < li_max) {
            var _ln   = ds_list_find_value(global.line_list, li);
            var code  = ds_map_find_value(global.program_map, _ln);
            var parts = split_on_unquoted_colons(string_trim(code));

            for (var p = stmt; p < array_length(parts); p++) {
                var raw  = string_trim(parts[p]);
                if (raw == "") continue;

                raw = strip_basic_remark(raw);
                var sp  = string_pos(" ", raw);
                var cmd = (sp > 0) ? string_upper(string_copy(raw, 1, sp - 1)) : string_upper(raw);

                if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: scan line " + string(_ln) + " part " + string(p) + " → " + cmd);

                if (cmd == "WHILE") {
                    _depth += 1; // nested while inside the false body we’re skipping
                } else if (cmd == "WEND") {
                    _depth -= 1;
                    if (_depth == 0) {
                        if (dbg_on(DBG_FLOW)) show_debug_message(
                            "WHILE: Found matching WEND at line index " + string(li) + ", line " + string(_ln) + ", part " + string(p)
                        );
                        // Land just AFTER this WEND colon slot
                        global.interpreter_use_stmt_jump = true;
                        global.interpreter_target_line   = li;
                        global.interpreter_target_stmt   = p + 1;
                        global.interpreter_next_line     = -1;
                        return;
                    }
                }
            }

            li   += 1;
            stmt  = 0; // from next physical line, start at first colon slot
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("?WHILE ERROR: No matching WEND found — control flow may break");
        return;
    }

    // === Condition TRUE → record minimal metadata and push loop frame as you already do ===
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Condition is TRUE — evaluating stack push logic");

    // Ensure stack exists
    if (!ds_exists(global.while_stack, ds_type_stack)) {
        global.while_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Created new while_stack");
    }

    // Only push if not already at top (preserve your logic)
    if (ds_stack_empty(global.while_stack) || ds_stack_top(global.while_stack) != line_index) {
        ds_stack_push(global.while_stack, line_index);
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Pushed line_index " + string(line_index) + " onto while_stack");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Stack already contains this line_index at top — skipping push");
    }

    // Save exact condition and the colon slot to resume the loop body after WHILE’s header
    var key = string(line_index); // key by the WHILE's physical line index
    var meta = ds_map_create();
    meta[? "cond_str"]   = string_trim(arg); // store as written on the line (not uppercased)
    meta[? "stmt_after"] = global.interpreter_current_stmt_index + 1;
    ds_map_replace(global.while_meta, key, meta);

    // Continue normally
    global.interpreter_next_line = -1;
}

/// @script basic_cmd_elseif
/// @description Handle an ELSEIF in a block‐structured IF…THEN…ELSEIF…ELSE…ENDIF chain
function basic_cmd_elseif(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF START — Raw arg: '" + arg + "'");
    
    // ── GUARD 1: Must have an open IF on the stack ──
    if (ds_stack_empty(global.if_stack)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: ELSEIF without matching IF");
        return;
    }
    
    // 1) Where are we in the program?
    var current_index = global.interpreter_current_line_index;
    
    // 2) Peek the top IF‐frame
    var frame = ds_stack_top(global.if_stack);
    
    // ── GUARD 2: Must have block metadata for this IF ──
    if (!ds_map_exists(global.if_block_map, frame[? "startIndex"])) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: No IF‐block metadata (bad nesting?)");
        return;
    }
    
    var taken       = frame[? "takenBranch"];
    var elseif_list = frame[? "elseifIndices"]; // ds_list of all ELSEIF positions
    var else_index  = frame[? "elseIndex"];
    var endif_index = frame[? "endifIndex"];
    
    // 3) Find which ELSEIF this is
    var pos = ds_list_find_index(elseif_list, current_index);
    if (pos < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: Unexpected ELSEIF at index " + string(current_index));
        return;
    }
    
    // 4) If we’ve already taken a branch, skip straight through
    if (taken) {
        // decide next jump: next ELSEIF, or ELSE, or ENDIF
        var next_index = -1;
        if (pos < ds_list_size(elseif_list) - 1) {
            next_index = elseif_list[| pos + 1];
        } else if (else_index >= 0) {
            next_index = else_index;
        } else {
            next_index = endif_index;
        }
        global.interpreter_next_line = next_index;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF skipping to index " + string(next_index));
        return;
    }
    
    // 5) Parse and evaluate this ELSEIF’s condition
    var raw      = string_trim(arg);
    var upperRaw = string_upper(raw);
    var then_pos = string_pos("THEN", upperRaw);
    if (then_pos <= 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var cond_text = string_trim(string_copy(raw, 1, then_pos - 1));
    if (dbg_on(DBG_FLOW))  show_debug_message("Parsed ELSEIF condition: '" + cond_text + "'");
    
    // Reuse your AND/OR logic from basic_cmd_if
    var result = false;
    var logic_op = "";
    var upcond   = string_upper(cond_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";
    if (logic_op != "") {
        var parts = string_split(cond_text, logic_op);
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        if (dbg_on(DBG_FLOW))  show_debug_message("Combined ELSEIF (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(cond_text);
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF single condition result: " + string(result));
    }
    
    // 6) If it’s true, mark the frame as “taken” and fall into this block…
    if (result) {
        frame[? "takenBranch"] = true;
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF TRUE: entering branch at index " + string(global.interpreter_next_line));
    } else {
        // …otherwise skip to the next ELSEIF/ELSE/ENDIF
        var next_index = (pos < ds_list_size(elseif_list) - 1)
                         ? elseif_list[| pos + 1]
                         : (else_index >= 0 ? else_index : endif_index);
        global.interpreter_next_line = next_index;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF FALSE: skipping to index " + string(next_index));
    }
}

function basic_validate_program() {
    // Ensure structures exist
    if (!ds_exists(global.program_map, ds_type_map) || !ds_exists(global.line_list, ds_type_list)) return true;

    // Helpers local to validator
    var _top_level_eq_pos = function(s) {
        var L = string_length(s), _depth = 0, inq = false;
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { inq = !inq; continue; }
            if (inq) continue;
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { if (_depth > 0) _depth--; continue; }
            if (ch == "=" && _depth == 0) return i;
        }
        return 0;
    };
    
    var _is_letter = function(ch) {
        if (string_length(ch) < 1) return false;
        var c = ord(string_upper(ch));
        return (c >= 65 && c <= 90);
    };
    
    var _is_valid_lhs = function(lhs) {
        lhs = string_trim(lhs);
        if (lhs == "") return false;
        var head = string_char_at(lhs, 1);
        // Inline the letter check to avoid scoping issues
        var head_ord = ord(string_upper(head));
        var is_valid_head = (string_length(head) >= 1) && (head_ord >= 65 && head_ord <= 90);
        if (!is_valid_head) return false;
        var p = string_pos("(", lhs);
        if (p > 0 && string_char_at(lhs, string_length(lhs)) != ")") return false;
        return true;
    };
    
    var _has_unquoted_inkey = function(stmt, up) {
        var inq = false;
        var stmt_len = string_length(stmt);
        for (var j = 1; j <= stmt_len - 5; j++) {
            var ch = string_char_at(stmt, j);
            if (ch == "\"") {
                if (j < stmt_len && string_char_at(stmt, j + 1) == "\"") {
                    j++; // skip escaped quote
                    continue;
                }
                inq = !inq;
                continue;
            }
            if (!inq && j + 5 <= stmt_len && string_copy(up, j, 6) == "INKEY$") {
                return true;
            }
        }
        return false;
    };

    // Walk each physical line in program order
    for (var i = 0; i < ds_list_size(global.line_list); i++) {
        var line_no  = global.line_list[| i];
        var src_line = ds_map_find_value(global.program_map, line_no);
        if (!is_string(src_line)) continue;

        // Split on top-level colons (your helper)
        var parts = split_on_unquoted_colons(string_trim(src_line));
        for (var p = 0; p < array_length(parts); p++) {
            var stmt_raw = string_trim(parts[p]);
            if (stmt_raw == "") continue;

            // Ignore REM / apostrophe comments entirely
            var sp  = string_pos(" ", stmt_raw);
            var verb = (sp > 0) ? string_upper(string_copy(stmt_raw, 1, sp - 1)) : string_upper(stmt_raw);
            if (verb == "REM" || string_char_at(stmt_raw, 1) == "'") break;

            var stmt = strip_basic_remark(stmt_raw);
            var up   = string_upper(stmt);

            // Use quote-aware INKEY$ detection instead of simple string_pos
            if (_has_unquoted_inkey(stmt, up)) {
                var eqp = _top_level_eq_pos(stmt);
                if (eqp > 0) {
                    var lhs = string_copy(stmt, 1, eqp - 1);
                    if (!_is_valid_lhs(lhs)) {
                        basic_syntax_error("Left side of assignment must be a variable or array name before INKEY$", line_no, p, "INKEY_LHS");
                        return false;
                    }
                } else if (verb != "LET") {
                    basic_syntax_error("INKEY$ may only appear on the right side of an assignment like  X$ = INKEY$", line_no, p, "INKEY_MISUSE");
                    return false;
                }
            }
        }
    }
    return true;
}
/// @function mode1_scroll_grid(grid_obj, direction, amount)
/// @description Scroll the grid contents in specified direction
function mode1_scroll_grid(grid_obj, direction, amount) {
    if (!instance_exists(grid_obj)) return;
    
    var cols = 40;
    var rows = 25;
    amount = clamp(amount, 1, rows);
    
    if (dbg_on(DBG_FLOW)) show_debug_message("GRID SCROLL: " + direction + " by " + string(amount));
    
    with (grid_obj) {
        switch (string_upper(direction)) {
            case "UP":
                // Move all rows up, fill bottom with spaces
                for (var row = 0; row < rows - amount; row++) {
                    for (var col = 0; col < cols; col++) {
                        var src_i = col + (row + amount) * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                }
                // Clear bottom rows
                for (var row = rows - amount; row < rows; row++) {
                    for (var col = 0; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "DOWN":
                // Move all rows down, fill top with spaces
                for (var row = rows - 1; row >= amount; row--) {
                    for (var col = 0; col < cols; col++) {
                        var src_i = col + (row - amount) * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                }
                // Clear top rows
                for (var row = 0; row < amount; row++) {
                    for (var col = 0; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "LEFT":
                // Move all columns left, fill right with spaces
                for (var row = 0; row < rows; row++) {
                    for (var col = 0; col < cols - amount; col++) {
                        var src_i = (col + amount) + row * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                    // Clear right columns
                    for (var col = cols - amount; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "RIGHT":
                // Move all columns right, fill left with spaces
                for (var row = 0; row < rows; row++) {
                    for (var col = cols - 1; col >= amount; col--) {
                        var src_i = (col - amount) + row * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                    // Clear left columns
                    for (var col = 0; col < amount; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            default:
                if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: Unknown direction: " + direction);
                break;
        }
    }
}
/// @function basic_cmd_dim(rest)
/// @description DIM NAME(expr) or DIM NAME1(expr1), NAME2(expr2), ...
/// Allocates 1-D arrays in global.basic_arrays as zero-filled ds_lists.
/// Semantics: inclusive upper bound like C64 — DIM A(10) => valid indices 0..10.
/// Notes:
/// - Safe alongside LET auto-grow: DIM preallocates; LET keeps working the same.
/// - Multiple arrays supported, comma-separated at top level (commas inside () are ignored).
function basic_cmd_dim(rest) {
    var s  = string_trim(rest);
    if (s == "") {
        if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Missing arguments");
        return;
    }

    // Ensure array registry exists
    if (is_undefined(global.basic_arrays)) {
        global.basic_arrays = ds_map_create();
        if (dbg_on(DBG_FLOW))  show_debug_message("DIM: Created global.basic_arrays map");
    }

    // Split on top-level commas (ignore commas inside parentheses or quotes)
    var defs = [];
    {
        var _depth = 0;
        var in_q  = false;
        var start = 1;
        for (var i = 1; i <= string_length(s); i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { in_q = !in_q; }
            if (!in_q) {
                if (ch == "(") _depth++;
                else if (ch == ")") _depth = max(0, _depth - 1);
                else if (ch == "," && _depth == 0) {
                    array_push(defs, string_trim(string_copy(s, start, i - start)));
                    start = i + 1;
                }
            }
        }
        // tail
        if (start <= string_length(s)) {
            array_push(defs, string_trim(string_copy(s, start, string_length(s) - start + 1)));
        }
    }

    // Process each NAME(expr)
    for (var d = 0; d < array_length(defs); d++) {
        var item = defs[d];
        if (item == "") continue;

        var openPos  = string_pos("(", item);
        var closePos = string_last_pos(")", item);

        if (openPos <= 0 || closePos <= openPos) {
            if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Expected NAME(expr), got: " + item);
            continue;
        }

        var nm_raw  = string_trim(string_copy(item, 1, openPos - 1));
        var nm      = string_upper(nm_raw);
        var lenExpr = string_copy(item, openPos + 1, (closePos - openPos - 1));
        var lenVal  = basic_evaluate_expression_v2(lenExpr);

        if (!is_real(lenVal)) {
            if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Length expression not numeric for " + nm + " -> [" + lenExpr + "]");
            continue;
        }

        var n    = floor(max(0, lenVal));
        var size = n + 1; // inclusive upper bound (0..n)

        // Replace any existing ds_list to avoid leaks
        if (ds_map_exists(global.basic_arrays, nm)) {
            var _old = global.basic_arrays[? nm];
            if (ds_exists(_old, ds_type_list)) {
                ds_list_destroy(_old);
            }
        }

        // Create and zero-fill list
        var lst = ds_list_create();
        for (var i = 0; i < size; i++) ds_list_add(lst, 0);

        global.basic_arrays[? nm] = lst;

        if (dbg_on(DBG_FLOW))  {show_debug_message("DIM: " + nm + " sized to " + string(size) + " (indices 0.." + string(n) + ")"
            + " | lenExpr=[" + lenExpr + "] -> " + string(lenVal));}
    }
}

/// @function basic_run_to_console()
/// @description Executes the BASIC program in memory and prints the output to the console instead of the screen.

function basic_run_to_console() {
   if (dbg_on(DBG_FLOW)) show_debug_message("==== BEGIN PROGRAM CONSOLE OUTPUT ====");

    // Safety check
    if (!ds_exists(global.program_lines, ds_type_map) || !ds_exists(global.line_numbers, ds_type_list)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("No program loaded.");
        return;
    }

    // Local context for LET variable storage
    var local_vars = ds_map_create();

    // Run through each line in order
    for (var i = 0; i < ds_list_size(global.line_numbers); i++) {
        var line_num = ds_list_find_value(global.line_numbers, i);
        var code = ds_map_find_value(global.program_lines, line_num);
        var trimmed = string_trim(code);

        var sp = string_pos(" ", trimmed);
        var cmd = (sp > 0) ? string_upper(string_copy(trimmed, 1, sp - 1)) : string_upper(trimmed);
        var arg = (sp > 0) ? string_trim(string_copy(trimmed, sp + 1, string_length(trimmed))) : "";

        switch (cmd) {
            case "LET":
                var eq_pos = string_pos("=", arg);
                if (eq_pos > 0) {
                    var varname = string_trim(string_copy(arg, 1, eq_pos - 1));
                    var value = string_trim(string_copy(arg, eq_pos + 1, string_length(arg)));
                    var value_num = real(value);
                    ds_map_replace(local_vars, varname, value_num);
                }
                break;

            case "PRINT":
                // Check if last character is semicolon
                var ends_with_semicolon = (string_char_at(arg, string_length(arg)) == ";");
                if (ends_with_semicolon) {
                    arg = string_copy(arg, 1, string_length(arg) - 1);
                }

                var segments = string_split(arg, "+");
                var output = "";
                for (var j = 0; j < array_length(segments); j++) {
                    var segment = string_trim(segments[j]);
                    if (string_length(segment) >= 2 && string_char_at(segment, 1) == "\"" && string_char_at(segment, string_length(segment)) == "\"") {
                        output += string_copy(segment, 2, string_length(segment) - 2);
                    } else if (ds_map_exists(local_vars, segment)) {
                        output += string(ds_map_find_value(local_vars, segment));
                    } else {
                        output += segment;
                    }
                }

                if (ends_with_semicolon) {
                    // no newline
                    if (dbg_on(DBG_FLOW)) show_debug_message(">> " + output);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message(">> " + output + "\n");
                }
                break;

            default:
                if (dbg_on(DBG_FLOW)) show_debug_message("Unknown command on line " + string(line_num) + ": " + cmd);
        }
    }

    ds_map_destroy(local_vars);
	basic_run_to_console_flag = false;
    if (dbg_on(DBG_FLOW)) show_debug_message("==== END PROGRAM CONSOLE OUTPUT ====");
}

function basic_wrap_and_commit(_text, _color) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_wrap_and_commit START ===");

    // Output buffers must already exist
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("wrap: buffers not initialized; SKIP");
        return;
    }

    // Width: default 64 unless caller set global.wrap_width
    var wrap_width = (variable_global_exists("wrap_width") && is_real(global.wrap_width) && global.wrap_width > 0)
        ? floor(global.wrap_width) : 70;

    var remaining = string(_text);

    while (string_length(remaining) > wrap_width) {
        var len_rem = string_length(remaining);
        var cut = wrap_width;
        var last_space = 0;
        var found_space = false;

        // Find the last space at or before wrap_width
        var p = min(wrap_width, len_rem);
        for (; p >= 1; p--) {
            if (string_char_at(remaining, p) == " ") { last_space = p; break; }
        }

        if (last_space > 0) {
            // Break on that space (exclude it)
            cut = last_space - 1;
            found_space = true;
        } else {
            // Hard break … but avoid dangling punctuation on next line
            var next_char = (wrap_width + 1 <= len_rem) ? string_char_at(remaining, wrap_width + 1) : "";
            if (next_char == ")" || next_char == "]" || next_char == "}" ||
                next_char == "!" || next_char == "?" || next_char == "." ||
                next_char == "," || next_char == ":" || next_char == ";") {
                var back = wrap_width;
                while (back > 1 && string_char_at(remaining, back) != " ") back--;
                if (back > 1) {
                    cut = back - 1;   // exclude that space
                    found_space = true;
                }
            }
        }

        if (cut < 1) cut = wrap_width; // safety for huge first word

        var line = string_copy(remaining, 1, cut);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, _color);

        // Advance; skip the space when we broke on a space
        var next_start = cut + (found_space ? 2 : 1);
        if (next_start <= len_rem) {
            remaining = string_copy(remaining, next_start, len_rem - (next_start - 1));
        } else {
            remaining = "";
        }

        // Trim any leading spaces on the next line
        while (string_length(remaining) > 0 && string_char_at(remaining, 1) == " ") {
            remaining = string_copy(remaining, 2, string_length(remaining) - 1);
        }
    }

    // Tail
    ds_list_add(global.output_lines, remaining);
    ds_list_add(global.output_colors, _color);
}

/// FILE: scripts/editor__apply_pasted_text.gml
/// @function editor__apply_pasted_text(text)
/// @desc Parses BASIC lines from `text` and mutates global.program_lines/global.line_numbers.
/// @returns {bool} true if at least one line was applied; false otherwise
function editor__apply_pasted_text(text) {
    if (is_undefined(text) || string_length(text) <= 0) {
        show_message("Clipboard is empty.");
        return false;
    }

    var applied = false;
    var lines = string_split(text, "\n");
    if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: received " + string(array_length(lines)) + " raw lines");
    }

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);
        if (string_length(line) == 0) continue;

        var space_pos = string_pos(" ", line);
        if (space_pos <= 0) continue;

        var line_num_str = string_copy(line, 1, space_pos - 1);
        var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

        // Strip trailing CR in CRLF cases
        if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
            code_str = string_copy(code_str, 1, string_length(code_str) - 1);
        }

        // Validate line number is digits-only
        if (string_digits(line_num_str) != line_num_str) continue;

        var line_num = real(line_num_str);
        if (line_num <= 0 || string_length(code_str) <= 0) continue;

        // Insert/replace in program_lines
        ds_map_set(global.program_lines, line_num, code_str);

        if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
           if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");
        }

        // Maintain ordered list of line numbers
        var idx = ds_list_find_index(global.line_numbers, line_num);
        if (idx == -1) {
            ds_list_add(global.line_numbers, line_num);
            ds_list_sort(global.line_numbers, true);
            if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
               if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
            }
        } else if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
            show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
        }

        applied = true;
    }

    if (applied) {
        basic_show_message("Program pasted successfully.");
    } else {
        // Nothing matched the `<num> <code>` pattern; keep parity with Windows behavior:
        // do not show success if nothing was applied.
        show_message("Clipboard is empty or not in '<line> <code>' format.");
    }
    return applied;
}

/// @function editor_handle_paste_command
// === BEGIN: editor_handle_paste_command ===
function editor_handle_paste_command() {
	
	// Prevent HTML5 from touching the clipboard API
	if (os_browser != browser_not_a_browser) {
	    show_error_message("Use :PASTE to open paste box in browser.");
	    return;
	}

	
	
    var raw_clip = clipboard_get_text();
    if (string_length(raw_clip) <= 0) {
        show_message("Clipboard is empty.");
        return;
    }

    var lines = string_split(raw_clip, "\n");
    if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: captured " + string(array_length(lines)) + " raw lines");

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);
        if (string_length(line) == 0) continue;

        // Expect: <number><space><code>
        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var line_num_str = string_copy(line, 1, space_pos - 1);
            var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            // Windows CRLF: trim trailing '\r' if present
            if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
                code_str = string_copy(code_str, 1, string_length(code_str) - 1);
            }

            if (string_digits(line_num_str) == line_num_str) {
                var line_num = real(line_num_str);

                if (line_num > 0 && string_length(code_str) > 0) {
                    // INSERT or REPLACE program text
                    ds_map_set(global.program_lines, line_num, code_str);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");

                    // Maintain ordered line number list — add only if not present
                    var idx = ds_list_find_index(global.line_numbers, line_num);
                    if (idx == -1) {
                        ds_list_add(global.line_numbers, line_num);
                        ds_list_sort(global.line_numbers, true);
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
                    } else if (dbg_on(DBG_FLOW)) {
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
                    }
                }
            }
        }
    }

    basic_show_message("Program pasted successfully.");
}
// === END: editor_handle_paste_command ===

// FILE: scripts/basic_cmd_mode.gml
// FUNCTION: basic_cmd_mode(arg)
// BEHAVIOR: MODE 1 optionally accepts a size (8,16,32). Sets global.mode1_cell_px,
//           selects a size-matched default font from global.font_sheets, and switches rooms when needed.
function basic_cmd_mode(arg) {
    var mode    = 0;
    var size_px = -1;
    // --- Parse "1" or "1,16" (CSV-aware) ---
    var s = string_trim(arg);
    if (string_pos(",", s) > 0) {
        var parts = basic_parse_csv_args(s);
        mode = real(string_trim(parts[0]));
        if (array_length(parts) >= 2) size_px = real(string_trim(parts[1]));
    } else {
        mode = real(s);
    }
    // --- Validate mode key in registry ---
    if (!ds_map_exists(global.mode_rooms, mode)) {
        basic_show_message("Invalid MODE: " + string(mode));
        return;
    }
    // --- MODE 1: accept 8/16/32; default 32 for back-compat ---
// --- Only MODE 1 supports size selection (8/16/32), default 32 ---
if (mode == 1) {
    if (size_px != 8 && size_px != 16 && size_px != 32) size_px = 32;
    global.mode1_cell_px = size_px;
    if (dbg_on(DBG_FLOW)) show_debug_message("MODE 1: cell size set to " + string(size_px) + " px");

    // Pick a matching DEFAULT_* only if user hasn't FONTSET-locked a font
    if (!variable_global_exists("font_locked") || !global.font_locked) {
        var _key = "DEFAULT_32";
        if (size_px == 16) _key = "DEFAULT_16";
        else if (size_px == 8) _key = "DEFAULT_8";

        if (ds_map_exists(global.font_sheets, _key)) {
            global.active_font_name   = _key;
            global.active_font_sprite = global.font_sheets[? _key];
            if (dbg_on(DBG_FLOW)) show_debug_message("MODE: active font -> " + _key);
        }
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("MODE: font locked by user (" + global.active_font_name + "), leaving as-is");
    }
}

    // --- If mode already active, do not switch rooms (we still updated size/font above) ---
    if (mode == global.current_mode) {
        if (dbg_on(DBG_FLOW)) show_debug_message("MODE already set to " + string(mode) + "; no room switch needed.");
        return;
    }
    // --- Switch to the room for the requested mode ---
    global.current_mode = mode;
    var target_room = ds_map_find_value(global.mode_rooms, mode);
    if (dbg_on(DBG_FLOW)) show_debug_message("Switching to MODE " + string(mode) + " → room: " + string(target_room));
    room_goto(target_room);
}
if (showing_dir_overlay) {
    // Basic style
    var W = display_get_gui_width();
    var H = display_get_gui_height();
    var pad = 16;
    var box_w = min(720, W - pad * 2);
    var box_h = min(520, H - pad * 2);
    var bx = (W - box_w) * 0.5;
    var by = (H - box_h) * 0.5;

    // Backdrop
    draw_set_alpha(0.60);
    draw_set_color(c_black);
    draw_rectangle(0, 0, W, H, false);

    // Panel
    draw_set_alpha(1);
    draw_set_color(make_color_rgb(24,24,24));
    draw_roundrect(bx, by, bx + box_w, by + box_h, false);
    draw_set_color(c_white);

    // Title
    var title = "FILES (↑/↓ select, Enter open, Esc close)";
    draw_text(bx + pad, by + pad, title);

    // List - use dir_listing array
    if (variable_instance_exists(id, "dir_listing") && is_array(dir_listing)) {
        var n = array_length(dir_listing);
        var row_h = 22;
        var max_rows = floor((box_h - pad*3) / row_h);
        var start = clamp(dir_sel - floor(max_rows/2), 0, max(0, n - max_rows));
        var _y = by + pad*2;

        for (var i = 0; i < max_rows && (start + i) < n; i++) {
            var idx = start + i;
            var filename = dir_listing[idx];
            
            // For HTML files, get size from global.html_dir_files
            var file_size = "? bytes";
            if (variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > idx) {
                var rec = global.html_dir_files[| idx];
                if (ds_exists(rec, ds_type_map)) {
                    file_size = string(ds_map_find_value(rec, "size")) + " bytes";
                }
            }

            // highlight selected row
            if (idx == dir_sel) {
                draw_set_color(make_color_rgb(48,96,160));
                draw_rectangle(bx + pad - 6, _y - 2, bx + box_w - pad, _y + row_h - 4, false);
                draw_set_color(c_white);
            }

            draw_text(bx + pad, _y, string(idx + 1) + ". " + string(filename) + "  (" + file_size + ")");
            _y += row_h;
        }
    }
}
/// @script basic_syntax_error
/// Print a visible error line and stop the interpreter gracefully.
/// @param msg        string message explaining the error
/// @param line_no    (optional) line number; defaults to current
/// @param stmt_idx   (optional) colon-slot index; defaults to current
/// @param hint_key   (optional) short key for contextual hints, e.g. "INKEY_MISUSE"
function basic_syntax_error(msg, line_no, stmt_idx, hint_key) {
    if (is_undefined(line_no))  line_no  = global.current_line_number;
    if (is_undefined(stmt_idx)) stmt_idx = global.interpreter_current_stmt_index;
    // Flush any buffered PRINT so error doesn't glue to prior text
    if (is_string(global.print_line_buffer) && string_length(global.print_line_buffer) > 0) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        global.print_line_buffer = "";
    }
    var prev_col = global.current_draw_color;
    // Header + reason
    global.current_draw_color = c_red;
    basic_wrap_and_commit("SYNTAX ERROR at " + string(line_no) + ":", global.current_draw_color);
    basic_wrap_and_commit(string(msg), global.current_draw_color);
    // Compact hints
    if (ds_exists(global.config, ds_type_map) && global.config[? "show_error_hints"]) {
        var _h = basic_error_hint(hint_key);
        for (var i = 0; i < array_length(_h); i++) {
            if (_h[i] != "") basic_wrap_and_commit("  " + _h[i], global.current_draw_color);
        }
    }
    global.current_draw_color = prev_col;
    // Stop cleanly (no gates left engaged)
    global.pause_in_effect     = false;
    global.awaiting_input      = false;
    global.input_expected      = false;
    global.inkey_mode          = false;
    global.inkey_waiting       = false;
    global.interpreter_running = false;
    global.program_has_ended   = true;
    // Let run_program() know not to clear the screen immediately
    global._syntax_error_just_emitted = true;
    if (dbg_on(DBG_FLOW)) show_debug_message("SYNTAX: " + msg + " (line " + string(line_no) + ")");
}
// FILE: scripts/screen_editor_load_program/screen_editor_load_program.gml
/// @function screen_editor_load_program(editor_inst)
function screen_editor_load_program(editor_inst) {
    with (editor_inst) {
        //show_debug_message("SCREEN_EDITOR: Loading program to screen (scroll_offset=" + string(scroll_offset) + ")");
        
        // Clear screen first
        for (var i = 0; i < array_length(screen_buffer); i++) {
            screen_buffer[i] = ord(" ");
        }
        
        // Load program lines with scroll offset
        var total_lines = ds_list_size(global.line_numbers);
        var screen_row = 0;
        
        // Start from scroll_offset instead of 0
		for (var i = scroll_offset; i < total_lines && screen_row < screen_rows; i++) {
		    var line_num = ds_list_find_value(global.line_numbers, i);
		    var code = ds_map_find_value(global.program_lines, line_num);
		    var line_text = string(line_num) + " " + code;
    
		    // Apply horizontal offset ONLY to the current cursor line
		    var display_text = line_text;
		if (screen_row == cursor_y && horizontal_offset > 0) {
		    // Only scroll the line where the cursor currently is
		    display_text = string_copy(line_text, horizontal_offset + 1, screen_cols);
		    //show_debug_message("SCREEN_EDITOR: Applying h_offset=" + string(horizontal_offset) + " to cursor line " + string(cursor_y));
		}
            
		// Place line text on screen
		var text_len = min(string_length(display_text), screen_cols);  // Use display_text
		for (var j = 1; j <= text_len; j++) {
		    var ch = string_char_at(display_text, j);  // Use display_text
		    screen_editor_set_char_at(id, j - 1, screen_row, ord(ch));
		}
            
            screen_row++;
        }
        
        //show_debug_message("SCREEN_EDITOR: Loaded " + string(screen_row) + " lines starting from offset " + string(scroll_offset));
    }
}
/// @func split_on_unquoted_commas(s)
/// @desc Split a string on commas that are OUTSIDE quotes (and outside parentheses),
///       mirroring your colon-splitter behavior. Keeps empty fields trimmed out.
///       Examples:
///         split_on_unquoted_commas("1,2,\"a,b\",3") -> ["1","2","\"a,b\"","3"]
///         split_on_unquoted_commas("A(1,2),B")      -> ["A(1,2)","B"]
function split_on_unquoted_commas(s) {
    var parts = [];
    if (s == undefined) return parts;

    var L = string_length(s);
    var in_q = false;
    var _depth = 0;     // parentheses depth for safety (DATA can contain A(…), keep it intact)
    var start = 1;

    for (var i = 1; i <= L; i++) {
        var ch = string_char_at(s, i);

        if (ch == "\"") {
            // Handle doubled quotes "" inside strings -> treat as escaped, stay in same quote state
            var nxt = (i < L) ? string_char_at(s, i + 1) : "";
            if (in_q && nxt == "\"") { i++; continue; }
            in_q = !in_q;
            continue;
        }

        if (!in_q) {
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (ch == "," && _depth == 0) {
                var seg = string_trim(string_copy(s, start, i - start));
                if (seg != "") parts[array_length(parts)] = seg;
                start = i + 1;
            }
        }
    }

    // tail
    var tail = string_trim(string_copy(s, start, L - start + 1));
    if (tail != "") parts[array_length(parts)] = tail;

    if (dbg_on && is_undefined(dbg_on) == false) {} // no-op to avoid warnings if dbg_on is macro
    if (dbg_on(DBG_FLOW)) show_debug_message("split_on_unquoted_commas('" + s + "') -> " + string(parts));

    return parts;
}

// ===============================================
// FILE: scripts/screen_editor_commit_row_extended/screen_editor_commit_row_extended.gml
// NEW: Modified commit function that accepts full line text
// ===============================================

/// @function screen_editor_commit_row_extended(editor_inst, _row, line_text)
function screen_editor_commit_row_extended(editor_inst, _row, line_text) {
    with (editor_inst) {
        var trimmed_text = string_trim(line_text);
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Committing row " + string(_row) + ": '" + trimmed_text + "'");
        
        if (trimmed_text == "") return;
        
        if (string_upper(trimmed_text) == "EXIT") {
            screen_editor_exit(id);
            return;
        }
        
        var space_pos = string_pos(" ", trimmed_text);
        var line_num_str = "";
        var code = "";
        
        if (space_pos > 0) {
            line_num_str = string_copy(trimmed_text, 1, space_pos - 1);
            code = string_trim(string_copy(trimmed_text, space_pos + 1, string_length(trimmed_text)));
        } else {
            line_num_str = trimmed_text;
        }
        
        var line_num = real(line_num_str);
        if (line_num_str != "" && is_real(line_num) && line_num > 0) {
            if (code == "") {
                delete_program_line(line_num);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Deleted line " + string(line_num));
            } else {
                add_or_update_program_line(line_num, code);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Added/updated line " + string(line_num) + ": " + code);
            }
        }
    }
}
function basic_cmd_pset(arg) {
    var args = string_split(arg, ",");
    if (array_length(args) < 5) {
        if (dbg_on(DBG_FLOW))  show_debug_message("PSET requires 5 arguments: x, y, char, fg, bg");
        return;
    }
    
    // Evaluate expressions for x, y, and char (they might be variables or expressions)
    var x_val = real(basic_evaluate_expression_v2(string_trim(args[0])));
    var y_val = real(basic_evaluate_expression_v2(string_trim(args[1])));
    var char_index = real(basic_evaluate_expression_v2(string_trim(args[2])));
    
    var fg_str = string_upper(string_trim(args[3]));
    var bg_str = string_upper(string_trim(args[4]));
    
    var fg_color = ds_map_exists(global.colors, fg_str) ? global.colors[? fg_str] : c_white;
    var bg_color = ds_map_exists(global.colors, bg_str) ? global.colors[? bg_str] : c_black;
    
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (instance_exists(grid_obj)) {
        var cols = 40;
        var rows = 25;
        if (x_val >= 0 && x_val < cols && y_val >= 0 && y_val < rows) {
            var index = x_val + y_val * cols;
            grid_obj.grid[index].char = char_index;
            grid_obj.grid[index].fg = fg_color;
            grid_obj.grid[index].bg = bg_color;
            if (dbg_on(DBG_FLOW))  show_debug_message("PSET: Set tile at (" + string(x_val) + "," + string(y_val) + ") to char=" + string(char_index));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("PSET: coordinates out of bounds: (" + string(x_val) + "," + string(y_val) + ")");
        }
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("PSET: No grid object found");
    }
}
/// @event obj_editor/Create
// You can write your code in this editor
 // Program storage


 // Input handling
 current_input = "";               // Current line being typed
 cursor_pos = 0;                  // Text cursor position


 input_buffer = "";               // Buffer for key repeat handling
 // Display variables
 display_start_line = 0;          // For scrolling through program
 lines_per_screen = 20;           // How many lines to show
 font_height = 16;                // Adjust based on your font
 screen_width = room_width;
 screen_height = room_height;
 // Syntax highlighting settings
 syntax_highlighting = true;      // Toggle for syntax highlighting
 keyword_color = c_blue;          // Color for BASIC keywords
 text_color = c_green;            // Default text color
 number_color = c_yellow;         // Color for line numbers
 // State management
 editor_mode = "READY";           // States: "READY", "INPUT", "RUNNING"
 current_filename = "";           // For save/load operations
 // Keyboard handling
 last_keyboard_string = "";       // Track keyboard_string changes
 key_repeat_timer = 0;            // For handling key repeat timing
 // Undo system

 max_undo_levels = 20;            // Limit undo history
 // Message system
 message_text = "";
 message_timer = 0;
 
 drag_enabled = true;
 //show_debug_message("Working directory: " + working_directory);
keyboard_string = "";

//for directory listings
showing_dir_overlay = false;
dir_listing = [];

// Overlay for HTML DIR listing
show_dir_overlay = false;   // draw toggle
dir_cursor       = 0;       // selected row (0-based)

/// @function basic_cmd_font(arg)
/// @desc FONTSET "KEY" -> switch active font sprite by registry key
function basic_cmd_font(arg) {
    if (global.current_mode < 1) {
        basic_print_system_message("FONT not implemented in MODE " + string(global.current_mode));
        return;
    }

    var key = string_trim(arg);

    // Strip quotes if present
    if (string_length(key) >= 2) {
        var f = string_char_at(key,1);
        var l = string_char_at(key,string_length(key));
        if ((f == "\"" || f == "'") && f == l) key = string_copy(key,2,string_length(key)-2);
    }

    key = string_upper(key);

    if (!variable_global_exists("font_sheets")) {
        basic_print_system_message("FONT registry not initialized");
        return;
    }

    if (ds_map_exists(global.font_sheets, key)) {
        var spr = ds_map_find_value(global.font_sheets, key);
        global.active_font_name   = key;
        global.active_font_sprite = spr;

        // DEBUG: prove which sprite & how many subimages
        var n = sprite_get_number(spr);
        if (dbg_on(DBG_FLOW)) {
            show_debug_message("FONTSET: key=" + key
                + " spr_id=" + string(spr)
                + " subimages=" + string(n));
        }

        // Trigger a lightweight refresh (keeps existing fg/bg)
        global.grid_refresh_needed = true;
        global.grid_refresh_char   = 32; // space

    } else {
        basic_cmd_print("FONT " + key + " not found", false);
        if (dbg_on(DBG_FLOW)) show_debug_message("FONTSET: missing registry key '" + key + "'");
    }
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function load_program_from_path(file_path, filename) {
    if (!file_exists(file_path)) {
        show_error_message("DRAG FILE NOT FOUND");
        return;
    }
    
    try {
        save_undo_state();
        new_program_without_undo();
        
        var file = file_text_open_read(file_path);
        while (!file_text_eof(file)) {
            var line = file_text_read_string(file);
            file_text_readln(file);
            
            if (string_trim(line) != "") {
                var space_pos = string_pos(" ", line);
                if (space_pos > 0) {
                    var line_num_str = string_copy(line, 1, space_pos - 1);
					                    var line_num = real(line_num_str);
                    var code_content = string_copy(line, space_pos + 1, string_length(line));
                    
                    if (is_line_number(line_num_str) && is_valid_line_number(line_num)) {
                        ds_map_set(global.program_lines, line_num, code_content);
                        insert_line_number_ordered(line_num);
                    }
                }
            }
        }
        file_text_close(file);
        current_filename = filename;
        basic_show_message("LOADED via DRAG: " + filename);
        update_display();
    } catch (e) {
        show_error_message("DRAG LOAD ERROR");
    }
 }
/// @function basic_array_init(name, size)
/// @description Initializes a 1D array as a ds_list in global.basic_arrays
/// @param name The name of the array (string)
/// @param size The size of the array (number of elements)
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_init(_name, _size) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT: Initializing " + nm + " with size " + string(_size));

    // If the array already exists, destroy its backing list
    if (ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT WARNING: Array '" + nm + "' already exists, destroying");
        var old_lst = global.basic_arrays[? nm];
        if (ds_exists(old_lst, ds_type_list)) {
            ds_list_destroy(old_lst);
        }
        ds_map_delete(global.basic_arrays, nm);
    }

    // Normalize and validate size
    var sz = floor(real(_size));
    if (sz < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT ERROR: Invalid size " + string(sz) + " for " + nm);
        return;
    }

    // Create and fill
    var lst = ds_list_create();
    repeat (sz) {
        ds_list_add(lst, 0);
    }
    global.basic_arrays[? nm] = lst;

    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT: Created " + nm + " with size " + string(ds_list_size(lst)));
}

/// @function basic_cmd_fontset(arg)
/// @description FONTSET "<registry-key>"
function basic_cmd_fontset(arg) {
    if (global.current_mode < 1) {
        basic_print_system_message("FONTSET not implemented in MODE " + string(global.current_mode));
        return;
    }

    var key = string_upper(string_trim(arg));

    // Strip quotes if present
    if (string_length(key) >= 2) {
        var first = string_char_at(key, 1);
        var last  = string_char_at(key, string_length(key));
        if ((first == "\"" || first == "'") && first == last) {
            key = string_copy(key, 2, string_length(key) - 2);
        }
    }

    if (!ds_map_exists(global.font_sheets, key)) {
        basic_cmd_print("FONTSET: " + key + " not found", false);
        return;
    }

    // Lock the font so MODE/room init won't overwrite it
    global.active_font_name   = key;
    global.active_font_sprite = global.font_sheets[? key];
    global.font_locked        = true;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("FONTSET -> " + key
            + "  sprite=" + string(global.active_font_sprite)
            + "  subimages=" + string(sprite_get_number(global.active_font_sprite)));
    }

    // Reblank using current sheet's blank char, if you do that
    global.grid_refresh_needed = true;
}

/// @event obj_basic_interpreter/Create

    global.debug_mask        = DBG_ALL;//0;//DBG_ALL;   // start verbose; you can trim later
    global.dbg_frame_quota   = 0;      // 1200 is ~20 logs per ms at 60fps is ok; tune as needed
    global.dbg_frame_count   = 0;
    global.dbg_dropped_count = 0;

// Set the current draw color
global.current_draw_color = global.basic_text_color;

// Use the shared global data structures
global.program_map  = global.basic_program; // optional if you're not modifying
global.line_list    = global.basic_line_numbers;

// Interpreter control variables
line_index = 0;                         // current line being executed
font_height = 16;

current_input = "";
cursor_pos = 0;
last_keyboard_string = "";

global.interpreter_current_line_index = 0;
global.interpreter_next_line = -1;

// Local list to hold current run if needed
interpreter_current_program = ds_list_create(); // OK to keep local

basic_run_to_console_flag = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
    global.help_topics = ds_list_create();
} else {
    ds_list_clear(global.help_topics);
}

// PRINT tab stop width (classic BASIC style)
if (is_undefined(global.print_zone)) global.print_zone = 14;



// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function load_program_json(filename) {
    var file_path = working_directory + filename + ".json";
    
    if (!file_exists(file_path)) {
        show_error_message("JSON FILE NOT FOUND");
        return;
    }
    
    try {
        var file = file_text_open_read(file_path);
        var json_string = file_text_read_string(file);
        file_text_close(file);
        
        var loaded_map = json_decode(json_string);
        
        new_program();
        ds_map_copy(global.program_lines, loaded_map);
        
        // Rebuild line numbers list
        var key = ds_map_find_first(global.program_lines);
        while (!is_undefined(key)) {
            insert_line_number_ordered(real(key));
            key = ds_map_find_next(global.program_lines, key);
        }
        
        ds_map_destroy(loaded_map);
        basic_show_message("LOADED JSON: " + filename);
        update_display();
    } catch (e) {
        show_error_message("JSON LOAD ERROR");
    }
 }
// ===============================================
// FILE: scripts/refresh_current_line_display/refresh_current_line_display.gml
// NEW: Helper function to update display for current line
// ===============================================

/// @function refresh_current_line_display(editor_inst)
function refresh_current_line_display(editor_inst) {
    with (editor_inst) {
        var full_text = get_full_line_text(id, cursor_y);
        var display_text = string_copy(full_text, horizontal_offset + 1, screen_cols);
        
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Refreshing display - full_text='" + full_text + "', display='" + display_text + "', h_offset=" + string(horizontal_offset));
        
        // Clear the row
        screen_editor_clear_row(id, cursor_y);
        
        // Display the visible portion
        for (var i = 1; i <= string_length(display_text); i++) {
            var ch = string_char_at(display_text, i);
            screen_editor_set_char_at(id, i - 1, cursor_y, ord(ch));
        }
    }
}
/// @function basic_cmd_goto(arg)
/// @description Sets the program counter to a new line number if it exists.
function basic_cmd_goto(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("GOTO START — Raw arg: '" + arg + "'");

    var trimmed_arg = string_trim(arg);
    var target_line = real(trimmed_arg);

    if (dbg_on(DBG_FLOW)) show_debug_message("GOTO: Parsed target line number: " + string(target_line));

    // Find the index in your line_list
    var index = -1;
	for (var i = 0; i < ds_list_size(global.line_list); i++) {
	    if (real(ds_list_find_value(global.line_list, i)) == target_line) {
	        index = i;
	        break;
	    }
	}

	
    if (index >= 0) {
        global.interpreter_next_line = index;
        if (dbg_on(DBG_FLOW)) show_debug_message("GOTO SUCCESS → Jumping to line " + string(target_line) + " (list index " + string(index) + ")");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("?GOTO ERROR: Line number " + string(target_line) + " not found in global.line_list");
    }
}

// ===============================================
// FILE: scripts/set_full_line_text/set_full_line_text.gml  
// NEW: Helper function to store complete line text
// ===============================================

/// @function set_full_line_text(editor_inst, row, text)
function set_full_line_text(editor_inst, row, text) {
    with (editor_inst) {
        if (string_length(text) > screen_cols) {
            extended_lines[? row] = text;
           if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Stored extended line " + string(row) + ": '" + text + "'");
        } else {
            // Remove from extended storage if line is now short
            if (ds_map_exists(extended_lines, row)) {
                ds_map_delete(extended_lines, row);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Removed extended line " + string(row) + " (now fits on screen)");
            }
        }
    }
}
function reset_interpreter_state() {
    global.interpreter_running = false;
    global.program_has_ended = false;
    global.awaiting_input = false;
    global.pause_in_effect = false;
    global.pause_mode = false;
    global.input_expected = false;
    global.interpreter_input = "";
    global.interpreter_cursor_pos = 0;
    global.last_interpreter_string = "";
    
    // Reset mode if needed
    if (global.current_mode != 0) {
        global.current_mode = 0;
        room_goto(rm_basic_interpreter);
    }
    
    // Clear any program execution state
    ds_stack_clear(global.gosub_stack);
    ds_stack_clear(global.for_stack);
    ds_stack_clear(global.while_stack);
	// Clear INKEY$ queue
    if (ds_exists(global.__inkey_queue, ds_type_queue)) {
    ds_queue_clear(global.__inkey_queue);
    if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ RESET: Cleared global.__inkey_queue");
   }
}
/// @script is_function
// === BEGIN: is_function ===
function is_function(t) {
    var fn = string_upper(string_trim(t));
    return  fn == "RND"    // your original BASIC call
         || fn == "RND1"   // internal 1-arg postfix token
         || fn == "RND2"   // internal 2-arg postfix token
         || fn == "STR$"
         || fn == "CHR$"
         || fn == "LEFT$"
         || fn == "RIGHT$"
         || fn == "MID$"
         || fn == "ABS"
         || fn == "INT"
         || fn == "EXP"
         || fn == "LOG"
         || fn == "LOG10"
         || fn == "SGN"
         || fn == "SIN"
         || fn == "COS"
         || fn == "TAN"
         || fn == "REPEAT$"
         || fn == "TIMER"
         || fn == "TIME$"
         || fn == "DATE$"
         || fn == "INKEY$"
         || fn == "ASC"
		 || fn == "LEN";   // <-- added
}
// === END: is_function ===

// FILE: scripts/start_screen_editor/start_screen_editor.gml
/// @function start_screen_editor()
/// @description Launch the full-screen C64-style editor

function start_screen_editor() {
   if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: start_screen_editor called");
    
    if (global.screen_edit_mode) {
       if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: Screen editor already active");
        basic_show_message("Screen editor already active");
        return;
    }
    
   if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: Setting screen_edit_mode = true and creating obj_screen_editor");
    global.screen_edit_mode = true;
    instance_create_layer(0, 0, "Instances", obj_screen_editor);
    
    basic_show_message("Entering screen edit mode...");
}
/// pm_paste_handler(data, name, type)
function pm_paste_handler(_data, _name, _type) {
    // Text if name is undefined
    if (is_undefined(_name)) {
        if (is_string(_data) && string_length(_data) > 0) {
            pm_receive_text(_data);
        } else {
           if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Text handler: empty or non-string payload.");
        }
    } else {
        // You pasted a file; ignore for now (or handle base64 here)
       if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] File paste ignored: " + string(_name) + " (" + string(_type) + ")");
    }

    // Unbind so we don't keep intercepting Ctrl/Cmd+V forever
    var _bind = asset_get_index("browser_paste_bind");
    if (_bind != -1) script_execute(_bind);
}

function dump_program_to_console() {
    if (dbg_on(DBG_FLOW)) show_debug_message("==== BASIC PROGRAM DUMP ====");

    var lines = global.line_numbers; // numeric line numbers
    var prog = global.program_lines;

    for (var i = 0; i < ds_list_size(lines); i++) {
        var linenum = ds_list_find_value(lines, i); // numeric
        if (ds_map_exists(prog, linenum)) {
            var code = ds_map_find_value(prog, linenum);
            if (dbg_on(DBG_FLOW)) show_debug_message(string(linenum) + " " + code);
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("Missing entry for key: " + string(linenum));
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("==== END OF DUMP ====");
}

/// @function editor_html_save_selftest()
function editor_html_save_selftest() {
    if (function_exists("browser_file_tools_init")) browser_file_tools_init();
    if (!function_exists("browser_show_save_dialog")) {
        show_error_message("Save dialog function not present.");
        return;
    }
    var s = "HELLO\r\n";
    var n = string_length(s);
    var b = buffer_create(n, buffer_fixed, 1);
    for (var i = 1; i <= n; i++) buffer_write(b, buffer_u8, ord(string_char_at(s, i)));
    buffer_seek(b, buffer_seek_start, 0);
    browser_show_save_dialog(b, "selftest.bas", "text/plain; charset=utf-8", n);
    buffer_delete(b);
    basic_show_message("Save self-test offered.");
}

/// @function mode1_grid_set(x, y, ch, fg, bg)
/// @desc Update a grid cell with char + optional fg/bg colors
function mode1_grid_set(_x, _y, _char, _fg, _bg) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return;

    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _x >= cols || _y < 0 || _y >= rows) return;

    var idx = _x + _y * cols;
    var cell = grid_obj.grid[idx];

    // Always set the glyph
    cell.char = _char;

    // Only change colors if the caller supplied them
    if (_fg != undefined) cell.fg = _fg;
    if (_bg != undefined) cell.bg = _bg;

    grid_obj.grid[idx] = cell;
}

// ===============================================
// FILE: scripts/screen_editor_clear_row/screen_editor_clear_row.gml
// NEW: Helper function to clear a display row
// ===============================================

/// @function screen_editor_clear_row(editor_inst, _row)
function screen_editor_clear_row(editor_inst, _row) {
    with (editor_inst) {
        if (_row < 0 || _row >= screen_rows) return;
        for (var _x = 0; _x < screen_cols; _x++) {
            screen_editor_set_char_at(id, _x, _row, ord(" "));
        }
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cleared row " + string(_row));
    }
}
function is_numeric_string(str) {
    if (string_length(str) == 0) return false;

    // Allow negative sign
    if (string_char_at(str, 1) == "-") {
        str = string_copy(str, 2, string_length(str));
        if (string_length(str) == 0) return false; // <- Add this
    }

    var dot_count = 0;
    for (var i = 1; i <= string_length(str); i++) {
        var c = string_char_at(str, i);
        if (c == ".") {
            dot_count++;
            if (dot_count > 1) return false;
        }
        else if (ord(c) < ord("0") || ord(c) > ord("9")) {
            return false;
        }
    }

    return true;
}

/// @function import_from_url(_url)
/// @desc Fetch text at URL, then import into the editor as numbered lines.
function import_from_url(_url) {
    if (!is_string(_url) || _url == "") {
        show_error_message("Usage: :LOADURL <http(s)://...>");
        return;
    }
    if (!variable_global_exists("http_tags")) global.http_tags = ds_map_create();

    var req = http_get(_url);
    // Store a tag so we know why this request happened
    ds_map_replace(global.http_tags, req, ":LOADURL");
   if (dbg_on(DBG_FLOW)) show_debug_message("[LOADURL] GET -> " + _url + " (req=" + string(req) + ")");
}

/// Decode a data: URL (base64) into a text string (ASCII/UTF-8)
function editor_html_decode_data_url_to_text(data_url) {
    var comma = string_pos(",", data_url);
    if (comma <= 0) return "";
    var b64 = string_copy(data_url, comma + 1, string_length(data_url) - comma);

    var buf = buffer_base64_decode(b64); // native GMS
    if (buf <= 0) return "";
    buffer_seek(buf, buffer_seek_start, 0);

    var n = buffer_get_size(buf);
    var s = "";
    for (var i = 0; i < n; i++) {
        s += chr(buffer_read(buf, buffer_u8));
    }
    buffer_delete(buf);
    return s;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_line_number(str) {
    // Check if string contains only digits
    if (string_length(str) == 0) return false;
    
    for (var i = 1; i <= string_length(str); i++) {
        var char = string_char_at(str, i);
        if (char < "0" || char > "9") return false;
    }
    
    // Convert to number and validate range
    var line_num = real(str);
    return (line_num >= 1 && line_num <= 65535);
 }
function split_on_unquoted_semicolons(s) {
    var result = [];
    var current = "";
    var in_string = false;
    for (var i = 1; i <= string_length(s); i++) {
        var c = string_char_at(s, i);
        if (c == "\"") in_string = !in_string;
        if (c == ";" && !in_string) {
            array_push(result, string_trim(current));
            current = "";
        } else {
            current += c;
        }
    }
    if (string_length(current) > 0) array_push(result, string_trim(current));
    return result;
}

/// @function interpreter_cmd_print(argument)
/// @description Handles the BASIC PRINT command.
/// @param arg - The string argument from the BASIC code

function interpreter_cmd_print(arg) {
    // Remove surrounding double quotes if present
    if (string_length(arg) >= 2 &&
        string_char_at(arg, 1) == "\"" &&
        string_char_at(arg, string_length(arg)) == "\"") {
        arg = string_copy(arg, 2, string_length(arg) - 2);
    }

    ds_list_add(output_lines, arg);
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function new_program() {
    // Save state for undo before clearing
    if (ds_list_size(global.line_numbers) > 0) {
        save_undo_state();
    }
    
    ds_map_clear(global.program_lines);
    ds_list_clear(global.line_numbers);
    current_filename = "";
    display_start_line = 0;
    update_display();
    basic_show_message("NEW PROGRAM");
 }
/// Destroys previous records and clears the list.
function editor_html_dir__reset() {
    if (!variable_global_exists("html_dir_files")) {
        global.html_dir_files = ds_list_create();
        return;
    }
    var n = ds_list_size(global.html_dir_files);
    for (var i = 0; i < n; i++) {
        var rec = global.html_dir_files[| i];
        if (ds_exists(rec, ds_type_map)) ds_map_destroy(rec);
    }
    ds_list_clear(global.html_dir_files);
}

/// @script basic_current_line_no
function basic_current_line_no() {
    if (ds_exists(global.line_list, ds_type_list)) {
        var idx = global.interpreter_current_line_index;
        if (is_real(idx) && idx >= 0 && idx < ds_list_size(global.line_list)) {
            return global.line_list[| idx];
        }
    }
    return is_undefined(global.current_line_number) ? -1 : global.current_line_number;
}
// FILE: scripts/screen_editor_get_char_at/screen_editor_get_char_at.gml
/// @function screen_editor_get_char_at(editor_inst, _x, _y)
function screen_editor_get_char_at(editor_inst, _x, _y) {
    with (editor_inst) {
        if (_x < 0 || _x >= screen_cols || _y < 0 || _y >= screen_rows) return ord(" ");
        var idx = _y * screen_cols + _x;
        return screen_buffer[idx];
    }
}
/// @function paste_line(index, text)
/// @description Called by JavaScript for each line of pasted text
function paste_line(index, text) {
    ds_list_add(paste_buffer, string(text));
   if (dbg_on(DBG_FLOW)) show_debug_message("PASTE_MANAGER: Received line " + string(index) + ": " + string_copy(string(text), 1, 50) + "...");
}
function basic_cmd_end() {
    if (dbg_on(DBG_FLOW)) show_debug_message("END: Program termination requested");
    global.program_has_ended = true;
    global.interpreter_running = false;
	 global.current_mode = 0;
    if (dbg_on(DBG_FLOW)) show_debug_message("END: interpreter_running set to false");
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function save_program() {
    if (current_filename == "") {
        show_error_message("NO FILENAME");
        return;
    }
    save_program_as(current_filename);
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_valid_line_number(line_num) {
    return (line_num >= 1 && line_num <= global.config[? "max_line_number"]);
 }

// FILE: objects/obj_screen_editor/Destroy_0.gml
// REMOVE: Delete the entire Destroy event or replace with:

/// @event Destroy
// No cleanup needed - reverted to simple implementation
show_debug_message("SCREEN_EDITOR: Destroying");
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_current_colors() {
    basic_show_message("CURRENT SCHEME - USE: COLOR GREEN/BLUE/AMBER");
 }
/// @event obj_mode1_grid/Destroy
// You can write your code in this editor
reset_interpreter_state();
global.current_mode = 0;
show_message(" Unto the abyss I fall");

// Optional helper for errors: prefix message with a "?" as classic BASIC did.
function basic_show_error_message(err) {
    basic_show_message("?" + err);
}



function is_letter(ch) {
    var o = ord(string_upper(ch));
    return (o >= 65 && o <= 90);
}



function is_letter_or_digit(ch) {
    return is_letter(ch) || (ord(ch) >= 48 && ord(ch) <= 57);
}
/// @event obj_editor/Game End


