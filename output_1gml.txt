/// @script evaluate_postfix
/// @description Evaluate a postfix token array, with support for 1-D arrays.
/// Notes:
/// - Array tokens arrive as a single atom like "D(I)" because infix_to_postfix collapses NAME(...).
/// - We defensively avoid treating built-in functions as arrays (e.g., "INT(5)").
/// - Comma tokens are ignored completely.
/// - Returns the TOP of the stack (last pushed), else 0.

function evaluate_postfix(postfix) {
    var stack = [];
    if (dbg_on(DBG_PARSE)) show_debug_message("Evaluating postfix: " + string(postfix));

    for (var i = 0; i < array_length(postfix); i++) {
        var token = postfix[i];
        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Processing token [" + string(i) + "] → " + string(token));

        // Normalize once
        var trimmed     = string_trim(string(token));
        var token_upper = string_upper(trimmed);

        // -------------------------------------------------------
        // Ignore commas completely (arg separators, never values)
        // -------------------------------------------------------
        if (trimmed == ",") {
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Ignoring stray comma token");
            continue;
        }

        // -------------------------------------------------------
        // ARRAY READ SUPPORT (atom form: NAME(index_expr))
        // -------------------------------------------------------
        var openPos = string_pos("(", token_upper);
        if (openPos > 0 && string_char_at(token_upper, string_length(token_upper)) == ")") {
            var arrNameU   = string_copy(token_upper, 1, openPos - 1);
            var innerLen   = string_length(token) - openPos - 1;
            var idxTextRaw = string_copy(token, openPos + 1, innerLen);

            // MINIMAL CHANGE: also skip STRING$ here even if is_function() doesn't know it
            if (!is_function(arrNameU) && arrNameU != "STRING$") {
                var arrName = arrNameU; // arrays stored uppercase in helpers
                var idxText = string_trim(idxTextRaw);

                if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY]: Candidate '" + string(token) + "' → name='" + arrName + "', idxText='" + idxText + "'");

                var idxVal = basic_evaluate_expression_v2(idxText);
                if (!is_real(idxVal)) {
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY] ERROR: Index non-numeric from '" + idxText + "' → '" + string(idxVal) + "'. Pushing 0.");
                    array_push(stack, 0);
                    continue;
                }

                var arrVal = basic_array_get(arrName, idxVal); // your 1-based getter
                if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY]: " + arrName + "(" + string(idxVal) + ") → " + string(arrVal));
                array_push(stack, arrVal);
                continue;
            }
        }

        // -------------------------------------------------------
        // Numeric literal
        // -------------------------------------------------------
        if (is_numeric_string(trimmed)) {
            var num = real(trimmed);
            array_push(stack, num);
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed number → " + string(num));
            continue;
        }

        // -------------------------------------------------------
        // Quoted string literal
        // -------------------------------------------------------
        if (string_length(trimmed) >= 2
        &&  string_char_at(trimmed, 1) == "\""
        &&  string_char_at(trimmed, string_length(trimmed)) == "\"")
        {
            var str = string_copy(trimmed, 2, string_length(trimmed) - 2);
            str = string_replace_all(str, "\"\"", "\"");  // unescape "" -> "
            array_push(stack, str);
            if (dbg_on(DBG_FLOW)) if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed quoted string literal → " + str);
            continue;
        }

		// -------------------------------------------------------
		// Operators
		// -------------------------------------------------------
		if (is_operator(token_upper)) {
		    if (array_length(stack) < 2) {
		        if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX ERROR: Not enough operands for operator " + token_upper);
		        return 0;
		    }
		    var b = array_pop(stack);
		    var a = array_pop(stack);
		    var result = 0;

		    switch (token_upper) {
		        case "+":  result = (is_string(a) || is_string(b)) ? string(a) + string(b) : a + b; break;

		        case "-":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = a - b;
		            break;

case "=": {
    // Check if both are numeric (but exclude empty strings)
    var an = is_real(a) || (is_string(a) && string_length(a) > 0 && is_numeric_string(a));
    var bn = is_real(b) || (is_string(b) && string_length(b) > 0 && is_numeric_string(b));

    if (an && bn) {
        if (is_string(a)) a = real(a);
        if (is_string(b)) b = real(b);
        result = (a == b) ? 1 : 0;
    } else {
        result = (string(a) == string(b)) ? 1 : 0;
    }
    break;
}

		        // NEW: all other comparisons must live here (not in the function switch)
		        case "<>": {
		            // numeric compare if both are numbers; otherwise string compare
		            if (is_real(a) && is_real(b)) result = (a != b) ? 1 : 0;
		            else                          result = (string(a) != string(b)) ? 1 : 0;
		            break;
		        }
		        case "<": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a < b) ? 1 : 0;
		            break;
		        }
		        case ">": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a > b) ? 1 : 0;
		            break;
		        }
		        case "<=": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a <= b) ? 1 : 0;
		            break;
		        }
		        case ">=": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a >= b) ? 1 : 0;
		            break;
		        }

		        case "*":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = a * b;
		            break;

		        case "/":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (b != 0) ? a / b : 0;
		            break;

		        case "\\": { // integer division → truncate toward ZERO
		            if (is_string(a) && is_numeric_string(a)) a = real(a);
		            if (is_string(b) && is_numeric_string(b)) b = real(b);

		            if (!is_real(a) || !is_real(b)) {
		                basic_syntax_error("Integer division '\\' expects numbers; got a=" + string(a) + ", b=" + string(b),
		                    global.current_line_number, global.interpreter_current_stmt_index, "TYPE_MISMATCH");
		                result = 0; break;
		            }
		            if (b == 0) {
		                basic_syntax_error("Division by zero in '\\'",
		                    global.current_line_number, global.interpreter_current_stmt_index, "DIV_ZERO");
		                result = 0; break;
		            }

		            var q = a / b;
		            q = (q >= 0) ? floor(q) : ceil(q); // trunc-to-zero
		            result = q;
		            break;
		        }

		        case "%":
		        case "MOD":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = a mod b;
		            break;

		        case "^":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = power(a, b);
		            break;

case "AND": {
    // Don't pop again - use the a,b already popped above
    var tb = is_real(b) ? (b != 0) : (string_length(string(b)) > 0);
    var ta = is_real(a) ? (a != 0) : (string_length(string(a)) > 0);
    
    result = (ta && tb) ? 1 : 0;
    break;
}
case "OR": {
    // Don't pop again - use the a,b already popped above  
    var tb = is_real(b) ? (b != 0) : (string_length(string(b)) > 0);
    var ta = is_real(a) ? (a != 0) : (string_length(string(a)) > 0);
    
    result = (ta || tb) ? 1 : 0;
    break;
}

		        default:
		            if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX WARNING: Unknown operator = " + token_upper + " → 0");
		            result = 0;
		            break;
		    }

		    array_push(stack, result);
		    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Operator result (" + token_upper + ") = " + string(result));
		    continue;
		}


        // -------------------------------------------------------
        // Functions (numeric + string)
        // -------------------------------------------------------
        if (is_function(token_upper) || token_upper == "STRING$") {
            token_upper = string_upper(string_trim(token));
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Dispatching function → '" + token_upper + "'");

            switch (token_upper) {

                // ---- Random
                case "RND1": {
                    var n = safe_real_pop(stack);
                    if (n <= 0) n = 1;
                    var r1;
                    if (n == 1) {
                        // Classic BASIC: RND(1) returns 0.0 to 0.999...
                        r1 = random(1);
                    } else {
                        // Integer range: RND(6) returns 1-6
                        r1 = irandom(n - 1) + 1;
                    }
                    array_push(stack, r1);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RND1(" + string(n) + ") → " + string(r1));
                    break;
                }

                case "RND2": {
                    var max_val_raw = array_pop(stack);
                    var min_val_raw = array_pop(stack);
                    var min_val, max_val;

                    if (is_real(min_val_raw)) {
                        min_val = min_val_raw;
                    } else if (ds_map_exists(global.basic_variables, min_val_raw) && is_real(global.basic_variables[? min_val_raw])) {
                        min_val = global.basic_variables[? min_val_raw];
                    } else {
                        min_val = undefined;
                    }

                    if (is_real(max_val_raw)) {
                        max_val = max_val_raw;
                    } else if (ds_map_exists(global.basic_variables, max_val_raw) && is_real(global.basic_variables[? max_val_raw])) {
                        max_val = global.basic_variables[? max_val_raw];
                    } else {
                        max_val = undefined;
                    }

                    if (!is_real(min_val) || !is_real(max_val)) {
                        basic_system_message("ERROR: RND(min,max) requires numeric arguments — got '" 
                            + string(min_val_raw) + "', '" + string(max_val_raw) + "'");
                        array_push(stack, 0);
                    } else {
                        var result = irandom_range(min_val, max_val);
                        array_push(stack, result);
                        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RND2(" + string(min_val) + "," + string(max_val) + ") → " + string(result));
                    }
                    break;
                }

                // ---- NEW: Zero-arg time/keyboard functions ----
                case "TIMER": {
                    var secs = floor(current_time / 1000); // ms → seconds since game start
                    array_push(stack, secs);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: TIMER → " + string(secs));
                    break;
                }
				
				case "LEN": {
				    var s = string(array_pop(stack));
				    array_push(stack, string_length(s));
				    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: LEN('" + s + "') → " + string(string_length(s)));
				    break;
				}
				
                case "TIME$": {
                    var dt  = date_current_datetime();
                    var hh  = date_get_hour(dt);
                    var mm  = date_get_minute(dt);
                    var ss  = date_get_second(dt);
                    var hhs = (hh < 10 ? "0" : "") + string(hh);
                    var mms = (mm < 10 ? "0" : "") + string(mm);
                    var sss = (ss < 10 ? "0" : "") + string(ss);
                    var out = hhs + ":" + mms + ":" + sss;
                    array_push(stack, out);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: TIME$ → " + out);
                    break;
                }
                case "DATE$": {
                    var dt2 = date_current_datetime();
                    var yy  = date_get_year(dt2);
                    var mo  = date_get_month(dt2);
                    var dd  = date_get_day(dt2);
                    var mos = (mo < 10 ? "0" : "") + string(mo);
                    var dds = (dd < 10 ? "0" : "") + string(dd);
                    var out2 = string(yy) + "-" + mos + "-" + dds;
                    array_push(stack, out2);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: DATE$ → " + out2);
                    break;
                }

                case "INKEY$": {
                    if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: Processing INKEY$ token");

                    if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
                        if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: creating global.inkey_queue");
                        global.inkey_queue = ds_queue_create();
                    }

                    var _res = "";
                    if (ds_queue_size(global.inkey_queue) > 0) {
                        var _ch = ds_queue_dequeue(global.inkey_queue);
                        if (is_real(_ch)) _ch = chr(_ch);
                        _res = string(_ch);
                        if (dbg_on(DBG_PARSE)) show_debug_message(
                            "INKEY$ function: Dequeued '" + _res + "', queue size now = " + string(ds_queue_size(global.inkey_queue))
                        );
                    } else {
                        if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: Queue empty → returning empty string");
                    }

                    if (dbg_on(DBG_PARSE)) {
                        var _len = string_length(_res);
                        var _a1  = (_len >= 1) ? ord(string_char_at(_res, 1)) : -1;
                        var _a2  = (_len >= 2) ? ord(string_char_at(_res, 2)) : -1;
                        if (dbg_on(DBG_FLOW)) show_debug_message("##INK## LEN=" + string(_len)
                            + " A1=" + string(_a1)
                            + " A2=" + string(_a2)
                            + " K$='" + _res + "'");
                    }

                    array_push(stack, _res);
                    break;
                }

                // ---- Math
                case "ABS": array_push(stack, abs(safe_real_pop(stack))); break;
                case "EXP": array_push(stack, exp(safe_real_pop(stack))); break;

                // Preserving your prior semantics: LOG & LOG10 both as base-10
                case "LOG":
                case "LOG10": {
                    var v = safe_real_pop(stack);
                    array_push(stack, (ln(v) / ln(10)));
                    break;
                }

                case "SGN": {
                    var vsgn = safe_real_pop(stack);
                    var sgnv = (vsgn > 0) - (vsgn < 0);
                    array_push(stack, sgnv);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: SGN(" + string(vsgn) + ") → " + string(sgnv));
                    break;
                }

                case "INT": array_push(stack, floor(safe_real_pop(stack))); break;
                case "SIN": array_push(stack, sin(safe_real_pop(stack)));   break;
                case "COS": array_push(stack, cos(safe_real_pop(stack)));   break;
                case "TAN": array_push(stack, tan(safe_real_pop(stack)));   break;

                // ---- String conversions
                case "STR$": {
                    var vstr = safe_real_pop(stack);
                    var s = string(vstr);
                    array_push(stack, s);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: STR$ → " + s);
                    break;
                }
				
                case "CHR$": {
                    var cv = safe_real_pop(stack);
                    var c  = chr(cv);
                    array_push(stack, c);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: CHR$ → " + c);
                    break;
                }

                // ---- String functions we added
                case "REPEAT$": {
                    var nrep = floor(safe_real_pop(stack));
                    var srep = string(array_pop(stack));
                    if (nrep < 0) nrep = 0;

                    var max_out = 65535;
                    var unit = max(1, string_length(srep));
                    if (unit * nrep > max_out) nrep = floor(max_out / unit);

                    var outrep = "";
                    repeat (nrep) outrep += srep;
                    array_push(stack, outrep);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: REPEAT$('"+srep+"', "+string(nrep)+") → len="+string(string_length(outrep)));
                    break;
                }

                case "LEFT$": {
                    var nleft = floor(safe_real_pop(stack));
                    var sleft = string(array_pop(stack));
                    if (nleft < 0) nleft = 0;

                    var outleft = (nleft <= 0) ? "" : string_copy(sleft, 1, nleft);
                    array_push(stack, outleft);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: LEFT$('"+sleft+"', "+string(nleft)+") → '"+outleft+"'");
                    break;
                }

                case "RIGHT$": {
                    var nright = floor(safe_real_pop(stack));
                    var sright = string(array_pop(stack));
                    if (nright < 0) nright = 0;

                    var lenr = string_length(sright);
                    var start = max(1, lenr - nright + 1);
                    var outright = (nright <= 0) ? "" : string_copy(sright, start, nright);
                    array_push(stack, outright);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RIGHT$('"+sright+"', "+string(nright)+") → '"+outright+"'");
                    break;
                }

                case "MID$": {
                    var lmid = floor(safe_real_pop(stack));
                    var smid = floor(safe_real_pop(stack));
                    var strm = string(array_pop(stack));

                    if (lmid < 0) lmid = 0;
                    if (smid < 1) smid = 1;

                    var outm = "";
                    if (lmid > 0 && smid <= string_length(strm)) {
                        outm = string_copy(strm, smid, lmid);
                    }
                    array_push(stack, outm);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: MID$('"+strm+"', "+string(smid)+", "+string(lmid)+") → '"+outm+"'");
                    break;
                }

                case "ASC": {
                    var s = string(array_pop(stack));            // ensure string
                    var r = (string_length(s) >= 1) ? ord(string_char_at(s, 1)) : 0;
                    array_push(stack, r);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: ASC('" + s + "') → " + string(r));
                    break;
                }

                // ---- NEW: STRING$(x, n) ----
                case "STRING$": {
                    // Postfix order from infix handler: push x, push n, then STRING$
                    var n = array_pop(stack);
                    var _x = array_pop(stack);

                    // normalize n
                    var count = max(0, floor(is_real(n) ? n : real(n)));

                    // determine a single character from _x
                    var ch;
                    if (is_string(_x)) {
                        ch = (string_length(_x) > 0) ? string_copy(_x, 1, 1) : " ";
                    } else {
                        var code = clamp(floor(real(_x)), 0, 255);
                        ch = chr(code);
                    }

                    var out = "";
                    repeat (count) out += ch;

                    array_push(stack, out);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: STRING$(" + string(x) + "," + string(count) + ") → len=" + string(string_length(out)));
                    break;
                }

			


                default:
                    if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX WARNING: Unknown function = " + token_upper + " — pushing last real as fallback");
                    array_push(stack, safe_real_pop(stack));
                    break;
            }

            continue;
        }

			// -------------------------------------------------------
			// Scalar variable load (string vars stay strings; numeric vars coerce)
			// -------------------------------------------------------
			if (ds_map_exists(global.basic_variables, token_upper)) {
			    var vv = global.basic_variables[? token_upper];

			    var is_string_var = (string_char_at(token_upper, string_length(token_upper)) == "$");

			    if (is_string_var) {
			        // String variables ALWAYS behave as strings (QBASIC semantics)
			        if (is_undefined(vv)) vv = "";
			        vv = string(vv); // ensure string; do not numeric-coerce
			    } else {
			        // Numeric variables: allow numeric strings, else 0
			        if (is_string(vv)) {
			            vv = is_numeric_string(vv) ? real(vv) : 0;
			        } else if (!is_real(vv)) {
			            vv = 0;
			        }
			    }

			    array_push(stack, vv);

			    if (dbg_on(DBG_PARSE)) {
			        var _tag = is_string_var ? "[S]" : "[N]";
			        show_debug_message("POSTFIX: Loaded variable " + token_upper + " " + _tag + " = " + string(vv));
			    }
			    continue;
			}


       // -------------------------------------------------------
		// Fallback: IDENT or literal
		// -------------------------------------------------------
		var ident = trimmed;

		// If this looks like an identifier (A..Z start) and it’s not in the map,
		// treat it as an undeclared numeric variable (default 0).
		var first = string_upper(string_char_at(ident, 1));
		var oc = ord(first);
		var looks_ident = (oc >= 65 && oc <= 90); // A..Z

		if (looks_ident) {
		    var key = string_upper(ident);
		    if (!ds_map_exists(global.basic_variables, key)) {
		        // create as numeric 0 (QBASIC style)
		        global.basic_variables[? key] = 0;
		        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Implicit numeric var created '" + key + "' = 0");
		    }
		    var vv = global.basic_variables[? key];

		    // coerce type by suffix: $ means string var
		    if (string_char_at(key, string_length(key)) == "$") {
		        if (is_undefined(vv)) vv = "";
		        if (!is_string(vv))  vv = string(vv);
		    } else {
		        if (is_string(vv)) {
		            vv = is_numeric_string(vv) ? real(vv) : 0;
		        } else if (!is_real(vv)) {
		            vv = 0;
		        }
		    }
		    array_push(stack, vv);
		    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Loaded/created ident " + key + " = " + string(vv));
		} else {
		    // true literal fallback
		    array_push(stack, trimmed);
		    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed fallback string → " + trimmed);
		}

    }

    return (array_length(stack) > 0) ? stack[array_length(stack) - 1] : 0;
}

/// @file objects/obj_screen_editor/Step_0.gml
/// @event Step
/// Final corrected horizontal scrolling implementation

// Handle ESC key - exit screen editor
if (keyboard_check_pressed(vk_escape)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: ESC pressed - exiting");
    screen_editor_exit(id);
    exit;
}

// Initialize line_modified flag if it doesn't exist
if (!variable_instance_exists(id, "line_modified")) {
    line_modified = false;
}

// Initialize key repeat timer for smoother arrow key movement
if (!variable_instance_exists(id, "arrow_repeat_timer")) {
    arrow_repeat_timer = 0;
}

// Handle cursor movement with horizontal scrolling
if (keyboard_check(vk_left)) {
    if (arrow_repeat_timer <= 0) {
        if (cursor_x > 0) {
            cursor_x--;
        } else if (horizontal_offset > 0) {
            // At left edge of screen, scroll left
            horizontal_offset--;
            screen_editor_load_program(id);
            if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled left - new h_offset=" + string(horizontal_offset));
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cursor left to (" + string(cursor_x) + "," + string(cursor_y) + "), h_offset=" + string(horizontal_offset));
        arrow_repeat_timer = 4; // 4-frame delay between movements
    }
}

if (keyboard_check(vk_right)) {
    if (arrow_repeat_timer <= 0) {
        // Get the FULL line content directly from program storage, not from screen buffer
        var line_index = cursor_y + scroll_offset;
        var full_line_text = "";
        
        if (line_index < ds_list_size(global.line_numbers)) {
            var line_num = ds_list_find_value(global.line_numbers, line_index);
            var code = ds_map_find_value(global.program_lines, line_num);
            full_line_text = string(line_num) + " " + code;
        }
        
        var actual_cursor_pos = cursor_x + horizontal_offset;
        var full_line_length = string_length(full_line_text);
        
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Right arrow - cursor_x=" + string(cursor_x) + ", h_offset=" + string(horizontal_offset) + ", actual_pos=" + string(actual_cursor_pos) + ", full_line_len=" + string(full_line_length));
        
        // Allow scrolling through the entire line content
        if (actual_cursor_pos < full_line_length && actual_cursor_pos < 200) {
            if (cursor_x < 79) {  // Use 79 for your 80-character screen
                cursor_x++;
            } else {
                // At right edge of screen, scroll right
                horizontal_offset++;
                screen_editor_load_program(id);
                if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled right - new h_offset=" + string(horizontal_offset));
            }
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: After right - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), h_offset=" + string(horizontal_offset));
        arrow_repeat_timer = 4; // 4-frame delay between movements
    }
}

// Decrement the arrow key repeat timer
if (arrow_repeat_timer > 0) {
    arrow_repeat_timer--;
}

if (keyboard_check_pressed(vk_up)) {
    // If current line was modified, commit it first
    if (line_modified) {
        screen_editor_commit_row(id, cursor_y);
        line_modified = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Auto-committed modified line before moving up");
    }
    
    // Store the desired horizontal position
    var desired_x = cursor_x + horizontal_offset;
    
    // Clear ALL keyboard input to prevent character leakage
    keyboard_string = "";
    keyboard_lastchar = "";
    keyboard_lastkey = 0;
    
    // Reset horizontal scrolling - always show left edge of new line
    horizontal_offset = 0;
    
    if (cursor_y > 0) {
        cursor_y--;
    } else if (scroll_offset > 0) {
        scroll_offset--;
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled up - scroll_offset=" + string(scroll_offset));
    }
    
    // Smart cursor positioning for new line
    var new_line_text = screen_editor_get_row_text(id, cursor_y);
    var new_line_length = string_length(new_line_text);
    var target_pos = min(desired_x, new_line_length);
    cursor_x = min(target_pos, 79);
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Up - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), cleared input");
}

if (keyboard_check_pressed(vk_down)) {
    // If current line was modified, commit it first
    if (line_modified) {
        screen_editor_commit_row(id, cursor_y);
        line_modified = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Auto-committed modified line before moving down");
    }
    
    // Store the desired horizontal position
    var desired_x = cursor_x + horizontal_offset;
    
    // Clear ALL keyboard input to prevent character leakage
    keyboard_string = "";
    keyboard_lastchar = "";
    keyboard_lastkey = 0;
    
    // Reset horizontal scrolling - always show left edge of new line
    horizontal_offset = 0;
    
    var total_lines = ds_list_size(global.line_numbers);
    var visible_lines = min(screen_rows, total_lines - scroll_offset);
    
    if (cursor_y < visible_lines - 1 && cursor_y < screen_rows - 1) {
        cursor_y++;
    } else if (scroll_offset + screen_rows < total_lines) {
        scroll_offset++;
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled down - scroll_offset=" + string(scroll_offset));
    }
    
    // Smart cursor positioning for new line
    var new_line_text = screen_editor_get_row_text(id, cursor_y);
    var new_line_length = string_length(new_line_text);
    var target_pos = min(desired_x, new_line_length);
    cursor_x = min(target_pos, 79);
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Down - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), cleared input");
}

// Handle Page Up/Down
if (keyboard_check_pressed(vk_pageup)) {
    var old_offset = scroll_offset;
    scroll_offset = max(0, scroll_offset - screen_rows);
    if (scroll_offset != old_offset) {
        horizontal_offset = 0;
        cursor_x = min(cursor_x, 79);
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Page Up - scroll_offset " + string(old_offset) + " -> " + string(scroll_offset));
    }
}

if (keyboard_check_pressed(vk_pagedown)) {
    var old_offset = scroll_offset;
    var total_lines = ds_list_size(global.line_numbers);
    scroll_offset = min(max(0, total_lines - screen_rows), scroll_offset + screen_rows);
    if (scroll_offset != old_offset) {
        horizontal_offset = 0;
        cursor_x = min(cursor_x, 79);
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Page Down - scroll_offset " + string(old_offset) + " -> " + string(scroll_offset));
    }
}

// Home/End key support
if (keyboard_check_pressed(vk_home)) {
    cursor_x = 0;
    horizontal_offset = 0;
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Home pressed - jump to beginning");
}

if (keyboard_check_pressed(vk_end)) {
    var current_line_text = screen_editor_get_row_text(id, cursor_y);
    var line_length = string_length(current_line_text);
    
    if (line_length <= 80) {
        // Line fits on screen
        cursor_x = line_length;
        horizontal_offset = 0;
    } else {
        // Line is longer - scroll to show the end
        horizontal_offset = line_length - 80;
        cursor_x = 79;
    }
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: End pressed - jump to end, cursor=" + string(cursor_x) + ", h_offset=" + string(horizontal_offset));
}


// Character input
if (keyboard_check_pressed(vk_anykey)) {
    var k  = keyboard_lastkey;
    var ch = keyboard_lastchar;

    // Is this a printable keystroke (not pure modifier / not control)?
    var _is_printable =
        (k != vk_shift && k != vk_control && k != vk_alt) &&
        (!is_undefined(ch)) && (ch != "") && (ord(ch) >= 32);

    // CRITICAL: Ignore arrow keys and other navigation keys to prevent interference
    var _is_nav =
        keyboard_check(vk_left) || keyboard_check(vk_right) ||
        keyboard_check(vk_up)   || keyboard_check(vk_down)  ||
        keyboard_check_pressed(vk_left) || keyboard_check_pressed(vk_right) ||
        keyboard_check_pressed(vk_up)   || keyboard_check_pressed(vk_down)  ||
        keyboard_check_pressed(vk_home) || keyboard_check_pressed(vk_end)   ||
        keyboard_check_pressed(vk_pageup) || keyboard_check_pressed(vk_pagedown) ||
        keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_backspace) ||
        keyboard_check_pressed(vk_escape);

    // Only run the INSERT path for printable, non-nav keys.
    if (_is_printable && !_is_nav) {

        if (string_length(ch) == 1) {
            var ascii_code = ord(ch);
            if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Key pressed - char '" + ch + "', ASCII " + string(ascii_code));

            if (ascii_code >= 32 && ascii_code <= 126) {
                var current_line_text = screen_editor_get_row_text(id, cursor_y);
                var actual_cursor_pos = cursor_x + horizontal_offset;

                // Preserve intentional trailing spaces up to cursor (since get_row_text trims)
                if (string_length(current_line_text) < actual_cursor_pos) {
                    var pad = actual_cursor_pos - string_length(current_line_text);
                    repeat (pad) { current_line_text += " "; }
                }

                if (string_length(current_line_text) < 200) {
                    // Insert character at actual position
                    var before_cursor = string_copy(current_line_text, 1, actual_cursor_pos);
                    var after_cursor  = string_copy(current_line_text, actual_cursor_pos + 1, string_length(current_line_text));
                    var new_line      = before_cursor + ch + after_cursor;

                    // Update the actual BASIC program line
                    var line_index = cursor_y + scroll_offset;
                    if (line_index < ds_list_size(global.line_numbers)) {
                        var line_num  = ds_list_find_value(global.line_numbers, line_index);
                        var space_pos = string_pos(" ", new_line);
                        if (space_pos > 0) {
                            var code_part = string_copy(new_line, space_pos + 1, string_length(new_line));
                            ds_map_set(global.program_lines, line_num, code_part);
                        }
                    }

                    // Mark line as modified
                    line_modified = true;

                    // Advance cursor
                    if (cursor_x < 79) {
                        cursor_x++;
                    } else {
                        horizontal_offset++;
                    }

                    screen_editor_load_program(id);
                    // keep the live edit visible even if this is a not-yet-committed/new line
                    screen_editor_display_line(id, new_line, cursor_y);

                } else {
                    basic_show_message("Line too long (max 200 chars)");
                }
            }
        }
    }
    // IMPORTANT: do not exit here — lets Enter/Backspace handlers run later in Step
}



// Backspace
if (keyboard_check_pressed(vk_backspace)) {
    var current_line_text = screen_editor_get_row_text(id, cursor_y);
    var actual_cursor_pos = cursor_x + horizontal_offset;
	
	// ADD this padding block (so backspace can delete spaces you just typed):
	if (string_length(current_line_text) < actual_cursor_pos) {
	    var pad = actual_cursor_pos - string_length(current_line_text);
	    repeat (pad) { current_line_text += " "; }
	}
    
    if (actual_cursor_pos > 0) {
        // Delete character
        var before_cursor = string_copy(current_line_text, 1, actual_cursor_pos - 1);
        var after_cursor = string_copy(current_line_text, actual_cursor_pos + 1, string_length(current_line_text));
        var new_line = before_cursor + after_cursor;
        
        // Update program line
        var line_index = cursor_y + scroll_offset;
        if (line_index < ds_list_size(global.line_numbers)) {
            var line_num = ds_list_find_value(global.line_numbers, line_index);
            var space_pos = string_pos(" ", new_line);
            if (space_pos > 0) {
                var code_part = string_copy(new_line, space_pos + 1, string_length(new_line));
                ds_map_set(global.program_lines, line_num, code_part);
            }
        }
        
        // Mark line as modified
        line_modified = true;
        
        // Move cursor back
        if (cursor_x > 0) {
            cursor_x--;
        } else if (horizontal_offset > 0) {
            horizontal_offset--;
        }
        
        screen_editor_load_program(id);
		
		// re-assert the edited row on screen after the reload
		screen_editor_display_line(id, new_line, cursor_y);
    }
}

// Enter key
if (keyboard_check_pressed(vk_enter)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Enter pressed - committing row " + string(cursor_y));
    screen_editor_commit_row(id, cursor_y);
    
    horizontal_offset = 0;
    cursor_x = 0;
    
    screen_editor_load_program(id);
    
    if (cursor_y < screen_rows - 1) {
        cursor_y++;
    }
}

// Cursor blink
blink_timer++;
if (blink_timer >= 30) {
    cursor_visible = !cursor_visible;
    blink_timer = 0;
}
function basic_evaluate_condition(expr) {
    var s = string_trim(expr);
    if (dbg_on(DBG_FLOW)) show_debug_message ("COND: Begin evaluate_condition → '" + s + "'");

    // ===== boolean precedence: OR (low) then AND (high) =====
    {
        var su = string_upper(s);
        var L  = string_length(su);
        var _depth = 0;
        var in_q  = false;

        // ---- Top-level OR ----
        for (var i = 1; i <= L - 1; i++) {
            var ch = string_char_at(su, i);
            if (ch == "\"") { in_q = !in_q; continue; }
            if (in_q) continue;

            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (_depth != 0) continue;

            if (string_copy(su, i, 2) == "OR") {
                // require space boundaries (avoid COLOR etc.)
                var prev = (i == 1) ? " " : string_char_at(su, i - 1);
                var next = (i + 2 <= L) ? string_char_at(su, i + 2) : " ";
                if (prev == " " && next == " ") {
                    var left  = string_trim(string_copy(s, 1, i - 1));
                    var right = string_trim(string_copy(s, i + 2, L - (i + 2) + 1));
                    if (dbg_on(DBG_FLOW)) show_debug_message ("COND: top-level OR split → LHS='" + left + "'  ||  RHS='" + right + "'");

                    var lres = basic_evaluate_condition(left);
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: OR left result = " + string(lres));
                    if (lres) { 
						if (dbg_on(DBG_FLOW)) {show_debug_message("COND: OR short-circuit TRUE");}
					return true; }

                    var rres = basic_evaluate_condition(right);
                    var ores = (lres || rres);
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: OR final = " + string(ores));
                    return ores;
                }
            }
        }

        // ---- Top-level AND ----
        _depth = 0; in_q = false;  // FIX: use _depth, not 'depth'
        for (var j = 1; j <= L - 2; j++) {
            var ch2 = string_char_at(su, j);
            if (ch2 == "\"") { in_q = !in_q; continue; }
            if (in_q) continue;

            if (ch2 == "(") { _depth++; continue; }
            if (ch2 == ")") { _depth = max(0, _depth - 1); continue; }
            if (_depth != 0) continue;

            if (string_copy(su, j, 3) == "AND") {
                var prev2 = (j == 1) ? " " : string_char_at(su, j - 1);
                var next2 = (j + 3 <= L) ? string_char_at(su, j + 3) : " ";
                if (prev2 == " " && next2 == " ") {
                    var left2  = string_trim(string_copy(s, 1, j - 1));
                    var right2 = string_trim(string_copy(s, j + 3, L - (j + 3) + 1));
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: top-level AND split → LHS='" + left2 + "'  &&  RHS='" + right2 + "'");

                    var lres2 = basic_evaluate_condition(left2);
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: AND left result = " + string(lres2));
                    if (!lres2) { if (dbg_on(DBG_FLOW)) show_debug_message("COND: AND short-circuit FALSE"); return false; }

                    var rres2 = basic_evaluate_condition(right2);
                    var andres = (lres2 && rres2);
                    if (dbg_on(DBG_FLOW)) show_debug_message("Combined condition (AND): " + string(lres2) + " AND " + string(rres2) + " = " + string(andres));
                    return andres;
                }
            }
        }
    }
    // ===== END boolean handling =====

    // --- Comparator search (unchanged) ---
    var ops = ["<>", "<=", ">=", "=", "<", ">"];
    var found_op = "";
    var op_pos = 0;
    var _depth = 0;

    for (var i2 = 1; i2 <= string_length(s); i2++) {
        var ch3 = string_char_at(s, i2);
        if (ch3 == "(") { _depth++; continue; }
        if (ch3 == ")") { _depth--; continue; }
        if (_depth != 0) continue;

        if (i2 < string_length(s)) {
            var two = string_copy(s, i2, 2);
            if (two == "<>" || two == "<=" || two == ">=") {
                found_op = two; op_pos = i2;
                if (dbg_on(DBG_FLOW)) show_debug_message("COND: Found 2-char op '" + found_op + "' at pos " + string(op_pos));
                break;
            }
        }
        if (ch3 == "=" || ch3 == "<" || ch3 == ">") {
            found_op = ch3; op_pos = i2;
            if (dbg_on(DBG_FLOW)) show_debug_message("COND: Found 1-char op '" + found_op + "' at pos " + string(op_pos));
            break;
        }
    }

    if (found_op != "") {
        var lhs = string_trim(string_copy(s, 1, op_pos - 1));
        var rhs = string_trim(string_copy(s, op_pos + string_length(found_op), string_length(s) - (op_pos + string_length(found_op) - 1)));
        var op  = found_op;

        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Split → LHS='" + lhs + "'  OP='" + op + "'  RHS='" + rhs + "'");

        var lhs_val = basic_evaluate_expression_v2(lhs);
        var rhs_val = basic_evaluate_expression_v2(rhs);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Eval → LHS=" + string(lhs_val) + "  RHS=" + string(rhs_val));

        var lhs_str = string(lhs_val);
        var rhs_str = string(rhs_val);
        var lhs_is_num = is_real(lhs_val) || is_numeric_string(lhs_str);
        var rhs_is_num = is_real(rhs_val) || is_numeric_string(rhs_str);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Types → LHS_is_num=" + string(lhs_is_num) + "  RHS_is_num=" + string(rhs_is_num));

        if (!(lhs_is_num && rhs_is_num)) {
            var sres = false;
            switch (op) {
                case "=":  sres = (lhs_str == rhs_str); break;
                case "<>": sres = (lhs_str != rhs_str); break;
                default:   sres = false;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("COND: String-compare '" + op + "' → " + string(sres));
            return sres;
        }

        var lhs_num = real(lhs_str);
        var rhs_num = real(rhs_str);
        var nres = false;
        switch (op) {
            case "=":  nres = (lhs_num == rhs_num); break;
            case "<":  nres = (lhs_num <  rhs_num); break;
            case ">":  nres = (lhs_num >  rhs_num); break;
            case "<=": nres = (lhs_num <= rhs_num); break;
            case ">=": nres = (lhs_num >= rhs_num); break;
            case "<>": nres = (lhs_num != rhs_num); break;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Numeric-compare '" + op + "' → " + string(nres));
        return nres;
    }

    // --- Legacy space-split path (kept) ---
    var tokens = string_split(s, " ");
    if (array_length(tokens) == 3) {
        var lhs2 = string_trim(tokens[0]);
        var op2  = string_trim(tokens[1]);
        var rhs2 = string_trim(tokens[2]);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback (space-split) → LHS='" + lhs2 + "' OP='" + op2 + "' RHS='" + rhs2 + "'");

        var lhs_val2 = basic_evaluate_expression_v2(lhs2);
        var rhs_val2 = basic_evaluate_expression_v2(rhs2);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback eval → LHS=" + string(lhs_val2) + "  RHS=" + string(rhs_val2));

        var lhs_str2 = string(lhs_val2);
        var rhs_str2 = string(rhs_val2);
        var lhs_is_num2 = is_real(lhs_val2) || is_numeric_string(lhs_str2);
        var rhs_is_num2 = is_real(rhs_val2) || is_numeric_string(rhs_str2);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback types → LHS_is_num=" + string(lhs_is_num2) + "  RHS_is_num=" + string(rhs_is_num2));

        if (!(lhs_is_num2 && rhs_is_num2)) {
            var sres2 = false;
            switch (op2) {
                case "=":  sres2 = (lhs_str2 == rhs_str2); break;
                case "<>": sres2 = (lhs_str2 != rhs_str2); break;
                default:   sres2 = false;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback string-compare '" + op2 + "' → " + string(sres2));
            return sres2;
        }

        var lhs_num2 = real(lhs_str2);
        var rhs_num2 = real(rhs_str2);
        var nres2 = false;
        switch (op2) {
            case "=":  nres2 = (lhs_num2 == rhs_num2); break;
            case "<":  nres2 = (lhs_num2 <  rhs_num2); break;
            case ">":  nres2 = (lhs_num2 >  rhs_num2); break;
            case "<=": nres2 = (lhs_num2 <= rhs_num2); break;
            case ">=": nres2 = (lhs_num2 >= rhs_num2); break;
            case "<>": nres2 = (lhs_num2 != rhs_num2); break;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback numeric-compare '" + op2 + "' → " + string(nres2));
        return nres2;
    }

    // --- NEW: final fallback — evaluate whole expression as truthy/falsey ---
    if (dbg_on(DBG_FLOW)) show_debug_message("COND: No operator; evaluating whole expression for truthiness");
    var _val = basic_evaluate_expression_v2(s);
    var _truth = 0;
    if (is_real(_val) || is_numeric_string(string(_val))) {
        _truth = (real(string(_val)) != 0);
    } else {
        var _s = string(_val);
        _truth = (string_length(_s) > 0);
    }
    if (dbg_on(DBG_FLOW)) show_debug_message("COND: expression value=" + string(_val) + " → truth=" + string(_truth));
    return _truth;
}

/// @script dbg_macros.gml
#macro DBG_PARSE  1     // tokenizer, parser, DIM/LET parsing
#macro DBG_EVAL   2     // postfix eval, expression values
#macro DBG_FLOW   4     // IF/WHILE/GOTO/GOSUB flow
#macro DBG_IO     8     // INPUT/PRINT/UI prompts
#macro DBG_ARRAY  16    // array get/set, DIM
#macro DBG_PERF   32    // performance
#macro DBG_STEP   64    // Execution
#macro DBG_EXEC   128	// EXEC
#macro DBG_ALL    0x7fffffff

/*
DEBUG MASKING — HOW TO USE (READ THIS FIRST)
============================================

## WHAT THIS FILE IS

These `#macro` lines define **compile-time constants** used to *categorize* your
debug logs. They are simple bit flags (1, 2, 4, …) that you OR together to
decide which kinds of messages should print at runtime.

```
#macro DBG_PARSE  1     // tokenizer & parser chatter
#macro DBG_EVAL   2     // postfix evaluation & expression results
#macro DBG_FLOW   4     // IF/WHILE/WEND/GOTO/GOSUB decisions
#macro DBG_IO     8     // INPUT/PRINT/UI prompts & commits
#macro DBG_ARRAY  16    // DIM + array get/set + bounds logs
#macro DBG_ALL    0x7fffffff  // convenience: everything on
```

> IMPORTANT: Macros must live at **top level** (not inside a function). Keep
> this file as-is; don’t wrap these lines in a function.

## REQUIRED COMPANION (dbg.gml)

You also have two helper functions defined in `dbg.gml`:

```
function dbg_on(cat) -> bool
    // Returns TRUE if the category bit is enabled in global.debug_mask.
    // Very cheap; use around *occasional* logs.

function dbg(cat, msg) -> void
    // Prints a message if the category bit is enabled AND you haven’t
    // exceeded the per-frame quota. Use inside tight loops to avoid FPS hits.
```

Both helpers rely on these globals, which you should initialize once in your
interpreter’s Create/Init event:

```
if (!variable_global_exists("debug_mask")) {
    global.debug_mask        = DBG_ALL;   // start verbose; tune later
    global.dbg_frame_quota   = 1200;      // max logs per frame before dropping
    global.dbg_frame_count   = 0;         // internal counter (do not set manually)
    global.dbg_dropped_count = 0;         // internal counter (do not set manually)
}
```

And reset the quota each frame (Step Start of the interpreter object):

```
global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}
```

## HOW TO WRAP EXISTING LOGS

You have hundreds of `show_debug_message(...)` calls. Wrap them gradually:

• High-volume / in loops (tokenizer, postfix, array hot-paths) → **use `dbg()`**
This enforces the per-frame quota automatically.
BEFORE:
show\_debug\_message("TOKENIZER: Char\[" + string(i) + "]='" + c + "'");
AFTER:
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "]='" + c + "'");

• Low-volume / occasional (flow decisions, one-off prints) → **use `dbg_on()`**
This is a tiny mask check; then you call `show_debug_message` yourself.
BEFORE:
show\_debug\_message("WEND: Condition is TRUE — looping");
AFTER:
if (dbg\_on(DBG\_FLOW)) show\_debug\_message("WEND: Condition is TRUE — looping");

Tip: It’s fine to mix both styles. Prefer `dbg()` anywhere that can spam.

## WHAT EACH MASK MEANS (AND WHERE TO USE IT)

• DBG\_PARSE
Use on: tokenizer (`basic_tokenize_expression_v2`), parser/splitters,
command lexing (verb/arg extraction).
Goal: see how text becomes tokens. No evaluation yet.

• DBG\_EVAL
Use on: postfix creation/evaluation, math/operator application, variable loads.
Goal: see stack pushes/pops and numeric/string results.

• DBG\_FLOW
Use on: `basic_cmd_if/_if_inline`, `basic_cmd_while`, `basic_cmd_wend`,
loop stack push/pop, `GOTO/GOSUB/RETURN` target resolution.
Goal: follow control flow decisions and jumps.

• DBG\_IO
Use on: `basic_cmd_input`, `basic_cmd_print`, wrapping/commit pipeline,
prompt emission, input state flips.
Goal: ensure prompts and outputs render and input mode is toggled correctly.

• DBG\_ARRAY
Use on: `basic_cmd_dim`, `basic_array_get`, `basic_array_set`, bounds checks.
Goal: track sizes, indices, auto-grow, and OOB warnings.

• DBG\_ALL
Convenience macro: enable all categories at once.

## HOW TO TURN CATEGORIES ON/OFF

At runtime (debugger Watch window, a script, or once in Create):

```
// All off:
global.debug_mask = 0;

// Only FLOW:
global.debug_mask = DBG_FLOW;

// Only IO:
global.debug_mask = DBG_IO;

// FLOW + IO together:
global.debug_mask = DBG_FLOW | DBG_IO;

// Everything on:
global.debug_mask = DBG_ALL;
```

You can also toggle bits on the fly:

```
// Flip the PARSE bit:
global.debug_mask ^= DBG_PARSE;
```

If you temporarily cranked the quota for a heavy trace, put it back:

```
global.dbg_frame_quota = 1200;    // typical safe value
// (set larger, e.g., 100000, if you want to capture *everything* for a short run)
```

## OPTIONAL: QUICK HOTKEY TO CYCLE VERBOSITY

Add this to the interpreter object’s Step (or Step Begin):

```
if (keyboard_check_pressed(vk_f9)) {
    var next = (global.debug_mask == 0)
        ? (DBG_FLOW | DBG_IO)   // useful day-to-day
        : (global.debug_mask == (DBG_FLOW | DBG_IO) ? DBG_ALL : 0);
    global.debug_mask = next;
    show_debug_message("DBG: mask now = " + string(next));
}
```

## COMMON PITFALLS & TIPS

• Macros not recognized → Ensure this file (`dbg_macros.gml`) is a separate
script asset with **only** the `#macro` lines at top level. If you still see
“variable not defined” on a macro name, **Clean** the project and rebuild.

• Compile order → Place `dbg_macros.gml` near the top of your Scripts folder so
everything else sees it. (Macros are compile-time, but ordering can trip
partial rebuilds.)

• Use `dbg()` for anything inside loops; it’s quota-aware. If you use
`dbg_on()` + `show_debug_message(...)` in a hot loop you can still tank FPS.

• Migration strategy → You don’t need to wrap everything at once. Start with:
tokenizer (DBG\_PARSE), evaluation (DBG\_EVAL), flow (DBG\_FLOW). That usually
kills 90% of the spam while keeping the most actionable signal.

## EXAMPLES (COPY/PASTE)

Tokenizer char echo (quota-aware):
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "] = '" + string\_char\_at(s, i) + "'");

Flow decision:
if (dbg\_on(DBG\_FLOW))
show\_debug\_message("IF: result=" + string(result) + " → " + (result ? "THEN" : "ELSE"));

Input prompt emission:
dbg(DBG\_IO, "INPUT: Prompt='" + rawPrompt + "' → var=" + varName);

Array set:
dbg(DBG\_ARRAY, "ARRAY SET: " + name + "\[" + string(idx) + "] = " + string(val));

## QUICK START

1. Keep these macros here (top level).
2. Ensure `dbg.gml` exists with `dbg_on` and `dbg`.
3. Initialize the globals in Create, reset counters in Step Start.
4. Wrap high-volume logs with `dbg(cat, msg)`, occasional logs with `dbg_on`.
5. Control verbosity by setting `global.debug_mask` at runtime:
   • All off: 0
   • Only FLOW: DBG\_FLOW
   • Only IO: DBG\_IO
   • FLOW + IO: DBG\_FLOW | DBG\_IO
   • Everything: DBG\_ALL
6. If things feel slow, reduce the mask and/or lower `global.dbg_frame_quota`.

That’s it. You keep the power of your detailed logs without drowning the Runner.
*/

/// @event obj_editor/Step
// Pause regular editor when screen editor is active
if (global.screen_edit_mode) {
    //if (dbg_on(DBG_FLOW)) show_debug_message("EDITOR: Screen edit mode active, pausing regular editor");
    exit;
}

if (global.justreturned == 1) {
    current_input = "";
    cursor_pos = 0;
    keyboard_string = "";
    global.justreturned = 0;
    exit; // skip the rest of this Step event
}

// === DIRECTORY OVERLAY INPUT (ASCII) ===
if (showing_dir_overlay) {

    // Close overlay on ESC (unless confirm is up)
    if (!dir_confirm_active && keyboard_check_pressed(vk_escape)) {
        showing_dir_overlay = false;
        dir_listing = [];
        if (dbg_on(DBG_FLOW)) show_debug_message("[DIR] close overlay (ESC)");
        exit;
    }

    // Guard page_size (Draw recalculates each frame)
    if (dir_page_size < 1) dir_page_size = 1;

    var _count = array_length(dir_listing);
    if (_count <= 0) { exit; } // nothing to do

    // Clamp selection to list
    dir_sel = clamp(dir_sel, 0, max(0, _count - 1));

    // If confirm dialog active: handle Y/N only; block other inputs
    if (dir_confirm_active) {
        if (keyboard_check_pressed(ord("Y"))) {
            // Delete (desktop only)
            if (os_type != os_browser) {
                var _name = dir_listing[dir_confirm_index];
                var _path = dir_save_dir + _name;
                if (file_exists(_path)) {
                    if (dbg_on(DBG_IO)) show_debug_message("[DIR] delete " + _path);
                    file_delete(_path);
                }
                // refresh list
                list_saved_programs(); // re-enter overlay with fresh state
            } else {
                if (dbg_on(DBG_IO)) show_debug_message("[DIR] delete disabled on HTML5");
                dir_confirm_active = false;
            }
        }
        if (keyboard_check_pressed(ord("N")) || keyboard_check_pressed(vk_escape)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("[DIR] delete cancelled");
            dir_confirm_active = false;
        }
        exit; // modal consumes input
    }

    // NAVIGATION
    if (keyboard_check_pressed(vk_home))  dir_sel = 0;
    else if (keyboard_check_pressed(vk_end))   dir_sel = max(0, _count - 1);
    else if (keyboard_check_pressed(vk_up))    dir_sel = max(0, dir_sel - 1);
    else if (keyboard_check_pressed(vk_down))  dir_sel = min(_count - 1, dir_sel + 1);
    else if (keyboard_check_pressed(vk_pageup))   dir_sel = max(0, dir_sel - dir_page_size);
    else if (keyboard_check_pressed(vk_pagedown)) dir_sel = min(_count - 1, dir_sel + dir_page_size);

    // ACTIONS
    // Load on ENTER or '>' key
// Load on ENTER or '>' key
if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(ord(">"))) {
    var _name = dir_listing[dir_sel];
    if (_name != "No .bas files found.") {
        // Check if this is an HTML file list (has global.html_dir_files data)
        if (os_browser != browser_not_a_browser && variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > 0) {
            // HTML version - load from memory
            if (dbg_on(DBG_IO)) show_debug_message("[DIR] HTML load: " + _name + " at index " + string(dir_sel + 1));
            var success = editor_html_dir_open(string(dir_sel + 1));
            if (success) {
                showing_dir_overlay = false;
                dir_listing = [];
                global.justreturned = 1;
            } else {
                basic_show_message("Failed to load file from memory");
            }
            exit;
        } else {
            // Windows version - load from disk
            var _path = dir_save_dir + _name;
            if (file_exists(_path)) {
                if (dbg_on(DBG_IO)) show_debug_message("[DIR] load " + _path);
                load_program_from_path(_path, _name);
                showing_dir_overlay = false;
                dir_listing = [];
                global.justreturned = 1;
                exit;
            } else {
                basic_show_message("File not found");
            }
        }
    }
}

    // Delete on 'D', 'X', or Delete key (desktop only)
    if (os_browser != browser_not_a_browser) {
        if (keyboard_check_pressed(ord("D")) || keyboard_check_pressed(ord("X")) || keyboard_check_pressed(vk_delete)) {
            if (_count > 0 && dir_listing[dir_sel] != "No .bas files found.") {
                dir_confirm_active = true;
                dir_confirm_index  = dir_sel;
                if (dbg_on(DBG_FLOW)) show_debug_message("[DIR] confirm delete idx=" + string(dir_sel));
            }
        }
    }

    // NOTE: Do not let base editor input run while overlay is active
    exit;
}





// Handle Enter key
if (keyboard_check_pressed(vk_enter)) {
    add_to_history(current_input);
    process_input_line(current_input);
    current_input = "";
    cursor_pos = 0;
    global.history_index = -1;
    input_buffer = keyboard_string; // reset keyboard buffer
}

 else if (keyboard_check_released(vk_backspace)) {
    if (cursor_pos > 0) {
        current_input = string_delete(current_input, cursor_pos, 1);
        cursor_pos--;
    }
 }
 else if (keyboard_check_pressed(vk_left)) {
    cursor_pos = max(0, cursor_pos - 1);
 }
 else if (keyboard_check_pressed(vk_right)) {
    cursor_pos = min(string_length(current_input), cursor_pos + 1);
 }
 else if (keyboard_check_pressed(vk_up)) {
    navigate_history_up();
 }
 else if (keyboard_check_pressed(vk_down)) {
    navigate_history_down();
 }
 else if (keyboard_check_pressed(vk_pageup)) {
    display_start_line = max(0, display_start_line - lines_per_screen);
 }
 else if (keyboard_check_pressed(vk_pagedown)) {
    var max_start = max(0, ds_list_size(global.line_numbers) - lines_per_screen);
    display_start_line = min(max_start, display_start_line + lines_per_screen);
 }
 else if (keyboard_check(vk_control) && keyboard_check_pressed(ord("Z"))) {
    undo_last_change();
 }
 else if (keyboard_check(vk_f5)) {
    dump_program_to_console();
	basic_show_message("Dumped program to Console");	 
 }
 else {
    // Handle character input with repeat
    handle_character_input();
 }
 
  // In Step Event
 if (message_timer > 0) {
    message_timer--;
    if (message_timer <= 0) {
        message_text = "";
    }
 }
 

/// Build/refresh the in-memory help topics tree
function help_build_topics() {
    // Initialize help_state if it doesn't exist
    if (!variable_global_exists("help_state")) {
        global.help_state = { built: false };
    }
    
    // Initialize or recreate list
    if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }

    // ==== Topics ====
    
    // Topic 1: Editor Commands
    var t1 = { title: "Editor Commands", subs: [] };
    array_push(t1.subs, { 
        title: "RUN / NEW / CLEAR / LIST", 
        lines: [
            "RUN - Execute the current BASIC program.",
            "NEW or CLEAR - Remove all lines from memory.",
            "LIST [start-end] - Show program lines.",
            "F5 - Dump listing to console."
        ]
    });
    array_push(t1.subs, { 
        title: "FILES: SAVE / LOAD / DIR", 
        lines: [
            "SAVE \"name\" - Adds .BAS, writes to Documents/BasicInterpreter.",
            "LOAD \"name\" - Loads program.",
            "DIR - Interactive browser (arrows, Enter, D/X delete, ESC quit)."
        ]
    });
    ds_list_add(global.help_topics, t1);

    // Topic 2: Language Basics
    var t2 = { title: "Language Basics", subs: [] };
    array_push(t2.subs, { 
        title: "Lines, Variables, PRINT", 
        lines: [
            "Lines run in numeric order unless redirected.",
            "Numeric vars: A, X1; Strings: NAME$; Arrays: DIM A(10).",
            "PRINT text or values; ; keeps the cursor on the line."
        ]
    });
    array_push(t2.subs, { 
        title: "INPUT / INKEY$", 
        lines: [
            "INPUT prompts and waits; assigns to variable.",
            "INKEY$ returns last key (\"\" when none).",
            "Extended keys return 2-char sequences."
        ]
    });
    ds_list_add(global.help_topics, t2);

    // Topic 3: Control Flow
    var t3 = { title: "Control Flow", subs: [] };
    array_push(t3.subs, { 
        title: "IF / ELSE / ENDIF", 
        lines: [
            "Inline IF: IF X=1 THEN PRINT \"HI\"",
            "Block IF ... ELSE ... ENDIF is supported."
        ]
    });
    array_push(t3.subs, { 
        title: "FOR / NEXT, WHILE / WEND", 
        lines: [
            "FOR I=1 TO 10 [STEP S] ... NEXT",
            "WHILE condition ... WEND"
        ]
    });
    ds_list_add(global.help_topics, t3);

    // Topic 4: MODE 1 (Tile) Basics
    var t4 = { title: "MODE 1 (Tile) Basics", subs: [] };
    array_push(t4.subs, { 
        title: "PRINTAT / CHARAT / PSET", 
        lines: [
            "PRINTAT x,y,\"TEXT\"[,FG,BG]",
            "CHARAT x,y,code[,FG,BG] places a tile/char.",
            "PSET x,y,code[,FG,BG,BG] shorthand."
        ]
    });
    // Topic 5: Math & Random
    var t5 = { title: "Math & Random", subs: [] };
    array_push(t5.subs, { 
        title: "Math Functions", 
        lines: [
            "ABS, INT, SGN, EXP, LOG, LOG10",
            "SIN, COS, TAN (work in radians)",
            "^ for exponentiation",
            "Standard operator precedence"
        ]
    });
    array_push(t5.subs, { 
        title: "Random Numbers", 
        lines: [
            "RND(6) returns 1 to 6",
            "RND(1,10) returns range 1 to 10", 
            "RND or RND(1) returns 0 to 1"
        ]
    });
    ds_list_add(global.help_topics, t5);

    // Topic 6: Strings
    var t6 = { title: "Strings", subs: [] };
    array_push(t6.subs, { 
        title: "String Functions", 
        lines: [
            "LEFT$, RIGHT$, MID$ for substrings",
            "LEN for string length",
            "CHR$(65) converts to \"A\"",
            "ASC(\"A\") converts to 65"
        ]
    });
    ds_list_add(global.help_topics, t6);

    // Topic 7: Data & Arrays  
    var t7 = { title: "Data & Arrays", subs: [] };
    array_push(t7.subs, { 
        title: "DATA/READ/RESTORE", 
        lines: [
            "DATA statement stores values",
            "READ loads into variables", 
            "RESTORE resets to start",
            "Named streams: DATA @name: values"
        ]
    });
    array_push(t7.subs, { 
        title: "Arrays", 
        lines: [
            "DIM A(10) creates array 0 to 10",
            "Use in loops: FOR I=0 TO 10",
            "Multi-dimensional: DIM A(5,5)",
            "Dynamic sizing: DIM A(X+5)"
        ]
    });
    ds_list_add(global.help_topics, t7);

    // Topic 8: Input/Output
    var t8 = { title: "Input/Output", subs: [] };
    array_push(t8.subs, { 
        title: "PRINT Variations", 
        lines: [
            "PRINT X prints value and newline",
            "PRINT X; keeps cursor on line",
            "PRINT X,Y,Z uses tab columns",
            "PRINT without args = blank line"
        ]
    });
    array_push(t8.subs, { 
        title: "INPUT and Keys", 
        lines: [
            "INPUT \"Prompt: \",VAR waits for input",
            "INKEY$ returns last key pressed",
            "CLS clears screen",
            "COLOR FG,BG sets colors"
        ]
    });
    ds_list_add(global.help_topics, t8);

    // Topic 9: Editor & Files
    var t9 = { title: "Editor & Files", subs: [] };
    array_push(t9.subs, { 
        title: "File Operations", 
        lines: [
            "SAVE \"filename\" saves program",
            "LOAD \"filename\" loads program",
            "DIR opens file browser",
            "Drag & drop .BAS files to load"
        ]
    });
    array_push(t9.subs, { 
        title: "Editor Commands", 
        lines: [
            "LIST shows program lines",
            "RUN executes program",
            "NEW or CLEAR erases program",
            "F5 dumps to console"
        ]
    });
    ds_list_add(global.help_topics, t9);

    global.help_state.built = true;
}
#define browser_file_tools_init
global.__browser_file_tools_paste_handler = -1;
global.__browser_file_tools_paste_filter = -1;
global.__browser_file_tools_drop_handler = -1;
global.__browser_file_tools_drop_filter = -1;
global.__browser_file_tools_open_handler = -1;
global.__browser_file_tools_open_filter = -1;

#define browser_file_tools_callback_get_name
var _script = argument0;
if (_script != undefined && script_exists(_script)) {
	var _name = script_get_name(_script);
	if (string_pos("gmcallback_", _name) != 1) {
		show_error("Callback script names must start with `gmcallback_` in GMS1", 1);
		return undefined;
	}
	return _name;
} else return undefined;

#define browser_file_tools_callback_is_valid
var _func = argument0;
if (_func == undefined) return false;
// GMS >= 2.3:
if (is_method(_func)) return true;
//*/
return script_exists(_func);

#define browser_file_tools_callback_invoke3
// GMS >= 2.3:
if (is_method(argument0)) {
	var _func = argument0;
	return _func(argument1, argument2, argument3);
}
//*/
return script_execute(argument0, argument1, argument2, argument3);

#define browser_file_tools_cb_invoke
var _script = argument0;

#define gmcallback_browser_file_tools_paste_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_paste_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_paste_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_paste_filter, _data, _name, _type);

#define browser_paste_bind
/// (?handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _handler = argument_count > 0 ? argument[0] : undefined;
var _filter = argument_count > 1 ? argument[1] : undefined;
// GMS >= 2:
global.__browser_file_tools_paste_handler = _handler;
global.__browser_file_tools_paste_filter = _filter;
return browser_paste_bind_raw(
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_paste_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_paste_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_paste_bind_raw(
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define gmcallback_browser_file_tools_drop_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_drop_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_drop_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_drop_filter, _data, _name, _type);

#define browser_drop_bind
/// (?handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _handler = argument_count > 0 ? argument[0] : undefined;
var _filter = argument_count > 1 ? argument[1] : undefined;
// GMS >= 2:
global.__browser_file_tools_drop_handler = _handler;
global.__browser_file_tools_drop_filter = _filter;
return browser_drop_bind_raw(
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_drop_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_drop_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_drop_bind_raw(
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define gmcallback_browser_file_tools_open_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_open_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_open_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_open_filter, _data, _name, _type);

#define browser_show_open_dialog
/// (accept:string, multiselect:bool, handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _accept = argument[0], _multiselect = argument[1], _handler = argument[2];
var _filter = argument_count > 3 ? argument[3] : undefined;
// GML >= 2:
global.__browser_file_tools_open_handler = _handler;
global.__browser_file_tools_open_filter = _filter;
return browser_show_open_dialog_raw(_accept, _multiselect,
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_open_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_open_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_show_open_dialog_raw(_accept,
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define browser_show_save_dialog
/// (buffer, name, ?type, ?size)
var _buffer = argument[0], _name = argument[1];
var _type = argument_count > 2 ? argument[2] : undefined;
var _size = argument_count > 3 ? argument[3] : buffer_get_size(_buffer);
if (_type == undefined) _type = "application/octet-stream";
return browser_show_save_dialog_raw(buffer_get_address(_buffer), _name, _type, _size);
/// @function editor_html_build_program_text
/// @desc Serialize the current BASIC program into canonical lines: "<line> <code>\r\n"
///       Uses the same sources your desktop save_program_as() already prefers.
/// @returns {string}
function editor_html_build_program_text() {
    var lines_list = ds_list_create(); // ordered strings to emit
    var source_used = "NONE";
    var ed = instance_find(obj_editor, 0);

    // === Try obj_editor.program_lines (array) ===
    if (ed != noone && variable_instance_exists(ed, "program_lines") && is_array(ed.program_lines)) {
        for (var i = 0; i < array_length(ed.program_lines); i++) {
            ds_list_add(lines_list, string(ed.program_lines[i]));
        }
        if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (array)";
    }

    // === Try obj_editor.program_lines (ds_list) ===
    if (source_used == "NONE" && ed != noone && variable_instance_exists(ed, "program_lines") &&
        ds_exists(ed.program_lines, ds_type_list)) {
        var n = ds_list_size(ed.program_lines);
        for (var j = 0; j < n; j++) {
            ds_list_add(lines_list, string(ds_list_find_value(ed.program_lines, j)));
        }
        if (n > 0) source_used = "obj_editor.program_lines (ds_list)";
    }

    // === Try obj_editor.program_lines (ds_map keyed by line numbers) ===
    if (source_used == "NONE" && ed != noone && variable_instance_exists(ed, "program_lines") &&
        ds_exists(ed.program_lines, ds_type_map)) {

        var epl_keys = ds_list_create();
        var e_k = ds_map_find_first(ed.program_lines);
        while (e_k != undefined) { ds_list_add(epl_keys, e_k); e_k = ds_map_find_next(ed.program_lines, e_k); }

        var epl_numeric = true;
        for (var ei = 0; ei < ds_list_size(epl_keys); ei++) {
            if (!is_real(ds_list_find_value(epl_keys, ei))) { epl_numeric = false; break; }
        }
        if (epl_numeric) ds_list_sort(epl_keys, true);

        for (var ej = 0; ej < ds_list_size(epl_keys); ej++) {
            var _ln  = ds_list_find_value(epl_keys, ej);
            var _val = ds_map_find_value(ed.program_lines, _ln);
            ds_list_add(lines_list, string(_ln) + " " + string(_val));
        }
        if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (ds_map)";

        ds_list_destroy(epl_keys);
    }

    // === Try common ds_map containers keyed by line numbers ===
    if (source_used == "NONE") {
        var map_names = [
            "program_map", "program_lines_map", "basic_program",
            "lines_map", "line_store", "program"
        ];
        for (var mi = 0; mi < array_length(map_names); mi++) {
            var mn = map_names[mi];
            if (variable_instance_exists(ed, mn) && ds_exists(ed[? mn], ds_type_map)) {
                var keys = ds_list_create();
                var k = ds_map_find_first(ed[? mn]);
                while (k != undefined) { ds_list_add(keys, k); k = ds_map_find_next(ed[? mn], k); }
                var numeric = true;
                for (var ki = 0; ki < ds_list_size(keys); ki++) {
                    if (!is_real(ds_list_find_value(keys, ki))) { numeric = false; break; }
                }
                if (numeric) ds_list_sort(keys, true);
                for (var kj = 0; kj < ds_list_size(keys); kj++) {
                    var _ln  = ds_list_find_value(keys, kj);
                    var val = ds_map_find_value(ed[? mn], _ln);
                    ds_list_add(lines_list, string(_ln) + " " + string(val));
                }
                ds_list_destroy(keys);
                if (ds_list_size(lines_list) > 0) { source_used = "obj_editor." + mn; break; }
            }
        }
    }

    // === Try global.program_lines (ds_map keyed by line numbers) ===
    if (source_used == "NONE" && variable_global_exists("program_lines") && ds_exists(global.program_lines, ds_type_map)) {
        var gpl_keys = ds_list_create();
        var gpl_k = ds_map_find_first(global.program_lines);
        while (gpl_k != undefined) { ds_list_add(gpl_keys, gpl_k); gpl_k = ds_map_find_next(global.program_lines, gpl_k); }
        var gpl_numeric = true;
        for (var gpi = 0; gpi < ds_list_size(gpl_keys); gpi++) {
            if (!is_real(ds_list_find_value(gpl_keys, gpi))) { gpl_numeric = false; break; }
        }
        if (gpl_numeric) ds_list_sort(gpl_keys, true);
        for (var gpj = 0; gpj < ds_list_size(gpl_keys); gpj++) {
            var gln  = ds_list_find_value(gpl_keys, gpj);
            var gval = ds_map_find_value(global.program_lines, gln);
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        ds_list_destroy(gpl_keys);
        if (ds_list_size(lines_list) > 0) source_used = "global.program_lines (ds_map)";
    }

    // --- Emit CRLF text
    var out = "";
    var total = ds_list_size(lines_list);
    for (var ii = 0; ii < total; ii++) {
        out += string(ds_list_find_value(lines_list, ii)) + "\r\n";
    }
    ds_list_destroy(lines_list);
    return out; // empty if nothing found
}

/// @function editor_html_handle_paste_command
// === BEGIN: editor_html_handle_paste_command ===
function editor_html_handle_paste_command() {
    // Only meaningful in browser builds; desktop uses editor_handle_paste_command
    if (os_browser == browser_not_a_browser) {
        show_error_message("Use normal Paste on desktop. :PASTE is for browser builds.");
        return;
    }

    // Gate to avoid double-bind/log spam
    if (is_undefined(global.__editor_html_paste_bound)) global.__editor_html_paste_bound = false;
    if (global.__editor_html_paste_bound) {
        // Already waiting for a Ctrl/Cmd+V from the user
        basic_show_message("Paste is already waiting — click the game, then press Ctrl+V (⌘V on Mac).");
        if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE/HTML] already bound");
        return;
    }

    // Accept text only
    var _filter = function(kind, type) {
        // kind: "string" for text; "file" for files
        return (kind == "string");
    };

    // One-shot handler: identical parsing/mutation to Windows path
    var _handler = function(data, name, type) {
        // For text, YellowAfterLife sets name==undefined
        if (!is_undefined(name)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE/HTML] ignored non-text paste: name=" + string(name) + " type=" + string(type));
            // unbind and reset
            browser_paste_bind();
            global.__editor_html_paste_bound = false;
            return;
        }

        var raw_clip = string(data);
        if (string_length(raw_clip) <= 0) {
            show_message("Clipboard is empty.");
            browser_paste_bind();
            global.__editor_html_paste_bound = false;
            return;
        }

        var lines = string_split(raw_clip, "\n");
        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: captured " + string(array_length(lines)) + " raw lines");

        for (var i = 0; i < array_length(lines); i++) {
            var line = string_trim(lines[i]);
            if (string_length(line) == 0) continue;

            // Expect: <number><space><code>
            var space_pos = string_pos(" ", line);
            if (space_pos > 0) {
                var line_num_str = string_copy(line, 1, space_pos - 1);
                var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

                // Windows CRLF: trim trailing '\r' if present
                if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
                    code_str = string_copy(code_str, 1, string_length(code_str) - 1);
                }

                if (string_digits(line_num_str) == line_num_str) {
                    var line_num = real(line_num_str);

                    if (line_num > 0 && string_length(code_str) > 0) {
                        // INSERT or REPLACE program text
                        ds_map_set(global.program_lines, line_num, code_str);
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");

                        // Maintain ordered line number list — add only if not present
                        var idx = ds_list_find_index(global.line_numbers, line_num);
                        if (idx == -1) {
                            ds_list_add(global.line_numbers, line_num);
                            ds_list_sort(global.line_numbers, true);
                            if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
                        } else if (dbg_on(DBG_FLOW)) {
                           if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
                        }
                    }
                }
            }
        }

        basic_show_message("Program pasted successfully.");

        // One-shot: unbind after handling a paste so normal keys resume
        browser_paste_bind();
        global.__editor_html_paste_bound = false;
    };

    // Bind paste; some wrappers don’t return a bool to GML, so don’t trust the return value
    browser_paste_bind(_handler, _filter);
    global.__editor_html_paste_bound = true;

    // Match your existing UX/logging
    if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Bound. Click the game, then press Ctrl/Cmd+V.");
    basic_show_message("Paste ready — click the game, then press Ctrl+V (⌘V on Mac).");
}
// === END: editor_html_handle_paste_command ===

function basic_validate_program() {
    // Ensure structures exist
    if (!ds_exists(global.program_map, ds_type_map) || !ds_exists(global.line_list, ds_type_list)) return true;

    // Helpers local to validator
    var _top_level_eq_pos = function(s) {
        var L = string_length(s), _depth = 0, inq = false;
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { inq = !inq; continue; }
            if (inq) continue;
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { if (_depth > 0) _depth--; continue; }
            if (ch == "=" && _depth == 0) return i;
        }
        return 0;
    };
    
    var _is_letter = function(ch) {
        if (string_length(ch) < 1) return false;
        var c = ord(string_upper(ch));
        return (c >= 65 && c <= 90);
    };
    
    var _is_valid_lhs = function(lhs) {
        lhs = string_trim(lhs);
        if (lhs == "") return false;
        var head = string_char_at(lhs, 1);
        // Inline the letter check to avoid scoping issues
        var head_ord = ord(string_upper(head));
        var is_valid_head = (string_length(head) >= 1) && (head_ord >= 65 && head_ord <= 90);
        if (!is_valid_head) return false;
        var p = string_pos("(", lhs);
        if (p > 0 && string_char_at(lhs, string_length(lhs)) != ")") return false;
        return true;
    };
    
    var _has_unquoted_inkey = function(stmt, up) {
        var inq = false;
        var stmt_len = string_length(stmt);
        for (var j = 1; j <= stmt_len - 5; j++) {
            var ch = string_char_at(stmt, j);
            if (ch == "\"") {
                if (j < stmt_len && string_char_at(stmt, j + 1) == "\"") {
                    j++; // skip escaped quote
                    continue;
                }
                inq = !inq;
                continue;
            }
            if (!inq && j + 5 <= stmt_len && string_copy(up, j, 6) == "INKEY$") {
                return true;
            }
        }
        return false;
    };

    // Walk each physical line in program order
    for (var i = 0; i < ds_list_size(global.line_list); i++) {
        var line_no  = global.line_list[| i];
        var src_line = ds_map_find_value(global.program_map, line_no);
        if (!is_string(src_line)) continue;

        // Split on top-level colons (your helper)
        var parts = split_on_unquoted_colons(string_trim(src_line));
        for (var p = 0; p < array_length(parts); p++) {
            var stmt_raw = string_trim(parts[p]);
            if (stmt_raw == "") continue;

// === NEW: remark position lint (must start segment or be standalone) ===
var badpos = _lint_illegal_remark_position(stmt_raw);
if (badpos > 0) {
    basic_syntax_error(
        "Remark must be standalone on a line or begin a colon-separated statement.\n" +
        "Use  : ' comment   or   : REM comment\nOffending: " + stmt_raw,
        line_no,  // physical line number
        p,        // colon-segment index
        "REMARK_POSITION"
    );
    return false;
}


            // Ignore REM / apostrophe comments entirely
            var sp  = string_pos(" ", stmt_raw);
            var verb = (sp > 0) ? string_upper(string_copy(stmt_raw, 1, sp - 1)) : string_upper(stmt_raw);
            if (verb == "REM" || string_char_at(stmt_raw, 1) == "'") break;

            var stmt = strip_basic_remark(stmt_raw);
            var up   = string_upper(stmt);

            // Use quote-aware INKEY$ detection instead of simple string_pos
            if (_has_unquoted_inkey(stmt, up)) {
                var eqp = _top_level_eq_pos(stmt);
                if (eqp > 0) {
                    var lhs = string_copy(stmt, 1, eqp - 1);
                    if (!_is_valid_lhs(lhs)) {
                        basic_syntax_error("Left side of assignment must be a variable or array name before INKEY$", line_no, p, "INKEY_LHS");
                        return false;
                    }
                } else if (verb != "LET") {
                    basic_syntax_error("INKEY$ may only appear on the right side of an assignment like  X$ = INKEY$", line_no, p, "INKEY_MISUSE");
                    return false;
                }
            }
        }
    }
    return true;
}
/// @script basic_cmd_elseif
/// @description Handle an ELSEIF in a block‐structured IF…THEN…ELSEIF…ELSE…ENDIF chain
function basic_cmd_elseif(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF START — Raw arg: '" + arg + "'");
    
    // ── GUARD 1: Must have an open IF on the stack ──
    if (ds_stack_empty(global.if_stack)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: ELSEIF without matching IF");
        return;
    }
    
    // 1) Where are we in the program?
    var current_index = global.interpreter_current_line_index;
    
    // 2) Peek the top IF‐frame
    var frame = ds_stack_top(global.if_stack);
    
    // ── GUARD 2: Must have block metadata for this IF ──
    if (!ds_map_exists(global.if_block_map, frame[? "startIndex"])) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: No IF‐block metadata (bad nesting?)");
        return;
    }
    
    var taken       = frame[? "takenBranch"];
    var elseif_list = frame[? "elseifIndices"]; // ds_list of all ELSEIF positions
    var else_index  = frame[? "elseIndex"];
    var endif_index = frame[? "endifIndex"];
    
    // 3) Find which ELSEIF this is
    var pos = ds_list_find_index(elseif_list, current_index);
    if (pos < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: Unexpected ELSEIF at index " + string(current_index));
        return;
    }
    
    // 4) If we’ve already taken a branch, skip straight through
    if (taken) {
        // decide next jump: next ELSEIF, or ELSE, or ENDIF
        var next_index = -1;
        if (pos < ds_list_size(elseif_list) - 1) {
            next_index = elseif_list[| pos + 1];
        } else if (else_index >= 0) {
            next_index = else_index;
        } else {
            next_index = endif_index;
        }
        global.interpreter_next_line = next_index;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF skipping to index " + string(next_index));
        return;
    }
    
    // 5) Parse and evaluate this ELSEIF’s condition
    var raw      = string_trim(arg);
    var upperRaw = string_upper(raw);
    var then_pos = string_pos("THEN", upperRaw);
    if (then_pos <= 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var cond_text = string_trim(string_copy(raw, 1, then_pos - 1));
    if (dbg_on(DBG_FLOW))  show_debug_message("Parsed ELSEIF condition: '" + cond_text + "'");
    
    // Reuse your AND/OR logic from basic_cmd_if
    var result = false;
    var logic_op = "";
    var upcond   = string_upper(cond_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";
    if (logic_op != "") {
        var parts = string_split(cond_text, logic_op);
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        if (dbg_on(DBG_FLOW))  show_debug_message("Combined ELSEIF (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(cond_text);
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF single condition result: " + string(result));
    }
    
    // 6) If it’s true, mark the frame as “taken” and fall into this block…
    if (result) {
        frame[? "takenBranch"] = true;
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF TRUE: entering branch at index " + string(global.interpreter_next_line));
    } else {
        // …otherwise skip to the next ELSEIF/ELSE/ENDIF
        var next_index = (pos < ds_list_size(elseif_list) - 1)
                         ? elseif_list[| pos + 1]
                         : (else_index >= 0 ? else_index : endif_index);
        global.interpreter_next_line = next_index;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF FALSE: skipping to index " + string(next_index));
    }
}

function basic_wrap_and_commit(_text, _color) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_wrap_and_commit START ===");

// Normalize and split on explicit newlines first
var src = string(_text);
src = string_replace_all(src, "\r\n", "\n");
src = string_replace_all(src, "\r",   "\n");

if (string_pos("\n", src) > 0) {
    var parts = string_split(src, "\n"); // GMS2.3+
    for (var i = 0; i < array_length(parts); i++) {
        basic_wrap_and_commit(parts[i], _color); // recurse per physical line
    }
    return;
}


    // Output buffers must already exist
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("wrap: buffers not initialized; SKIP");
        return;
    }

    // Width: default 70 unless caller set global.wrap_width (>0)
    var wrap_width = (variable_global_exists("wrap_width") && is_real(global.wrap_width) && global.wrap_width > 0)
        ? floor(global.wrap_width) : 70;
    if (wrap_width < 4) wrap_width = 4; // safety

    // Defensive copy of input text (prevents any aliasing/truncation surprises)
    var src       = string(_text);
    var src_len   = string_length(src);
    var remaining = (src_len > 0) ? string_copy(src, 1, src_len) : "";

    // Wrap loop
    while (string_length(remaining) > wrap_width) {
        var len_rem    = string_length(remaining);
        var cut        = wrap_width;
        var last_space = 0;
        var found_space = false;

        // Find the last space at or before wrap_width
        var p = min(wrap_width, len_rem);
        for (; p >= 1; p--) {
            if (string_char_at(remaining, p) == " ") { last_space = p; break; }
        }

        if (last_space > 0) {
            // Break on that space (exclude it)
            cut = last_space - 1;
            found_space = true;
        } else {
            // Hard break … try not to strand punctuation on next line
            var next_char = (wrap_width + 1 <= len_rem) ? string_char_at(remaining, wrap_width + 1) : "";
            if (next_char == ")" || next_char == "]" || next_char == "}" ||
                next_char == "!" || next_char == "?" || next_char == "." ||
                next_char == "," || next_char == ":" || next_char == ";") {
                var back = wrap_width;
                while (back > 1 && string_char_at(remaining, back) != " ") back--;
                if (back > 1) {
                    cut = back - 1;   // exclude that space
                    found_space = true;
                }
            }
        }

        if (cut < 1) cut = wrap_width; // safety for huge first word

var line = string_copy(remaining, 1, cut);
var padN = max(0, wrap_width - string_length(line));
if (padN > 0) line += string_repeat(" ", padN);
if (dbg_on(DBG_FLOW)) show_debug_message("wrap: COMMIT(line) ← \"" + line + "\"");
ds_list_add(global.output_lines, line);
ds_list_add(global.output_colors, _color);


        // Advance; skip the space when we broke on a space
        var next_start = cut + (found_space ? 2 : 1);
        if (next_start <= len_rem) {
            remaining = string_copy(remaining, next_start, len_rem - (next_start - 1));
        } else {
            remaining = "";
        }

        // Trim any leading spaces on the next line
        while (string_length(remaining) > 0 && string_char_at(remaining, 1) == " ") {
            remaining = string_copy(remaining, 2, string_length(remaining) - 1);
        }
    }

    // Tail (commit only if there's content OR the original string was truly empty)
    // This avoids accidental commits of stray empties while preserving empty-line intent.
var tail = remaining;
var padT = max(0, wrap_width - string_length(tail));
if (padT > 0) tail += string_repeat(" ", padT);
if (dbg_on(DBG_FLOW)) show_debug_message("wrap: COMMIT(tail) ← \"" + tail + "\"");
ds_list_add(global.output_lines, tail);
ds_list_add(global.output_colors, _color);

    }


/// Helper function to assign values to arrays (BASIC-visible index is 1-based)
function basic_assign_to_array(varName, val) {
    // Parse array name and index from varName like "TOPIC$(I)"
    var open_paren  = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
    if (open_paren <= 0 || close_paren <= open_paren) {
        basic_syntax_error("Invalid array syntax: " + varName,
                           /*line_no*/ undefined,
                           /*stmt_idx*/ global.interpreter_current_stmt_index,
                           "ARRAY_SYNTAX");
        return;
    }

    var arrayName = string_trim(string_copy(varName, 1, open_paren - 1));
    var indexExpr = string_trim(string_copy(varName, open_paren + 1, close_paren - open_paren - 1));

    // Normalize array name used in your maps
    var normalizedArrayName = basic_normvar(arrayName);

    // Evaluate index expression (BASIC-side index, expected 1..N)
    var indexTokens  = basic_tokenize_expression_v2(indexExpr);
    var indexPostfix = infix_to_postfix(indexTokens);
    var indexVal     = evaluate_postfix(indexPostfix);

    // Safeguard against invalid index evaluation
    if (is_string(indexVal) || is_undefined(indexVal)) {
        basic_syntax_error("Invalid array index expression: " + indexExpr + " (evaluated to " + string(indexVal) + ")",
                           /*line_no*/ undefined,
                           /*stmt_idx*/ global.interpreter_current_stmt_index,
                           "ARRAY_INDEX_EVAL");
        return;
    }

    // Coerce to integer and enforce 1-based external indexing
    var idx1 = floor(real(indexVal));
    if (!is_real(idx1) || idx1 < 1) {
        basic_syntax_error("Array index must be >= 1 for " + arrayName + " (got " + string(indexVal) + ")",
                           /*line_no*/ undefined,
                           /*stmt_idx*/ global.interpreter_current_stmt_index,
                           "ARRAY_INDEX_RANGE");
        return;
    }

    // Convert to 0-based for ds_list
    var ds_idx = idx1 - 1;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("ARRAY ASSIGN: Array='" + normalizedArrayName
            + "' BASIC-idx=" + string(idx1) + " (ds_idx=" + string(ds_idx)
            + ") Value='" + string(val) + "'");
    }

    // Ensure the array map/list exists
    if (!ds_map_exists(global.basic_arrays, normalizedArrayName)) {
        global.basic_arrays[? normalizedArrayName] = ds_list_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: Created array '" + normalizedArrayName + "'");
    }

    var arrayList = global.basic_arrays[? normalizedArrayName];

    // Ensure capacity up to ds_idx (0-based)
    while (ds_list_size(arrayList) <= ds_idx) {
        ds_list_add(arrayList, 0); // default fill
    }

    // String arrays end with $, numeric otherwise
    var is_string_array = (string_length(normalizedArrayName) > 0)
                       && (string_char_at(normalizedArrayName, string_length(normalizedArrayName)) == "$");

    if (is_string_array) {
        ds_list_replace(arrayList, ds_idx, string(val));
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: " + normalizedArrayName + "[" + string(idx1) + "] (ds " + string(ds_idx) + ") = '" + string(val) + "' (string)");
    } else {
        var numVal = is_real(val) ? val : (basic_looks_numeric(string(val)) ? real(val) : 0);
        ds_list_replace(arrayList, ds_idx, numVal);
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: " + normalizedArrayName + "[" + string(idx1) + "] (ds " + string(ds_idx) + ") = " + string(numVal) + " (numeric)");
    }
}
/// @event obj_inkey_feeder/Step
if (os_browser != browser_not_a_browser) exit;

// === EARLY EXIT GUARDS ===
var _is_editor_room =
    (variable_global_exists("editor_return_room") && room == global.editor_return_room)
 || (variable_global_exists("editor_room") && room == global.editor_room)
 || (asset_get_index("rm_editor") != -1 && room == asset_get_index("rm_editor"))
 || instance_exists(obj_editor);

if (_is_editor_room) { keyboard_string = ""; exit; }
if (variable_global_exists("interpreter_running") && !global.interpreter_running) { keyboard_string = ""; exit; }

// === Ensure queue exists ===
if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
    global.inkey_queue = ds_queue_create();
}

// Capacity-aware enqueue (pass cap explicitly to avoid scope issues)
var _enq = function(val, cap) {
    while (ds_queue_size(global.inkey_queue) >= cap) ds_queue_dequeue(global.inkey_queue);
    ds_queue_enqueue(global.inkey_queue, val);
    if (variable_global_exists("DBG_PARSE") && dbg_on(DBG_PARSE)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("##KEYFEED## ENQ='" + string(val) + "'"
            + " A1=" + string((is_string(val) && string_length(val)>=1) ? ord(string_char_at(val,1)) : -1)
            + " A2=" + string((is_string(val) && string_length(val)>=2) ? ord(string_char_at(val,2)) : -1));
    }
};

var _CAP = 128;

// === 1) DISPLAYABLE TEXT (letters, digits, punctuation, space, shifted forms) ===
if (keyboard_string != "") {
    var s = keyboard_string;
    var n = string_length(s);
    for (var i = 1; i <= n; i++) {
        _enq(string_char_at(s, i), _CAP);
    }
    keyboard_string = "";
}

// === 2) STANDARD CONTROL KEYS (single-char control codes) ===
if (keyboard_check_pressed(vk_enter))     _enq(chr(13), _CAP); // Enter
if (keyboard_check_pressed(vk_tab))       _enq(chr(9),  _CAP); // Tab
if (keyboard_check_pressed(vk_backspace)) _enq(chr(8),  _CAP); // Backspace
if (keyboard_check_pressed(vk_escape))    _enq(chr(27), _CAP); // Escape

// === 3) NUMPAD DIGITS (show up even if keyboard_string doesn't) ===
if (keyboard_check_pressed(vk_numpad0)) _enq("0", _CAP);
if (keyboard_check_pressed(vk_numpad1)) _enq("1", _CAP);
if (keyboard_check_pressed(vk_numpad2)) _enq("2", _CAP);
if (keyboard_check_pressed(vk_numpad3)) _enq("3", _CAP);
if (keyboard_check_pressed(vk_numpad4)) _enq("4", _CAP);
if (keyboard_check_pressed(vk_numpad5)) _enq("5", _CAP);
if (keyboard_check_pressed(vk_numpad6)) _enq("6", _CAP);
if (keyboard_check_pressed(vk_numpad7)) _enq("7", _CAP);
if (keyboard_check_pressed(vk_numpad8)) _enq("8", _CAP);
if (keyboard_check_pressed(vk_numpad9)) _enq("9", _CAP);

// === 4) EXTENDED KEYS (QBASIC style: CHR$(0)+CHR$(scan)) ===
// Inline the extended key functionality to avoid scope issues
if (keyboard_check_pressed(vk_up))    _enq(chr(0) + chr(72), _CAP); // Up
if (keyboard_check_pressed(vk_down))  _enq(chr(0) + chr(80), _CAP); // Down
if (keyboard_check_pressed(vk_left))  _enq(chr(0) + chr(75), _CAP); // Left
if (keyboard_check_pressed(vk_right)) _enq(chr(0) + chr(77), _CAP); // Right

// Convenience WASD (uppercase; add lowercase if desired)
if (keyboard_check_pressed(ord("W"))) _enq("W", _CAP);
if (keyboard_check_pressed(ord("A"))) _enq("A", _CAP);
if (keyboard_check_pressed(ord("S"))) _enq("S", _CAP);
if (keyboard_check_pressed(ord("D"))) _enq("D", _CAP);
function basic_cmd_printat(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== PRINTAT DEBUG START ===");
    if (dbg_on(DBG_FLOW)) show_debug_message("Raw arg: '" + string(arg) + "'");

    // Parse arguments (x, y, "string" [, fg [, bg]])
    var args = basic_parse_csv_args(arg);
    if (dbg_on(DBG_FLOW)) show_debug_message("Parsed " + string(array_length(args)) + " arguments");
    if (array_length(args) < 3) {
        if (dbg_on(DBG_FLOW)) show_debug_message("❌ PRINTAT ERROR: Not enough arguments.");
        return;
    }

    // Evaluate x and y using the SAME expression engine your FOR header uses
    var x_expr = string_trim(args[0]);
    var y_expr = string_trim(args[1]);
    var _x     = floor(real(basic_evaluate_expression_v2(x_expr)));
    var _y     = floor(real(basic_evaluate_expression_v2(y_expr)));
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: start=(" + string(_x) + "," + string(_y) + ")");

	// 3rd argument: literal if quoted, otherwise evaluate expression → string
	var str_expr = string_trim(args[2]);

	if (string_length(str_expr) >= 2) {
		var first = string_char_at(str_expr, 1);
		var last  = string_char_at(str_expr, string_length(str_expr));
		if ((first == "\"" || first == "'") && first == last) {
		    // literal
		    str_expr = string_copy(str_expr, 2, string_length(str_expr) - 2);
		    var str = str_expr;
		} else {
		    // expression (supports variables, STR$, concatenation, etc.)
		    var _val = basic_evaluate_expression_v2(str_expr);
		    var str  = string(_val);
		}
	} else {
		var str = string(basic_evaluate_expression_v2(str_expr));
	}


    // Optional colors
    var fg = (array_length(args) > 3) ? basic_parse_color(string_trim(args[3])) : c_white;
    var bg = (array_length(args) > 4) ? basic_parse_color(string_trim(args[4])) : c_black;

    // Grid and bounds
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) { if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: grid not found"); return; }
    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _y < 0 || _x >= cols || _y >= rows) {
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: start out of bounds"); return;
    }

var _grid_obj = instance_find(obj_mode1_grid, 0);
if (!instance_exists(_grid_obj)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: No grid; creating now");
    // create your grid instance (room already in MODE 1)
    instance_create_layer(0, 0, "Instances", obj_mode1_grid);
    _grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(_grid_obj)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: still no grid after create; abort");
        return;
    }
}






    // Write characters, clamped to right edge
    var max_len = min(string_length(str), cols - _x);
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: str len=" + string(string_length(str)) + " -> max_len=" + string(max_len));
    for (var j = 0; j < max_len; j++) {
        var ch = ord(string_char_at(str, j + 1));
        mode1_grid_set(_x + j, _y, ch, fg, bg);
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("✅ PRINTAT complete");
    if (dbg_on(DBG_FLOW)) show_debug_message("=== PRINTAT DEBUG END ===");
}

/// FILE: scripts/basic_parse_color.gml
/// FUNCTION: basic_parse_color(colstr)
/// Behavior:
/// 1) Try global.colors map (case-insensitive; quotes ok; aliases normalized)
/// 2) Try hex formats: &Hrrggbb, 0xrrggbb, #rrggbb, $rrggbb
/// 3) Try decimal integer
/// 4) Fallback to c_white with a debug note

function basic_parse_color(colstr) {
    var s = string_trim(colstr);

    // Strip matching quotes
    if (string_length(s) >= 2) {
        var f = string_char_at(s, 1);
        var l = string_char_at(s, string_length(s));
        if ((f == "\"" || f == "'") && f == l) s = string_copy(s, 2, string_length(s) - 2);
    }

    // Normalize for name lookup
    var key = string_upper(s);

    // Alias normalization to your existing keys
    if (key == "GREY") key = "GRAY";
    if (key == "DARKGRAY" || key == "DARKGREY") key = "DKGRAY";
    // LIGHTGRAY not in your map; handle as special case

    // 1) Named color via global.colors (global is a struct, so check the variable)
    if (variable_global_exists("colors")) {
        if (key == "LIGHTGRAY" || key == "LIGHTGREY") {
            return make_color_rgb(192,192,192);
        }
        if (ds_map_exists(global.colors, key)) {
            return ds_map_find_value(global.colors, key);
        }
    }

    // 2) Hex parsing (RRGGBB)
    var hex = "";
    var ku  = string_upper(s);
    if (string_length(ku) >= 3 && string_copy(ku,1,2) == "&H") {
        hex = string_copy(s, 3, string_length(s)-2);
    } else if (string_length(ku) >= 3 && string_copy(ku,1,2) == "0X") {
        hex = string_copy(s, 3, string_length(s)-2);
    } else if (string_length(ku) >= 1 && string_char_at(ku,1) == "#") {
        hex = string_copy(s, 2, string_length(s)-1);
    } else if (string_length(ku) >= 1 && string_char_at(ku,1) == "$") {
        hex = string_copy(s, 2, string_length(s)-1);
    }

    if (hex != "") {
        var clean = "";
        for (var i = 1; i <= string_length(hex); i++) {
            var ch = string_upper(string_char_at(hex, i));
            if ((ch >= "0" && ch <= "9") || (ch >= "A" && ch <= "F")) clean += ch;
        }
        if (string_length(clean) == 6) {
            var rr = string_copy(clean,1,2);
            var gg = string_copy(clean,3,2);
            var bb = string_copy(clean,5,2);
            return make_color_rgb(__hex_byte(rr), __hex_byte(gg), __hex_byte(bb));
        }
    }

    // 3) Decimal integer fallback
    if (is_numeric_string(s)) {
        return real(s);
    }

    // 4) Fallback
    if (dbg_on(DBG_FLOW)) show_debug_message("basic_parse_color: unknown color '" + s + "', defaulting to WHITE");
    return c_white;
}

function __hex_byte(two) {
    var hi = string_char_at(two,1);
    var lo = string_char_at(two,2);
    return __hex_nibble(hi) * 16 + __hex_nibble(lo);
}
function __hex_nibble(ch) {
    ch = string_upper(ch);
    if (ch >= "0" && ch <= "9") return ord(ch) - ord("0");
    if (ch >= "A" && ch <= "F") return 10 + (ord(ch) - ord("A"));
    return 0;
}

/// FILE: scripts/editor__apply_pasted_text.gml
/// @function editor__apply_pasted_text(text)
/// @desc Parses BASIC lines from `text` and mutates global.program_lines/global.line_numbers.
/// @returns {bool} true if at least one line was applied; false otherwise
function editor__apply_pasted_text(text) {
    if (is_undefined(text) || string_length(text) <= 0) {
        show_message("Clipboard is empty.");
        return false;
    }

    var applied = false;
    var lines = string_split(text, "\n");
    if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: received " + string(array_length(lines)) + " raw lines");
    }

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);
        if (string_length(line) == 0) continue;

        var space_pos = string_pos(" ", line);
        if (space_pos <= 0) continue;

        var line_num_str = string_copy(line, 1, space_pos - 1);
        var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

        // Strip trailing CR in CRLF cases
        if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
            code_str = string_copy(code_str, 1, string_length(code_str) - 1);
        }

        // Validate line number is digits-only
        if (string_digits(line_num_str) != line_num_str) continue;

        var line_num = real(line_num_str);
        if (line_num <= 0 || string_length(code_str) <= 0) continue;

        // Insert/replace in program_lines
        ds_map_set(global.program_lines, line_num, code_str);

        if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
           if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");
        }

        // Maintain ordered list of line numbers
        var idx = ds_list_find_index(global.line_numbers, line_num);
        if (idx == -1) {
            ds_list_add(global.line_numbers, line_num);
            ds_list_sort(global.line_numbers, true);
            if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
               if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
            }
        } else if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
            show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
        }

        applied = true;
    }

    if (applied) {
        basic_show_message("Program pasted successfully.");
    } else {
        // Nothing matched the `<num> <code>` pattern; keep parity with Windows behavior:
        // do not show success if nothing was applied.
        show_message("Clipboard is empty or not in '<line> <code>' format.");
    }
    return applied;
}

/// Load a selected file (by 1-based index or exact filename) into program_lines/line_numbers
function editor_html_dir_open(which) {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("html_dir_files") || ds_list_size(global.html_dir_files) == 0) {
        show_message("No files selected. Use DIR to choose files first.");
        return false;
    }

    var idx = -1, n = ds_list_size(global.html_dir_files);
    var w = string_trim(which), W = string_upper(w);

    // numeric index (1-based)
    if (string_digits(w) == w) {
        var k = real(w);
        if (k >= 1 && k <= n) idx = k - 1;
    }
    // filename match
    if (idx < 0) {
        for (var i = 0; i < n; i++) {
            var rec_i = global.html_dir_files[| i];
            if (string_upper(ds_map_find_value(rec_i, "name")) == W) { idx = i; break; }
        }
    }
    if (idx < 0) { show_message("Not found. Use DIR SHOW to see indexes."); return false; }

    var rec = global.html_dir_files[| idx];
    var text = editor_html_decode_data_url_to_text(ds_map_find_value(rec, "data"));
    if (string_length(text) <= 0) {
        show_message("Unable to read file text.");
        return false;
    }

    // Parse exactly like your paste/Windows path
    var lines = string_split(text, "\n");
   if (dbg_on(DBG_FLOW)) show_debug_message("LOAD(HTML): captured " + string(array_length(lines)) + " raw lines");

    for (var j = 0; j < array_length(lines); j++) {
        var line = string_trim(lines[j]);
        if (string_length(line) == 0) continue;

        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var ln_str = string_copy(line, 1, space_pos - 1);
            var code   = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            if (string_length(code) > 0 && string_char_at(code, string_length(code)) == chr(13)) {
                code = string_copy(code, 1, string_length(code) - 1);
            }

            if (string_digits(ln_str) == ln_str) {
                var _ln = real(ln_str);
                if (_ln > 0 && string_length(code) > 0) {
                    ds_map_set(global.program_lines, _ln, code);
                    var found = ds_list_find_index(global.line_numbers, _ln);
                    if (found == -1) { ds_list_add(global.line_numbers, _ln); ds_list_sort(global.line_numbers, true); }
                }
            }
        }
    }

    basic_show_message("Program loaded: " + ds_map_find_value(rec, "name"));
    return true;
}

/// @event obj_basic_interpreter/Draw
draw_set_font(fnt_basic);

    //draw_set_color(c_white);
	//draw_text(4, room_height - 60, "FONT=" + global.active_font_name + "  spr=" + string(global.active_font_sprite) + "  num=" + string(sprite_get_number(global.active_font_sprite)));


// === BACKGROUND === //
if (global.background_draw_enabled) {
    draw_set_color(global.background_draw_color);
    draw_rectangle(0, 0, room_width, room_height, false);
}

var font_height = string_height("A");
var visible_lines = floor(room_height / font_height) - 2;
var total_lines = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);

// === SCROLL MANAGEMENT === //
if (!global.scroll_lock && global.interpreter_running && !global.awaiting_input && !global.program_has_ended) {
    global.scroll_offset = max(0, total_lines - visible_lines);
}
global.scroll_offset = clamp(global.scroll_offset, 0, max(0, total_lines - visible_lines));

// === OUTPUT TEXT === //
var y1 = 0;
for (var i = global.scroll_offset; i < ds_list_size(global.output_lines); i++) {
    var col = (i < ds_list_size(global.output_colors)) ? global.output_colors[| i] : global.basic_text_color;
    draw_set_color(col);
    draw_text(16, y1, global.output_lines[| i]);
    y1 += font_height;
}

// === INPUT LINE OR PAUSE === //
if (global.awaiting_input) {
    draw_set_color(global.basic_text_color);
    var input_str = "";

    if (global.input_expected) {
        // We're in INPUT mode
        input_str = "? " + global.interpreter_input;
    } else {
        // We're in PAUSE mode
        input_str = global.interpreter_input;

        var curr_color = draw_get_color();
        var txt = "PAUSED...";
        var xx = room_width div 2;
        var yy = room_height div 2;

        draw_set_color(c_black);
        draw_text(xx - 1, yy - 1, txt);
        draw_text(xx + 1, yy - 1, txt);
        draw_text(xx - 1, yy + 1, txt);
        draw_text(xx + 1, yy + 1, txt);

        draw_set_color(c_yellow);
        draw_text(xx, yy, txt);

        draw_set_color(curr_color);
    }

    if (current_time mod 1000 < 500) input_str += "|";
    draw_text(16, y1, input_str);
    y1 += font_height;
}

// === END MESSAGE === //
if (global.program_has_ended) {
    draw_set_color(c_lime);
    draw_text(16, y1 + 16, "Program has ended - ESC or ENTER to return");
}

function basic_cmd_bgcolor(arg) {
    var colstr = string_upper(string_trim(arg));
    if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Raw argument: '" + arg + "', Normalized: '" + colstr + "'");
    
    var bg_color = c_black;
    var matched = false;

    // Look up named color
    if (ds_map_exists(global.colors, colstr)) {
        bg_color = global.colors[? colstr];
        matched = true;
        if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Matched named color → " + string(bg_color));
    }
    // RGB() syntax
   else if (string_pos("RGB(", colstr) == 1) {
    var l = string_pos("(", colstr), r = string_last_pos(")", colstr);
    if (r > l) {
        var inner = string_copy(colstr, l + 1, r - l - 1);
        var parts = []; var buf = ""; var _depth = 0;
        for (var i = 1; i <= string_length(inner); i++) {
            var ch = string_char_at(inner, i);
            if (ch == "(") _depth++; else if (ch == ")") _depth--;
            if (ch == "," && _depth == 0) { array_push(parts, buf); buf = ""; } else buf += ch;
        }
        array_push(parts, buf);
        if (array_length(parts) == 3) {
            var rV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[0]))), 0, 255);
            var gV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[1]))), 0, 255);
            var bV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[2]))), 0, 255);
            bg_color = make_color_rgb(rV, gV, bV); matched = true;
        } else if (dbg_on(DBG_FLOW))  {show_debug_message("BGCOLOR: Invalid RGB arg count in '" + inner + "'");}
    } else if (dbg_on(DBG_FLOW))  {show_debug_message("BGCOLOR: Missing ) in '" + colstr + "'");}
}
 else {
        if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: No matching named color or RGB format found for '" + colstr + "'");
    }

    global.background_draw_color = bg_color;
    global.background_draw_enabled = (bg_color != c_black);
	// NEW: also set Mode 1 bg so CLS (in Mode 1) will use it
	global.mode1_bg_color = bg_color;

    if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Final color set to " + string(bg_color) + ", background_draw_enabled: " + string(global.background_draw_enabled));
}

/// @function basic_array_set(name, idx, value)
/// @description Sets a value in a 1D array stored in global.basic_arrays (0-based indexing, auto-grows)
/// @param name  The name of the array (string)
/// @param idx   The index to set (0-based)
/// @param value The value to set
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_set(_name, _idx, _val) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET: Setting " + nm + "[" + string(_idx) + "] = " + string(_val));

    // Ensure the map entry exists and is a ds_list
    if (!ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET: Creating new ds_list for " + nm);
        global.basic_arrays[? nm] = ds_list_create();
    }

    var lst = global.basic_arrays[? nm];
    if (!ds_exists(lst, ds_type_list)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET: Replacing non-list backing store for " + nm);
        lst = ds_list_create();
        global.basic_arrays[? nm] = lst;
    }

    // Normalize index
    var idx = floor(real(_idx)); // integer index (use floor to avoid +1 surprises near boundaries)

    // OPTIONAL: hard-stop on negative indexes (comment this out if you prefer silent ignore)
    if (idx < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET ERROR: Negative index " + string(idx) + " for array " + nm);
        return;
    }

    // Grow to fit (fills with 0)
    while (ds_list_size(lst) <= idx) {
        ds_list_add(lst, 0);
        // OPTIONAL: verbose growth log (disable if noisy)
        // show_debug_message("ARRAY_SET: Growing " + nm + " to size " + string(ds_list_size(lst)));
    }

    // Assign
    ds_list_replace(lst, idx, _val);
    // OPTIONAL: confirmation log (disable if noisy)
    // show_debug_message("ARRAY_SET: Set " + nm + "[" + string(idx) + "] = " + string(_val));
}

/// pm_receive_text(text)
function pm_receive_text(_text) {
    // Compatibility shim for legacy script calling
    var text_in = _text;
    if (is_undefined(text_in)) {
        if (argument_count > 0) text_in = argument0; else text_in = "";
    }

   if (dbg_on(DBG_FLOW)) show_debug_message("[pm_receive_text] got len=" + string(is_string(text_in) ? string_length(text_in) : -1));
    if (!is_string(text_in) || string_length(text_in) <= 0) return 0;

    var t = string(text_in);
    t = string_replace_all(t, "\r\n", "\n");
    t = string_replace_all(t, "\r",   "\n");

    var arr = string_split(t, "\n");
    var count = 0;
    var auto_num = 10;

    for (var i = 0; i < array_length(arr); i++) {
        var raw = string_trim(arr[i]);
        if (raw == "") continue;

        // Treat a leading '+' as decoration (strip it)
        if (string_length(raw) >= 2 && string_char_at(raw, 1) == "+") {
            raw = string_delete(raw, 1, 1);
            raw = string_trim(raw);
        }

        var sp   = string_pos(" ", raw);
        var head = (sp > 0) ? string_copy(raw, 1, sp - 1) : raw;

        if (string_length(head) > 0 && is_real(real(head))) {
            var num  = real(head);
            var code = (sp > 0) ? string_trim(string_copy(raw, sp + 1, string_length(raw))) : "";
            if (function_exists(paste_line)) paste_line(num, code);
        } else {
            if (function_exists(paste_line)) paste_line(auto_num, raw);
            auto_num += 10;
        }
        count++;
    }

    if (instance_exists(obj_paste_manager)) with (obj_paste_manager) {
        _pm_msg = "Imported " + string(count) + " line(s).";
        _pm_msg_ttl = 180;
        _pm_visible = false;
    }

   if (dbg_on(DBG_FLOW)) show_debug_message("[pm_receive_text] imported lines=" + string(count));
    return count;
}

/// @helper _lint_illegal_remark_position(stmt_raw)
/// Returns >0 if a top-level REM or ' appears after code in the colon segment (illegal), else 0
function _lint_illegal_remark_position(stmt_raw) {
    var s   = stmt_raw;
    var L   = string_length(s);
    var inq = false;

    // Find first non-space char
    var head = 1;
    while (head <= L && string_char_at(s, head) == " ") head++;

    // If the segment *starts* with a remark, it's allowed
    if (head <= L) {
        if (string_char_at(s, head) == "'") return 0;
        if (head + 2 <= L && string_upper(string_copy(s, head, 3)) == "REM") return 0;
    }

    // Otherwise, scan for a top-level ' or REM token later in the segment
    for (var i = 1; i <= L; i++) {
        var ch = string_char_at(s, i);

        if (ch == "\"") { 
            // handle doubled quotes "" as a literal quote
            if (i < L && string_char_at(s, i + 1) == "\"") { i += 1; continue; }
            inq = !inq; 
            continue; 
        }

        if (!inq) {
            // Apostrophe found later → illegal
            if (ch == "'") return i;

            // Check for REM token at top level with word-ish boundaries
            if (i + 2 <= L && string_upper(string_copy(s, i, 3)) == "REM") {
                var prev = (i == 1) ? " " : string_char_at(s, i - 1);
                var next = (i + 3 <= L) ? string_char_at(s, i + 3) : " ";
                var prev_ok = (prev == " " || prev == ":");
                var next_ok = (next == " " || next == ":" || i + 3 > L);
                if (prev_ok && next_ok) {
                    // Since we already know it didn't start the segment, this is inline → illegal
                    return i;
                }
            }
        }
    }
    return 0;
}

// ===============================================
// FILE: scripts/screen_editor_commit_row_extended/screen_editor_commit_row_extended.gml
// NEW: Modified commit function that accepts full line text
// ===============================================

/// @function screen_editor_commit_row_extended(editor_inst, _row, line_text)
function screen_editor_commit_row_extended(editor_inst, _row, line_text) {
    with (editor_inst) {
        var trimmed_text = string_trim(line_text);
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Committing row " + string(_row) + ": '" + trimmed_text + "'");
        
        if (trimmed_text == "") return;
        
        if (string_upper(trimmed_text) == "EXIT") {
            screen_editor_exit(id);
            return;
        }
        
        var space_pos = string_pos(" ", trimmed_text);
        var line_num_str = "";
        var code = "";
        
        if (space_pos > 0) {
            line_num_str = string_copy(trimmed_text, 1, space_pos - 1);
            code = string_trim(string_copy(trimmed_text, space_pos + 1, string_length(trimmed_text)));
        } else {
            line_num_str = trimmed_text;
        }
        
        var line_num = real(line_num_str);
        if (line_num_str != "" && is_real(line_num) && line_num > 0) {
            if (code == "") {
                delete_program_line(line_num);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Deleted line " + string(line_num));
            } else {
                add_or_update_program_line(line_num, code);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Added/updated line " + string(line_num) + ": " + code);
            }
        }
    }
}
// === 2A. Create this as a separate script file (handle_inkey_input.gml) ===
/// @function handle_inkey_input()
/// @description Handle INKEY$ input during pause
function handle_inkey_input() {
    // Only process if we're in INKEY$ mode
    if (!global.inkey_mode) return false;
    
    // Scan for any printable key press
    for (var key = 32; key <= 126; key++) { // printable ASCII range
        if (keyboard_check_pressed(key)) {
            var ch = chr(key);
            
            // Store the result
            global.basic_variables[? "__INKEY_RESULT"] = ch;
            
            // Resume program execution
            global.pause_in_effect = false;
            global.awaiting_input = false;
            global.input_target_var = "";
            global.pause_mode = false;
            global.input_expected = false;
            global.inkey_mode = false;
            
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Got keypress '" + ch + "' (code " + string(key) + "), resuming program");
            return true; // Input was handled
        }
    }
    
    // Handle special keys if needed
    if (keyboard_check_pressed(vk_enter)) {
        global.basic_variables[? "__INKEY_RESULT"] = chr(13);
        // Resume execution (same cleanup as above)
        global.pause_in_effect = false;
        global.awaiting_input = false;
        global.input_target_var = "";
        global.pause_mode = false;
        global.input_expected = false;
        global.inkey_mode = false;
        
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Got ENTER, resuming program");
        return true;
    }
    
    return false; // No input yet, keep waiting
}
/// @function basic_cmd_charat(arg)
/// @desc CHARAT x, y, charIndex [, fg [, bg]]
function basic_cmd_charat(arg) {
    var args = basic_parse_csv_args(arg);
    if (array_length(args) < 3) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT requires 3 arguments: x, y, char");
        return;
    }

    // Evaluate coordinates (identifiers allowed)
    var _x = floor(real(basic_evaluate_expression_v2(string_trim(args[0]))));
    var _y = floor(real(basic_evaluate_expression_v2(string_trim(args[1]))));
    var char_index = floor(real(basic_evaluate_expression_v2(string_trim(args[2]))));

    // Optional colors
    var fg = (array_length(args) > 3) ? basic_parse_color(string_trim(args[3])) : undefined;
    var bg = (array_length(args) > 4) ? basic_parse_color(string_trim(args[4])) : undefined;

    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT: grid not found");
        return;
    }

    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _x >= cols || _y < 0 || _y >= rows) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT: coordinates out of bounds (" + string(_x) + "," + string(_y) + ")");
        return;
    }

    // If fg/bg are undefined, mode1_grid_set should keep existing cell colors
    mode1_grid_set(_x, _y, char_index, fg, bg);

    if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT: set (" + string(_x) + "," + string(_y) + ")=" + string(char_index)
        + ((fg != undefined) ? " fg=" + string(fg) : "")
        + ((bg != undefined) ? " bg=" + string(bg) : ""));
}

/// @event obj_editor/Create
// You can write your code in this editor
 // Program storage


 // Input handling
 current_input = "";               // Current line being typed
 cursor_pos = 0;                  // Text cursor position


 input_buffer = "";               // Buffer for key repeat handling
 // Display variables
 display_start_line = 0;          // For scrolling through program
 lines_per_screen = 20;           // How many lines to show
 font_height = 16;                // Adjust based on your font
 screen_width = room_width;
 screen_height = room_height;
 // Syntax highlighting settings
 syntax_highlighting = true;      // Toggle for syntax highlighting
 keyword_color = c_blue;          // Color for BASIC keywords
 text_color = c_green;            // Default text color
 number_color = c_yellow;         // Color for line numbers
 // State management
 editor_mode = "READY";           // States: "READY", "INPUT", "RUNNING"
 current_filename = "";           // For save/load operations
 // Keyboard handling
 last_keyboard_string = "";       // Track keyboard_string changes
 key_repeat_timer = 0;            // For handling key repeat timing
 // Undo system

 max_undo_levels = 20;            // Limit undo history
 // Message system
 message_text = "";
 message_timer = 0;
 
 drag_enabled = true;
 //show_debug_message("Working directory: " + working_directory);
keyboard_string = "";

//for directory listings
showing_dir_overlay = false;
dir_listing = [];

// Overlay for HTML DIR listing
show_dir_overlay = false;   // draw toggle
dir_cursor       = 0;       // selected row (0-based)

/// @function basic_cmd_font(arg)
/// @desc FONTSET "KEY" -> switch active font sprite by registry key
function basic_cmd_font(arg) {
    if (global.current_mode < 1) {
        basic_print_system_message("FONT not implemented in MODE " + string(global.current_mode));
        return;
    }

    var key = string_trim(arg);

    // Strip quotes if present
    if (string_length(key) >= 2) {
        var f = string_char_at(key,1);
        var l = string_char_at(key,string_length(key));
        if ((f == "\"" || f == "'") && f == l) key = string_copy(key,2,string_length(key)-2);
    }

    key = string_upper(key);

    if (!variable_global_exists("font_sheets")) {
        basic_print_system_message("FONT registry not initialized");
        return;
    }

    if (ds_map_exists(global.font_sheets, key)) {
        var spr = ds_map_find_value(global.font_sheets, key);
        global.active_font_name   = key;
        global.active_font_sprite = spr;

        // DEBUG: prove which sprite & how many subimages
        var n = sprite_get_number(spr);
        if (dbg_on(DBG_FLOW)) {
            show_debug_message("FONTSET: key=" + key
                + " spr_id=" + string(spr)
                + " subimages=" + string(n));
        }

        // Trigger a lightweight refresh (keeps existing fg/bg)
        global.grid_refresh_needed = true;
        global.grid_refresh_char   = 32; // space

    } else {
        basic_cmd_print("FONT " + key + " not found", false);
        if (dbg_on(DBG_FLOW)) show_debug_message("FONTSET: missing registry key '" + key + "'");
    }
}

function tokenize_expression(expr) {
    var tokens = [];
    var i = 1;
    while (i <= string_length(expr)) {
        var ch = string_char_at(expr, i);

        if (ch == " " || ch == "\t") {
            i++;
            continue;
        }

        if (ch == "+" || ch == "-" || ch == "*" || ch == "/" || ch == "^" || ch == "(" || ch == ")") {
            array_push(tokens, ch);
            i++;
        }
        else if (ord(ch) >= 48 && ord(ch) <= 57) {
            var num = "";
            while (i <= string_length(expr) && (ord(string_char_at(expr, i)) >= 48 && ord(string_char_at(expr, i)) <= 57)) {
                num += string_char_at(expr, i);
                i++;
            }
            array_push(tokens, num);
        }
        else if (is_letter(ch)) {
            var ident = "";
            while (i <= string_length(expr) && (is_letter_or_digit(string_char_at(expr, i)))) {
                ident += string_char_at(expr, i);
                i++;
            }
            if (string_char_at(expr, i) == "(") {
                array_push(tokens, ident); // Function name
            } else {
                array_push(tokens, ident); // Variable
            }
        }
        else if (ch == ",") {
            array_push(tokens, ",");
            i++;
        }
        else {
            if (dbg_on(DBG_FLOW)) show_debug_message("Unknown character in expression: " + ch);
            i++;
        }
    }

    return tokens;
}


/// @function basic_array_init(name, size)
/// @description Initializes a 1D array as a ds_list in global.basic_arrays
/// @param name The name of the array (string)
/// @param size The size of the array (number of elements)
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_init(_name, _size) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT: Initializing " + nm + " with size " + string(_size));

    // If the array already exists, destroy its backing list
    if (ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT WARNING: Array '" + nm + "' already exists, destroying");
        var old_lst = global.basic_arrays[? nm];
        if (ds_exists(old_lst, ds_type_list)) {
            ds_list_destroy(old_lst);
        }
        ds_map_delete(global.basic_arrays, nm);
    }

    // Normalize and validate size
    var sz = floor(real(_size));
    if (sz < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT ERROR: Invalid size " + string(sz) + " for " + nm);
        return;
    }

    // Create and fill
    var lst = ds_list_create();
    repeat (sz) {
        ds_list_add(lst, 0);
    }
    global.basic_arrays[? nm] = lst;

    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT: Created " + nm + " with size " + string(ds_list_size(lst)));
}

/// @event obj_basic_interpreter/Create

    global.debug_mask        = DBG_ALL;//0;//DBG_ALL;   // start verbose; you can trim later
    global.dbg_frame_quota   = 0;      // 1200 is ~20 logs per ms at 60fps is ok; tune as needed
    global.dbg_frame_count   = 0;
    global.dbg_dropped_count = 0;

// Set the current draw color
global.current_draw_color = global.basic_text_color;

// Use the shared global data structures
global.program_map  = global.basic_program; // optional if you're not modifying
global.line_list    = global.basic_line_numbers;

// Interpreter control variables
line_index = 0;                         // current line being executed
font_height = 16;

current_input = "";
cursor_pos = 0;
last_keyboard_string = "";

global.interpreter_current_line_index = 0;
global.interpreter_next_line = -1;

// Local list to hold current run if needed
interpreter_current_program = ds_list_create(); // OK to keep local

basic_run_to_console_flag = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
    global.help_topics = ds_list_create();
} else {
    ds_list_clear(global.help_topics);
}

// PRINT tab stop width (classic BASIC style)
if (is_undefined(global.print_zone)) global.print_zone = 14;



// =================================================================
// LOCATE command - set cursor position for next PRINT
// =================================================================
function basic_cmd_locate(arg) {
    if (global.current_mode < 1) {
        // In text mode, just ignore or show message
        if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE: Not implemented in text mode");
        return;
    }
    
    var args = basic_parse_csv_args(arg);
    if (array_length(args) < 2) {
        if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE requires 2 arguments: row, col");
        return;
    }
    
    var row = real(basic_evaluate_expression_v2(string_trim(args[0])));
    var col = real(basic_evaluate_expression_v2(string_trim(args[1])));
    
    // BASIC typically uses 1-based coordinates, convert to 0-based
    row = max(0, min(24, row - 1));
    col = max(0, min(39, col - 1));
    
    // Store cursor position in globals for PRINT to use
    global.mode1_cursor_x = col;
    global.mode1_cursor_y = row;
    
    if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE: Set cursor to (" + string(col) + "," + string(row) + ")");
}
show_debug_message("SCREEN_EDITOR: Create start");

// Sizing (keep your existing numbers if different)
char_width  = 16;
char_height = 24;
margin_x    = 8;
margin_y    = 8;

// Dynamic screen size
screen_cols = floor((room_width  - (margin_x * 2)) / char_width);
screen_rows = floor((room_height - (margin_y * 2) - 40) / char_height);

show_debug_message("SCREEN_EDITOR: Calculated screen size - " + string(screen_cols) + "x" + string(screen_rows) +
                   " (room: " + string(room_width) + "x" + string(room_height) + ")");

// Backing char buffer (your renderer already expects this)
screen_buffer = array_create(screen_cols * screen_rows, ord(" "));

// Cursor & scroll
cursor_x = 0;
cursor_y = 0;
horizontal_offset = 0;
scroll_margin = 5;
scroll_offset = 0;

// Caret blink
blink_timer = 0;
cursor_visible = true;

// NEW: live text buffer for the current row in this view
current_input = "";

// Pull program into buffer for display
screen_editor_load_program(id);

keyboard_string = ""; // start clean

show_debug_message("SCREEN_EDITOR: Create complete - " + string(screen_cols) + "x" + string(screen_rows) + " buffer");

// Clear background
draw_set_color(c_black);
draw_rectangle(0, 0, room_width, room_height, false);

// Font/color
if (font_exists(fnt_basic)) draw_set_font(fnt_basic);
draw_set_color(make_color_rgb(255,191,64)); // your C64 yellow

// Draw any backing buffer you still use (safe-guarded)
if (is_array(screen_buffer)) {
    for (var _y = 0; _y < screen_rows; _y++) {
        for (var _x = 0; _x < screen_cols; _x++) {
            var idx = _x + _y * screen_cols;
            if (idx < array_length(screen_buffer)) {
                var ch = chr(screen_buffer[idx]);
                if (ch != " ") {
                    var draw_x = margin_x + (_x * char_width);
                    var draw_y = margin_y + (_y * char_height);
                    draw_text(draw_x, draw_y, ch);
                }
            }
        }
    }
}

// Draw caret on top of the existing buffer (no row_text/current_row)
if (cursor_visible) {
    draw_set_color(c_white);
    var caret_x = margin_x + (cursor_x * char_width);
    var caret_y = margin_y + (cursor_y * char_height);
    draw_text(caret_x, caret_y, "_");
}

/// help_restore_program()
function help_restore_program() {
    if (!variable_global_exists("help_snapshot_lines")) return;

    // wipe current
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // restore
    var key = ds_map_find_first(global.help_snapshot_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.help_snapshot_lines, key);
        ds_map_add(global.program_lines, key, val);
        key = ds_map_find_next(global.help_snapshot_lines, key);
    }
    for (var i = 0; i < ds_list_size(global.help_snapshot_nums); i++) {
        ds_list_add(global.line_numbers, ds_list_find_value(global.help_snapshot_nums, i));
    }

    // clean snapshot
    ds_map_destroy(global.help_snapshot_lines);
    ds_list_destroy(global.help_snapshot_nums);
    global.help_snapshot_lines = undefined;
    global.help_snapshot_nums  = undefined;
}


/// @file scripts/basic_cmd_return/basic_cmd_return.gml
function basic_cmd_return() {
    if (ds_stack_empty(global.gosub_stack)) {
        basic_syntax_error("RETURN without matching GOSUB",
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_MISMATCH");
        return;
    }

    var frame = ds_stack_pop(global.gosub_stack);

    // Backward-compat: older frames were numeric line indexes
    if (is_real(frame)) {
        global.interpreter_next_line = frame;
        return;
    }

    // === CHANGE: statement-level resume ===
    if (is_struct(frame) && frame.kind == "stmt") {
        global.interpreter_use_stmt_jump = true;
        global.interpreter_target_line  = frame.line_index;
        global.interpreter_target_stmt  = max(0, frame.stmt_index);
        return;
    }

    // Fallback: if unknown, behave like legacy
    global.interpreter_next_line = is_real(frame) ? frame : (line_index + 1);
}

/// @function string_is_number(str)
/// @desc Returns true if the input string can be safely converted to a number.
/// @param {string} str - The string to check
function string_is_number(str) {
    if (is_real(str)) return true; // Already a number
    var trimmed = string_trim(str);
    if (trimmed == "") return false;

    var dot_found = false;
    var start = 1;

    // Allow for optional leading minus sign
    if (string_char_at(trimmed, 1) == "-") {
        if (string_length(trimmed) == 1) return false;
        start = 2;
    }

    for (var i = start; i <= string_length(trimmed); i++) {
        var ch = string_char_at(trimmed, i);
        if (ch >= "0" && ch <= "9") continue;
        else if (ch == ".") {
            if (dot_found) return false; // only one dot allowed
            dot_found = true;
        } else {
            return false;
        }
    }

    return true;
}

/// @function string_split_spaces(str)
/// @desc Split on one or more whitespace chars; returns array of tokens (no quotes handling).
function string_split_spaces(str) {
    var s = string(str);
    var L = string_length(s);
    var out = array_create(0);
    var i = 1;

    while (i <= L) {
        // skip whitespace
        while (i <= L) {
            var ch = string_char_at(s, i);
            if (ch != " " && ch != "	" && ch != chr(13) && ch != chr(10)) break;
            i++;
        }
        if (i > L) break;

        var start = i;
        while (i <= L) {
            var ch2 = string_char_at(s, i);
            if (ch2 == " " || ch2 == "	" || ch2 == chr(13) || ch2 == chr(10)) break;
            i++;
        }
        var token = string_copy(s, start, i - start);
        out[array_length(out)] = token;
    }
    return out;
}

/// @function split_on_unquoted_colons(line)
/// @description Split a line on top-level colons, ignoring any inside "quoted strings"
function split_on_unquoted_colons(line) {
    var parts = [];
    var buf    = "";
    var inStr  = false;
    var len    = string_length(line);
    for (var i = 1; i <= len; i++) {
        var ch = string_char_at(line, i);
        if (ch == "\"") {
            // toggle string state and keep the quote
            inStr = !inStr;
            buf  += ch;
        }
        else if (ch == ":" && !inStr) {
            // top-level colon → break here
            array_push(parts, buf);
            buf = "";
        }
        else {
            buf += ch;
        }
    }
    // push whatever’s left
    array_push(parts, buf);
    return parts;
}

/// pm_paste_handler(data, name, type)
function pm_paste_handler(_data, _name, _type) {
    // Text if name is undefined
    if (is_undefined(_name)) {
        if (is_string(_data) && string_length(_data) > 0) {
            pm_receive_text(_data);
        } else {
           if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Text handler: empty or non-string payload.");
        }
    } else {
        // You pasted a file; ignore for now (or handle base64 here)
       if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] File paste ignored: " + string(_name) + " (" + string(_type) + ")");
    }

    // Unbind so we don't keep intercepting Ctrl/Cmd+V forever
    var _bind = asset_get_index("browser_paste_bind");
    if (_bind != -1) script_execute(_bind);
}

function safe_real_pop(stack) {
    if (array_length(stack) < 1) return 1;

    var raw = array_pop(stack);

    // Pass through real values
    if (is_real(raw)) return raw;

    // Try to convert string safely
    var str = string(raw);
    var tryval = real(str);

    if (is_nan(tryval)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("? safe_real_pop: Cannot convert '" + string(raw) + "' to number. Returning 0.");
        return 0;
    }

    // Handle invalid conversions like real("RND:")
    if (!is_numeric_string(str)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("? POSTFIX ERROR: Cannot convert to number: '" + str + "'");
        return 1; // or return 0 if you prefer a neutral fallback
    }

    return tryval;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function save_program_json(filename) {
    try {
        var save_data = ds_map_create();
        ds_map_copy(save_data, global.program_lines);
        
        var json_string = json_encode(save_data);
        var file_path = working_directory + filename + ".json";
        var file = file_text_open_write(file_path);
        file_text_write_string(file, json_string);
        file_text_close(file);
        
        ds_map_destroy(save_data);
        basic_show_message("SAVED: " + filename + " (JSON)");
    } catch (e) {
        show_error_message("JSON SAVE ERROR");
    }
 }
/// @function editor_html_save_selftest()
function editor_html_save_selftest() {
    if (function_exists("browser_file_tools_init")) browser_file_tools_init();
    if (!function_exists("browser_show_save_dialog")) {
        show_error_message("Save dialog function not present.");
        return;
    }
    var s = "HELLO\r\n";
    var n = string_length(s);
    var b = buffer_create(n, buffer_fixed, 1);
    for (var i = 1; i <= n; i++) buffer_write(b, buffer_u8, ord(string_char_at(s, i)));
    buffer_seek(b, buffer_seek_start, 0);
    browser_show_save_dialog(b, "selftest.bas", "text/plain; charset=utf-8", n);
    buffer_delete(b);
    basic_show_message("Save self-test offered.");
}

/// @function mode1_grid_set(x, y, ch, fg, bg)
/// @desc Update a grid cell with char + optional fg/bg colors
function mode1_grid_set(_x, _y, _char, _fg, _bg) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return;

    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _x >= cols || _y < 0 || _y >= rows) return;

    var idx = _x + _y * cols;
    var cell = grid_obj.grid[idx];

    // Always set the glyph
    cell.char = _char;

    // Only change colors if the caller supplied them
    if (_fg != undefined) cell.fg = _fg;
    if (_bg != undefined) cell.bg = _bg;

    grid_obj.grid[idx] = cell;
}

// ===============================================
// FILE: scripts/screen_editor_clear_row/screen_editor_clear_row.gml
// NEW: Helper function to clear a display row
// ===============================================

/// @function screen_editor_clear_row(editor_inst, _row)
function screen_editor_clear_row(editor_inst, _row) {
    with (editor_inst) {
        if (_row < 0 || _row >= screen_rows) return;
        for (var _x = 0; _x < screen_cols; _x++) {
            screen_editor_set_char_at(id, _x, _row, ord(" "));
        }
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cleared row " + string(_row));
    }
}
/// basic_normvar(name) -> canonical variable key
function basic_normvar(_name) {
    return string_upper(string_trim(string(_name)));
}

/// basic_looks_numeric(s) -> bool  (no regex; robust enough for BASIC)
function basic_looks_numeric(_s) {
    var s = string_trim(string(_s));
    if (s == "") return false;
    var digits = 0;
    for (var i = 1; i <= string_length(s); i++) {
        var c = ord(string_char_at(s, i));
        if ((c >= 48 && c <= 57)) digits++;                     // 0..9
        else if (c == 46 || c == 45) { /* '.' or leading '-' */ }
        else return false;
    }
    return digits > 0;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function insert_line_number_ordered(new_line_num) {
    var size = ds_list_size(global.line_numbers);
    var inserted = false;
    
    for (var i = 0; i < size; i++) {
        if (ds_list_find_value(global.line_numbers, i) > new_line_num) {
            ds_list_insert(global.line_numbers, i, new_line_num);
            inserted = true;
            break;
      }
    }
    
    if (!inserted) {
        ds_list_add(global.line_numbers, new_line_num);
    }
 }
/// Remove single quote comments, unless inside double quotes
function strip_basic_remark(arg) {
    var len = string_length(arg);
    var inside_string = false;

    for (var i = 1; i <= len; i++) {
        var c = string_char_at(arg, i);

        if (c == "\"") {
            inside_string = !inside_string;
        }
        else if (c == "'" && !inside_string) {
            // Found unquoted remark start – strip everything after
            return string_trim(string_copy(arg, 1, i - 1));
        }
    }

    // No unquoted remark found – return original
    return arg;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_line_number(str) {
    // Check if string contains only digits
    if (string_length(str) == 0) return false;
    
    for (var i = 1; i <= string_length(str); i++) {
        var char = string_char_at(str, i);
        if (char < "0" || char > "9") return false;
    }
    
    // Convert to number and validate range
    var line_num = real(str);
    return (line_num >= 1 && line_num <= 65535);
 }
// FILE: scripts/screen_editor_set_char_at/screen_editor_set_char_at.gml
/// @function screen_editor_set_char_at(editor_inst, _x, _y, _char)
function screen_editor_set_char_at(editor_inst, _x, _y, _char) {
    with (editor_inst) {
        if (_x < 0 || _x >= screen_cols || _y < 0 || _y >= screen_rows) return;
        var idx = _y * screen_cols + _x;
        screen_buffer[idx] = _char;
        //show_debug_message("SCREEN_EDITOR: Set char '" + chr(_char) + "' at (" + string(_x) + "," + string(_y) + ")");
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function new_program() {
    // Save state for undo before clearing
    if (ds_list_size(global.line_numbers) > 0) {
        save_undo_state();
    }
    
    ds_map_clear(global.program_lines);
    ds_list_clear(global.line_numbers);
    current_filename = "";
    display_start_line = 0;
    update_display();
    basic_show_message("NEW PROGRAM");
 }
/// @function mode1_get_char(col, row)
/// @description Get character at grid position
function mode1_get_char(col, row) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return 32;
    
    var cols = 40;
    var rows = 25;
    
    if (col < 0 || col >= cols || row < 0 || row >= rows) {
        return 32; // Return space for out of bounds
    }
    
    var i = col + row * cols;
    return grid_obj.grid[i].char;
}
/// Destroys previous records and clears the list.
function editor_html_dir__reset() {
    if (!variable_global_exists("html_dir_files")) {
        global.html_dir_files = ds_list_create();
        return;
    }
    var n = ds_list_size(global.html_dir_files);
    for (var i = 0; i < n; i++) {
        var rec = global.html_dir_files[| i];
        if (ds_exists(rec, ds_type_map)) ds_map_destroy(rec);
    }
    ds_list_clear(global.html_dir_files);
}

// FILE: scripts/screen_editor_get_char_at/screen_editor_get_char_at.gml
/// @function screen_editor_get_char_at(editor_inst, _x, _y)
function screen_editor_get_char_at(editor_inst, _x, _y) {
    with (editor_inst) {
        if (_x < 0 || _x >= screen_cols || _y < 0 || _y >= screen_rows) return ord(" ");
        var idx = _y * screen_cols + _x;
        return screen_buffer[idx];
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function delete_program_line(line_num) {
    ds_map_delete(global.program_lines, line_num);
    var pos = ds_list_find_index(global.line_numbers, line_num);
    if (pos != -1) {
        ds_list_delete(global.line_numbers, pos);
    }
 }
function basic_cmd_end() {
    if (dbg_on(DBG_FLOW)) show_debug_message("END: Program termination requested");
    global.program_has_ended = true;
    global.interpreter_running = false;
	 global.current_mode = 0;
    if (dbg_on(DBG_FLOW)) show_debug_message("END: interpreter_running set to false");
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function new_program_without_undo() {
    ds_map_clear(global.program_lines);
    ds_list_clear(global.line_numbers);
    current_filename = "";
    display_start_line = 0;
 }
function resolve_basic_value(key) {
    var k = basic_normvar(key); // normalize before lookup
    return ds_map_exists(global.basic_variables, k)
        ? global.basic_variables[? k]
        : real(key);             // keep your original fallback
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_valid_line_number(line_num) {
    return (line_num >= 1 && line_num <= global.config[? "max_line_number"]);
 }

// FILE: objects/obj_screen_editor/Destroy_0.gml
// REMOVE: Delete the entire Destroy event or replace with:

/// @event Destroy
// No cleanup needed - reverted to simple implementation
show_debug_message("SCREEN_EDITOR: Destroying");
function is_quoted_string(str) {
    return (string_length(str) >= 2 &&
            string_char_at(str, 1) == "\"" &&
            string_char_at(str, string_length(str)) == "\"");
}

/// @event obj_globals/Step
if (room == rm_editor) {
    if (!instance_exists(obj_editor)) {
        instance_create_layer(0, 0, "Instances", obj_editor);
    }
}


// Optional helper for errors: prefix message with a "?" as classic BASIC did.
function basic_show_error_message(err) {
    basic_show_message("?" + err);
}



function is_letter(ch) {
    var o = ord(string_upper(ch));
    return (o >= 65 && o <= 90);
}



function basic_cmd_rem() {
    // Do nothing — comment line
}

function quit_program()
{
	game_end();
}



