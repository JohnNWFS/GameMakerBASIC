function infix_to_postfix(tokens) {
    show_debug_message("Converting to postfix: " + string(tokens));

    var output = [];
    var stack  = [];

    // Local helper: safe uppercase
    var _TOKU = function(_t) { return string_upper(string(_t)); };

    // Local helper: append array contents to another array
    var _push_all = function(_dst, _src) {
        for (var __i = 0; __i < array_length(_src); __i++) {
            array_push(_dst, _src[__i]);
        }
    };

    for (var i = 0; i < array_length(tokens); i++) {
        var t  = tokens[i];        // raw token
        // Ignore commas as separators — functions handle arg order explicitly
        if (t == ",") {
            show_debug_message("INFIX: Skipping comma token");
            continue;
        }

        var tu = _TOKU(t);         // uppercased string form

        // ==========================================================
        // 1) ARRAY READ COLLAPSE — NAME ( balanced stuff )  →  "NAME(...)"
        //    (skip if NAME is a known function)
        // ==========================================================
        if (is_string(t)) {
            var first = string_char_at(t, 1);
            var can_be_name = is_letter(first);

            if (can_be_name
            &&  i + 1 < array_length(tokens)
            &&  tokens[i + 1] == "("
            && !is_function(t)) // do not collapse functions
            {
                var _depth   = 0;
                var j       = i + 1;
                var inner   = "";
                var matched = false;

                show_debug_message("INFIX: Candidate for array collapse → '" + string(t) + "' followed by '('");

                while (j < array_length(tokens)) {
                    var tk = tokens[j];
                    if (tk == "(") {
                        _depth++;
                        if (_depth > 1) inner += tk;
                    } else if (tk == ")") {
                        _depth--;
                        if (_depth == 0) { matched = true; break; }
                        inner += tk;
                    } else {
                        inner += tk;
                    }
                    j++;
                }

                if (matched) {
                    var collapsed = string(t) + "(" + inner + ")";
                    array_push(output, collapsed);
                    show_debug_message("INFIX: Collapsed array read token → '" + collapsed + "' (consumed through index " + string(j) + ")");
                    i = j; // skip to ')'
                    continue;
                } else {
                    show_debug_message("INFIX: WARNING — unmatched '(' after '" + string(t) + "'. Not collapsing.");
                }
            }
        }

        // ==========================================================
        // 2) NUMERIC LITERAL
        // ==========================================================
        if (is_numeric_string(t)) {
            array_push(output, t);
            show_debug_message("Added number to output: " + string(t));
            continue;
        }

        // ==========================================================
        // 3) KNOWN VARIABLE (already in global.basic_variables)
        // ==========================================================
        if (ds_map_exists(global.basic_variables, tu)) {
            array_push(output, tu);
            show_debug_message("Added variable name to output: " + tu);
            continue;
        }

        // ==========================================================
        // 4) OPEN PAREN
        // ==========================================================
        if (t == "(") {
            array_push(stack, t);
            show_debug_message("Pushed '(' onto operator stack");
            continue;
        }

        // ==========================================================
        // 5) CLOSE PAREN
        // ==========================================================
        if (t == ")") {
            while (array_length(stack) > 0 && stack[array_length(stack) - 1] != "(") {
                var popped_close = array_pop(stack);
                array_push(output, popped_close);
                show_debug_message("Popped '" + string(popped_close) + "' from stack to output (closing ')')");
            }
            if (array_length(stack) > 0 && stack[array_length(stack) - 1] == "(") {
                array_pop(stack); // discard '('
                show_debug_message("Discarded matching '(' from stack");
            } else {
                show_debug_message("INFIX: WARNING — stray ')' with no matching '('");
            }
            continue;
        }

        // ==========================================================
        // 6) OPERATORS (+ - * / % MOD ^ etc.)
        // ==========================================================
        if (is_operator(t)) {
            show_debug_message("Found operator: " + string(t));

            while (array_length(stack) > 0) {
                var top = stack[array_length(stack) - 1];
                if (is_operator(top) && (
                    get_precedence(top) > get_precedence(t) ||
                    (get_precedence(top) == get_precedence(t) && !is_right_associative(t))
                )) {
                    var popped_op = array_pop(stack);
                    array_push(output, popped_op);
                    show_debug_message("Popped higher/equal precedence operator '" + string(popped_op) + "' to output");
                } else {
                    break;
                }
            }

            array_push(stack, t);
            show_debug_message("Pushed operator '" + string(t) + "' onto stack");
            continue;
        }

        // ==========================================================
        // 7) FUNCTIONS
        // ==========================================================
        if (is_function(t)) {
            var fn_name = tu;

            // ------------------------------------------------------
            // 7a) NEW: Balanced 1-arg function handler for non-RND
            //     Handles cases like INT( RND(1,6) ), ABS(A+B*C) etc.
            //     We scan for the matching ')' and recursively convert
            //     the inner tokens with THIS same function.
            // ------------------------------------------------------
            if (i + 1 < array_length(tokens) && tokens[i + 1] == "(" && fn_name != "RND") {
                var depthB  = 0;
                var jB      = i + 1;
                var matchedB = false;

                // Find matching ')'
                while (jB < array_length(tokens)) {
                    var tkB = tokens[jB];
                    if (tkB == "(") { depthB++; }
                    else if (tkB == ")") { depthB--; if (depthB == 0) { matchedB = true; break; } }
                    jB++;
                }

                if (matchedB) {
                    // Extract inner tokens (between the outermost '(' and ')')
                    var inner_tokens = [];
                    for (var kB = i + 2; kB <= jB - 1; kB++) {
                        array_push(inner_tokens, tokens[kB]);
                    }

                    // Convert inner expression to postfix and append
                    var inner_post = infix_to_postfix(inner_tokens);
                    _push_all(output, inner_post);

                    // Push the function itself
                    array_push(output, fn_name);
                    show_debug_message("Processed balanced 1-arg function: " + fn_name + "(...)");

                    i = jB; // consume up to ')'
                    continue;
                }
                // If we didn't match, fall through to existing logic below
            }

            // ------------------------------------------------------
            // 7b) RND(min, max) handling for complex arguments
            // ------------------------------------------------------
            if (fn_name == "RND") {
                if (i + 1 < array_length(tokens) && tokens[i + 1] == "(") {
                    var _depth = 0;
                    var j = i + 1;
                    var matched = false;
                    var arg_tokens = [[]]; // Array of token lists for each argument
                    var arg_index = 0;

                    // Collect tokens until matching ')'
                    while (j < array_length(tokens)) {
                        var tk = tokens[j];
                        if (tk == "(") {
                            _depth++;
                            if (_depth > 1) array_push(arg_tokens[arg_index], tk);
                        } else if (tk == ")") {
                            _depth--;
                            if (_depth == 0) { matched = true; break; }
                            array_push(arg_tokens[arg_index], tk);
                        } else if (tk == "," && _depth == 1) {
                            arg_index++;
                            array_push(arg_tokens, []);
                        } else {
                            array_push(arg_tokens[arg_index], tk);
                        }
                        j++;
                    }

                    if (matched) {
                        if (array_length(arg_tokens) == 1 && array_length(arg_tokens[0]) == 0) {
                            // Empty parens: RND()
                            array_push(output, "1");
                            array_push(output, "RND1");
                            show_debug_message("Processed empty RND() → default to RND(1)");
                            i = j;
                            continue;
                        } else if (array_length(arg_tokens) == 1) {
                            // One arg: RND(n)
                            var inner_post = infix_to_postfix(arg_tokens[0]);
                            _push_all(output, inner_post);
                            array_push(output, "RND1");
                            show_debug_message("Processed RND(n): " + string(arg_tokens[0]));
                            i = j;
                            continue;
                        } else if (array_length(arg_tokens) == 2) {
                            // Two args: RND(min, max)
                            var min_post = infix_to_postfix(arg_tokens[0]);
                            var max_post = infix_to_postfix(arg_tokens[1]);
                            _push_all(output, min_post);
                            _push_all(output, max_post);
                            array_push(output, "RND2");
                            show_debug_message("Processed RND(min,max): " + string(arg_tokens[0]) + ", " + string(arg_tokens[1]));
                            i = j;
                            continue;
                        }
                    }
                    // Malformed RND call
                    show_debug_message("Malformed RND call at token '" + string(t) + "' — passing through");
                    array_push(output, t);
                    i = j;
                    continue;
                } else {
                    // RND without parentheses
                    show_debug_message("? Function 'RND' used without parentheses. Defaulting to RND(1) behavior.");
                    array_push(output, "1");
                    array_push(output, "RND1");
                    continue;
                }
            }

            // ------------------------------------------------------
            // 7c) Existing special cases for other functions
            // ------------------------------------------------------
            // Function used WITHOUT parentheses → fallback behavior (fn(1))
            if (i + 1 >= array_length(tokens) || tokens[i + 1] != "(") {
                show_debug_message("? Function '" + string(t) + "' used without parentheses. Defaulting to " + fn_name + "(1) behavior.");
                array_push(output, "1");
                array_push(output, fn_name);
                continue;
            }

            // Empty parens like REPEAT$()
            if (i + 2 < array_length(tokens) && tokens[i + 1] == "(" && tokens[i + 2] == ")") {
                show_debug_message("Function " + fn_name + "() with no args not supported (non-RND) — passing token through");
                array_push(output, t);
                i += 2;
                continue;
            }

            // REPEAT$(s, n) — exactly 2 args (simple positional form)
            if (fn_name == "REPEAT$") {
                show_debug_message("REPEAT$ DEBUG: i=" + string(i) + ", total=" + string(array_length(tokens)));
                if (i + 5 < array_length(tokens)
                &&  tokens[i + 1] == "("
                &&  tokens[i + 3] == ","
                &&  tokens[i + 5] == ")")
                {
                    var rq1 = tokens[i + 2];
                    var rq2 = tokens[i + 4];
                    array_push(output, rq1);
                    array_push(output, rq2);
                    array_push(output, fn_name);
                    show_debug_message("Processed REPEAT$(s,n): args = " + string(rq1) + ", " + string(rq2));
                    i += 5;
                } else {
                    show_debug_message("Malformed REPEAT$ call starting at token '" + string(t) + "'");
                    array_push(output, t);
                }
                continue;
            }

            // MID$(s, start, len) — 3 args
            if (fn_name == "MID$") {
                show_debug_message("MID$ DEBUG: i=" + string(i) + ", total tokens=" + string(array_length(tokens)));
                if (i + 7 < array_length(tokens)
                &&  tokens[i + 1] == "("
                &&  tokens[i + 3] == ","
                &&  tokens[i + 5] == ","
                &&  tokens[i + 7] == ")")
                {
                    var ma1 = tokens[i + 2];
                    var ma2 = tokens[i + 4];
                    var ma3 = tokens[i + 6];
                    array_push(output, ma1);
                    array_push(output, ma2);
                    array_push(output, ma3);
                    array_push(output, fn_name);
                    show_debug_message("Processed MID$(s,start,len): " + string(ma1) + ", " + string(ma3));
                    i += 7;
                } else {
                    show_debug_message("Malformed MID$ call starting at token '" + string(t) + "'");
                    array_push(output, t);
                }
                continue;
            }

            // LEFT$/RIGHT$ (2 args)
            if ((fn_name == "LEFT$" || fn_name == "RIGHT$")
            &&  i + 5 < array_length(tokens)
            &&  tokens[i + 1] == "("
            &&  tokens[i + 3] == ","
            &&  tokens[i + 5] == ")")
            {
                var la1 = tokens[i + 2];
                var la2 = tokens[i + 4];
                array_push(output, la1);
                array_push(output, la2);
                array_push(output, fn_name);
                show_debug_message("Processed " + fn_name + "(arg1,arg2): " + string(la1) + ", " + string(la2));
                i += 5;
                continue;
            }

            // Fallback: malformed function call
            show_debug_message("Malformed function call: " + string(t));
            array_push(output, t);
            continue;
        }

        // ==========================================================
        // 8) UNKNOWN TOKEN — pass through (evaluator often tolerates)
        // ==========================================================
        show_debug_message("Unknown token, adding to output: " + string(t));
        array_push(output, t);
    }

    // ==========================================================
    // Drain operator stack
    // ==========================================================
    while (array_length(stack) > 0) {
        var tail = array_pop(stack);
        array_push(output, tail);
        show_debug_message("Drained operator stack → appended '" + string(tail) + "'");
    }

    show_debug_message("Final postfix: " + string(output));
    return output;
}
// obj_basic_interpreter → Step Event
global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}

// WATCHDOG: are output buffers DS lists this frame?
/*var _ol = global.output_lines;
var _oc = global.output_colors;
show_debug_message(
    "WATCH: out_lines=" + string(_ol) +
    " is_real=" + string(is_real(_ol)) +
    " exists=" + string(is_real(_ol) && ds_exists(_ol, ds_type_list)) +
    " | out_colors=" + string(_oc) +
    " is_real=" + string(is_real(_oc)) +
    " exists=" + string(is_real(_oc) && ds_exists(_oc, ds_type_list))
);

*/

// ==============================
// Sort program lines in ascending order
// ==============================
if (ds_exists(global.line_list, ds_type_list)) {
    ds_list_sort(global.line_list, true);
}

// ==============================
// === Program Ended: Wait for user action ===
// ==============================
if (global.program_has_ended) {
    if (keyboard_check_pressed(vk_pageup)) {
        global.scroll_offset = max(global.scroll_offset - 1, 0);
    }
    if (keyboard_check_pressed(vk_pagedown)) {
        var font_height = string_height("A");
        var visible_lines = floor(room_height / font_height) - 2;
        var total_lines = ds_list_size(global.output_lines);
        global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines - visible_lines));
    }

    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
        global.program_has_ended = false;
        global.current_mode = 0;
        room_goto(global.editor_return_room);
    }
    return;
}

// ==============================
// === Handle INPUT or PAUSE ===
// ==============================
if (global.awaiting_input) {
    if (global.pause_mode) {
        if (keyboard_check_pressed(vk_enter)) {
            global.awaiting_input = false;
            global.pause_mode = false;
            global.input_target_var = "";
            global.interpreter_input = "";
        }
    } else {
        for (var _k = 32; _k <= 126; _k++) {
            if (keyboard_check_pressed(_k)) handle_interpreter_character_input(_k);
        }
        if (keyboard_check_pressed(vk_enter))     handle_interpreter_character_input(vk_enter);
        if (keyboard_check_pressed(vk_backspace)) handle_interpreter_character_input(vk_backspace);
    }
    return;
}

// ==============================
// === Synchronize for structured IF…ELSE handling ===
// Ensure handlers read the correct current line index
// ==============================
global.interpreter_current_line_index = line_index;

// ==============================
// === Handle Jumps (statement-first, then legacy line jump) ===
// These are set by commands like IF/GOTO (line jump) and NEXT (stmt jump, new)
// ==============================
if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
    show_debug_message("JUMP: Using statement-level jump → line="
        + string(global.interpreter_target_line) + ", stmt="
        + string(global.interpreter_target_stmt));

    // Jump to requested line
    line_index = global.interpreter_target_line;
    global.interpreter_current_line_index = global.interpreter_target_line;

    // Tell the dispatcher which statement on that line to resume at
    global.interpreter_resume_stmt_index = max(0, global.interpreter_target_stmt);

    // Clear stmt-jump flags
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line = -1;
    global.interpreter_target_stmt = 0;

    // Ensure legacy jump is cleared when stmt-jump is used
    global.interpreter_next_line = -1;

} else if (global.interpreter_next_line >= 0) {
    show_debug_message("JUMP: Using legacy line jump → line="
        + string(global.interpreter_next_line));

    // Legacy behavior: jump to a new line, start at first statement
    line_index = global.interpreter_next_line;
    global.interpreter_current_line_index = global.interpreter_next_line;

    global.interpreter_resume_stmt_index = 0;
    global.interpreter_next_line = -1;
}

// ==============================
// === End of Program Check ===
// ==============================
if (line_index >= ds_list_size(global.line_list)) {
    global.interpreter_running = false;
}

// ==============================
// === Execute BASIC Line ===
// ==============================
if (line_index < ds_list_size(global.line_list)) {
    // Fetch the next line of BASIC
    var line_number = ds_list_find_value(global.line_list, line_index);
    var code        = ds_map_find_value(global.program_map, line_number);

    // Trim and split on unquoted, top-level colons
    var trimmed = string_trim(code);
    var parts   = split_on_unquoted_colons(trimmed);

    // Dispatch each sub-statement in turn
    global.current_line_number = line_number;
    show_debug_message("Running line " + string(line_number));

    // NEW: resume at a specific statement index (set by stmt-level jump)
    var _start_stmt = 0;
    if (global.interpreter_resume_stmt_index > 0) {
        _start_stmt = global.interpreter_resume_stmt_index;
        show_debug_message("Resuming at statement index " + string(_start_stmt)
            + " on line " + string(line_number));
        // One-shot consumption: reset after applying
        global.interpreter_resume_stmt_index = 0;
    }

	for (var p = _start_stmt; p < array_length(parts); p++) {
	    var stmt = string_trim(parts[p]);
	    if (stmt == "") continue;

	    // Strip BASIC-style REM
	    stmt = strip_basic_remark(stmt);

	    // Pull off the verb vs. its argument
	    var sp2  = string_pos(" ", stmt);
	    var cmd2 = (sp2 > 0)
	                 ? string_upper(string_copy(stmt, 1, sp2 - 1))
	                 : string_upper(stmt);
	    var arg2 = (sp2 > 0)
	                 ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt)))
	                 : "";

	    // >>> NEW: tell commands which colon-slot we're on <<<
	    global.interpreter_current_stmt_index = p;

	    show_debug_message("Command: " + cmd2 + " | Arg: " + arg2);
	    handle_basic_command(cmd2, arg2);


        // If any jump was requested, stop processing further parts on this line

        // 1) Statement-level jump (inline FOR/NEXT loop body, etc.)
        if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
            show_debug_message("Breaking line loop to honor STATEMENT-LEVEL jump request");
            break;
        }

        // 2) Legacy line jump (IF/GOTO/etc.)
        if (global.interpreter_next_line >= 0) {
            show_debug_message("Breaking line loop to honor LINE jump request");
            break;
        }
    }

    // If no jump was requested, advance to the next line
    if (!(global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0)
     && !(global.interpreter_next_line >= 0)) {
        line_index++;
    }
}
else {
    global.interpreter_running = false;
}

// ==============================
// === Escape Returns to Editor ===
// ==============================
if (keyboard_check_pressed(vk_escape)) {
    global.current_mode = 0;
    room_goto(global.editor_return_room);
}

// ==============================
// === F5 Dumps BASIC to Console ===
// ==============================
if (keyboard_check_released(vk_f5) && basic_run_to_console_flag == false) {
    basic_run_to_console_flag = true;
    basic_run_to_console();
}

// ==============================
// === Manual Scroll (Always Available) ===
// ==============================
if (keyboard_check_pressed(vk_pageup)) {
    global.scroll_offset = max(global.scroll_offset - 1, 0);
}
if (keyboard_check_pressed(vk_pagedown)) {
    var font_height2 = string_height("A");
    var visible_lines2 = floor(room_height / font_height2) - 2;
    var total_lines2 = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);
    global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines2 - visible_lines2));
}

/// @script dbg_macros.gml
#macro DBG_PARSE  1     // tokenizer, parser, DIM/LET parsing
#macro DBG_EVAL   2     // postfix eval, expression values
#macro DBG_FLOW   4     // IF/WHILE/GOTO/GOSUB flow
#macro DBG_IO     8     // INPUT/PRINT/UI prompts
#macro DBG_ARRAY  16    // array get/set, DIM
#macro DBG_ALL    0x7fffffff

/*
DEBUG MASKING — HOW TO USE (READ THIS FIRST)
============================================

## WHAT THIS FILE IS

These `#macro` lines define **compile-time constants** used to *categorize* your
debug logs. They are simple bit flags (1, 2, 4, …) that you OR together to
decide which kinds of messages should print at runtime.

```
#macro DBG_PARSE  1     // tokenizer & parser chatter
#macro DBG_EVAL   2     // postfix evaluation & expression results
#macro DBG_FLOW   4     // IF/WHILE/WEND/GOTO/GOSUB decisions
#macro DBG_IO     8     // INPUT/PRINT/UI prompts & commits
#macro DBG_ARRAY  16    // DIM + array get/set + bounds logs
#macro DBG_ALL    0x7fffffff  // convenience: everything on
```

> IMPORTANT: Macros must live at **top level** (not inside a function). Keep
> this file as-is; don’t wrap these lines in a function.

## REQUIRED COMPANION (dbg.gml)

You also have two helper functions defined in `dbg.gml`:

```
function dbg_on(cat) -> bool
    // Returns TRUE if the category bit is enabled in global.debug_mask.
    // Very cheap; use around *occasional* logs.

function dbg(cat, msg) -> void
    // Prints a message if the category bit is enabled AND you haven’t
    // exceeded the per-frame quota. Use inside tight loops to avoid FPS hits.
```

Both helpers rely on these globals, which you should initialize once in your
interpreter’s Create/Init event:

```
if (!variable_global_exists("debug_mask")) {
    global.debug_mask        = DBG_ALL;   // start verbose; tune later
    global.dbg_frame_quota   = 1200;      // max logs per frame before dropping
    global.dbg_frame_count   = 0;         // internal counter (do not set manually)
    global.dbg_dropped_count = 0;         // internal counter (do not set manually)
}
```

And reset the quota each frame (Step Start of the interpreter object):

```
global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}
```

## HOW TO WRAP EXISTING LOGS

You have hundreds of `show_debug_message(...)` calls. Wrap them gradually:

• High-volume / in loops (tokenizer, postfix, array hot-paths) → **use `dbg()`**
This enforces the per-frame quota automatically.
BEFORE:
show\_debug\_message("TOKENIZER: Char\[" + string(i) + "]='" + c + "'");
AFTER:
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "]='" + c + "'");

• Low-volume / occasional (flow decisions, one-off prints) → **use `dbg_on()`**
This is a tiny mask check; then you call `show_debug_message` yourself.
BEFORE:
show\_debug\_message("WEND: Condition is TRUE — looping");
AFTER:
if (dbg\_on(DBG\_FLOW)) show\_debug\_message("WEND: Condition is TRUE — looping");

Tip: It’s fine to mix both styles. Prefer `dbg()` anywhere that can spam.

## WHAT EACH MASK MEANS (AND WHERE TO USE IT)

• DBG\_PARSE
Use on: tokenizer (`basic_tokenize_expression_v2`), parser/splitters,
command lexing (verb/arg extraction).
Goal: see how text becomes tokens. No evaluation yet.

• DBG\_EVAL
Use on: postfix creation/evaluation, math/operator application, variable loads.
Goal: see stack pushes/pops and numeric/string results.

• DBG\_FLOW
Use on: `basic_cmd_if/_if_inline`, `basic_cmd_while`, `basic_cmd_wend`,
loop stack push/pop, `GOTO/GOSUB/RETURN` target resolution.
Goal: follow control flow decisions and jumps.

• DBG\_IO
Use on: `basic_cmd_input`, `basic_cmd_print`, wrapping/commit pipeline,
prompt emission, input state flips.
Goal: ensure prompts and outputs render and input mode is toggled correctly.

• DBG\_ARRAY
Use on: `basic_cmd_dim`, `basic_array_get`, `basic_array_set`, bounds checks.
Goal: track sizes, indices, auto-grow, and OOB warnings.

• DBG\_ALL
Convenience macro: enable all categories at once.

## HOW TO TURN CATEGORIES ON/OFF

At runtime (debugger Watch window, a script, or once in Create):

```
// All off:
global.debug_mask = 0;

// Only FLOW:
global.debug_mask = DBG_FLOW;

// Only IO:
global.debug_mask = DBG_IO;

// FLOW + IO together:
global.debug_mask = DBG_FLOW | DBG_IO;

// Everything on:
global.debug_mask = DBG_ALL;
```

You can also toggle bits on the fly:

```
// Flip the PARSE bit:
global.debug_mask ^= DBG_PARSE;
```

If you temporarily cranked the quota for a heavy trace, put it back:

```
global.dbg_frame_quota = 1200;    // typical safe value
// (set larger, e.g., 100000, if you want to capture *everything* for a short run)
```

## OPTIONAL: QUICK HOTKEY TO CYCLE VERBOSITY

Add this to the interpreter object’s Step (or Step Begin):

```
if (keyboard_check_pressed(vk_f9)) {
    var next = (global.debug_mask == 0)
        ? (DBG_FLOW | DBG_IO)   // useful day-to-day
        : (global.debug_mask == (DBG_FLOW | DBG_IO) ? DBG_ALL : 0);
    global.debug_mask = next;
    show_debug_message("DBG: mask now = " + string(next));
}
```

## COMMON PITFALLS & TIPS

• Macros not recognized → Ensure this file (`dbg_macros.gml`) is a separate
script asset with **only** the `#macro` lines at top level. If you still see
“variable not defined” on a macro name, **Clean** the project and rebuild.

• Compile order → Place `dbg_macros.gml` near the top of your Scripts folder so
everything else sees it. (Macros are compile-time, but ordering can trip
partial rebuilds.)

• Use `dbg()` for anything inside loops; it’s quota-aware. If you use
`dbg_on()` + `show_debug_message(...)` in a hot loop you can still tank FPS.

• Migration strategy → You don’t need to wrap everything at once. Start with:
tokenizer (DBG\_PARSE), evaluation (DBG\_EVAL), flow (DBG\_FLOW). That usually
kills 90% of the spam while keeping the most actionable signal.

## EXAMPLES (COPY/PASTE)

Tokenizer char echo (quota-aware):
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "] = '" + string\_char\_at(s, i) + "'");

Flow decision:
if (dbg\_on(DBG\_FLOW))
show\_debug\_message("IF: result=" + string(result) + " → " + (result ? "THEN" : "ELSE"));

Input prompt emission:
dbg(DBG\_IO, "INPUT: Prompt='" + rawPrompt + "' → var=" + varName);

Array set:
dbg(DBG\_ARRAY, "ARRAY SET: " + name + "\[" + string(idx) + "] = " + string(val));

## QUICK START

1. Keep these macros here (top level).
2. Ensure `dbg.gml` exists with `dbg_on` and `dbg`.
3. Initialize the globals in Create, reset counters in Step Start.
4. Wrap high-volume logs with `dbg(cat, msg)`, occasional logs with `dbg_on`.
5. Control verbosity by setting `global.debug_mask` at runtime:
   • All off: 0
   • Only FLOW: DBG\_FLOW
   • Only IO: DBG\_IO
   • FLOW + IO: DBG\_FLOW | DBG\_IO
   • Everything: DBG\_ALL
6. If things feel slow, reduce the mask and/or lower `global.dbg_frame_quota`.

That’s it. You keep the power of your detailed logs without drowning the Runner.
*/

function basic_tokenize_expression_v2(expr) {
    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting expression: '" + expr + "'");

    var tokens = [];
    var i = 1;
    var len = string_length(expr);
    var current = "";

    var function_names = ["RND", "ABS", "EXP", "LOG", "LOG10", "SGN", "INT", "SIN", "COS", "TAN", "STR$", "CHR$", "REPEAT$"];

    while (i <= len) {
        var c = string_char_at(expr, i);
//        show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");
		if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");
		

        // --- STRING LITERAL SUPPORT (preserve exact quoted content) ---
        if (c == "\"") {
            var str = "\"";
            i++;
            while (i <= len) {
                var ch = string_char_at(expr, i);
                str += ch;
                if (ch == "\"") break;
                i++;
            }
            array_push(tokens, str);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added (quoted string): " + str);
            i++;
            continue;
        }

        // --- Handle whitespace ---
        if (c == " ") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token from space: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            i++;
            continue;
        }

        // --- Handle operators ---
        if (c == "+" || c == "*" || c == "/" || c == "(" || c == ")" || c == "%") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before operator: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            if (c == "(" && array_length(tokens) > 0) {
                var last = string_upper(tokens[array_length(tokens) - 1]);
                if (array_contains(function_names, last)) {
                    array_push(tokens, "(");
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Function call detected: " + last + "(");
                } else {
                    array_push(tokens, "(");
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);
                }
            } else {
                array_push(tokens, c);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);
            }
            i++;
            continue;
        }

        // --- Handle commas ---
        if (c == ",") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before comma: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, ",");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Comma token added");
            i++;
            continue;
        }

        // --- Handle subtraction/negative numbers ---
        if (c == "-") {
            var is_negative_number = false;
            if (i < len && (ord(string_char_at(expr, i + 1)) >= 48 && ord(string_char_at(expr, i + 1)) <= 57)) {
                // Check if - is followed by a digit
                if (array_length(tokens) == 0 || current != "") {
                    // If no tokens yet or current is non-empty (e.g., after a variable), treat as subtraction
                    if (current != "") {
                        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before subtraction: '" + current + "'");
                        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                        current = "";
                    }
                    array_push(tokens, "-");
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Subtraction operator token added: -");
                } else {
                    // After an operator or parenthesis, treat as negative number
                    var last_token = tokens[array_length(tokens) - 1];
                    if (last_token == "+" || last_token == "-" || last_token == "*" || 
                        last_token == "/" || last_token == "(" || last_token == "%" || 
                        string_upper(last_token) == "MOD") {
                        is_negative_number = true;
                    }
                }
            } else {
                // Lone - or followed by non-digit is always subtraction
                if (current != "") {
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before subtraction: '" + current + "'");
                    array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                    current = "";
                }
                array_push(tokens, "-");
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Subtraction operator token added: -");
            }

            if (is_negative_number) {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Beginning negative number with '-'");
                current += "-";
            }
            i++;
            continue;
        }

        // --- Accumulate characters for identifiers or numbers ---
        current += c;
        i++;
    }

    // --- Finalize any remaining token ---
    if (current != "") {
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing last token: '" + current + "'");
        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Final token list = " + string(tokens));
    return tokens;
}
/// @function basic_cmd_let(arg)
/// @description BASIC LET/assignment with array support (D(I)=expr), scalars, and string literals.
/// Notes:
/// - Array indices are evaluated via basic_evaluate_expression_v2 and stored with basic_array_set (1-based).
/// - Safeguards unmatched parentheses and empty pieces to avoid hard crashes.

function basic_cmd_let(arg) {
    show_debug_message("LET: Raw input: '" + string(arg) + "'");

    // ---------------------------
    // 1) Split "name = expr"
    // ---------------------------
    var eq_pos = string_pos("=", arg);
    if (eq_pos <= 0) {
        show_debug_message("LET ERROR: No '=' found in input: " + string(arg));
        return;
    }

    // Normalize name and expression text
    var varname = string_upper(string_trim(string_copy(arg, 1, eq_pos - 1)));
    var expr    = string_trim(string_copy(arg, eq_pos + 1, string_length(arg) - eq_pos));

    show_debug_message("LET: Parsed variable name: '" + varname + "'");
    show_debug_message("LET: Parsed expression    : '" + expr + "'");

    if (varname == "") {
        show_debug_message("LET ERROR: Empty variable name before '='");
        return;
    }
    if (expr == "") {
        show_debug_message("LET WARNING: Empty expression after '='; treating as empty string");
        global.basic_variables[? varname] = "";
        return;
    }

    // -----------------------------------------------
    // 2) String-literal assignment (double quotes)
    // -----------------------------------------------
    if (string_length(expr) >= 2
    &&  string_char_at(expr, 1) == "\""
    &&  string_char_at(expr, string_length(expr)) == "\"")
    {
        var str_val = string_copy(expr, 2, string_length(expr) - 2);
        global.basic_variables[? varname] = str_val;
        show_debug_message("LET: Assigned string value: '" + str_val + "' to '" + varname + "'");
        return;
    }

    // ---------------------------------------------------
    // 3) Array assignment: NAME( index_expr ) = value_expr
    //     - Works for VAR( I ), VAR( 1+J ), etc.
    // ---------------------------------------------------
    var openPos = string_pos("(", varname);
    if (openPos > 0) {
        // Ensure trailing ')'
        if (string_char_at(varname, string_length(varname)) != ")") {
            show_debug_message("LET WARNING: Array syntax missing ')': '" + varname + "'. Falling back to scalar assignment.");
        } else {
            // Extract array name and raw index text (allow spaces inside)
            var arrName = string_copy(varname, 1, openPos - 1);
            var idxText = string_copy(varname, openPos + 1, string_length(varname) - openPos - 1);
            // strip trailing ')' if still present due to odd spacing
            if (string_length(idxText) > 0 && string_char_at(idxText, string_length(idxText)) == ")") {
                idxText = string_delete(idxText, string_length(idxText), 1);
            }

            arrName = string_upper(string_trim(arrName));
            idxText = string_trim(idxText);

            if (arrName == "" || idxText == "") {
                show_debug_message("LET WARNING: Malformed array target. arrName='" + arrName + "', idxText='" + idxText + "'. Falling back to scalar.");
            } else {
                // Evaluate index and value via the standard expression pipeline
                var idxVal   = basic_evaluate_expression_v2(idxText);
                var valueVal = basic_evaluate_expression_v2(expr);

                // Defensive: if idxVal is not numeric, bail gracefully
                if (!is_real(idxVal)) {
                    show_debug_message("LET ERROR: Array index evaluated to non-numeric '" + string(idxVal) + "' from '" + idxText + "'");
                    return;
                }

                // Perform 1-based array set via your helper
                basic_array_set(arrName, idxVal, valueVal);
                show_debug_message("LET: Assigned array '" + arrName + "(" + string(idxVal) + ")' = " + string(valueVal));
                return;
            }
        }
        // If we got here, array syntax was malformed; continue to scalar handling below
    }

    // ---------------------------------------------------
    // 4) Scalar numeric / expression assignment (fallback)
    // ---------------------------------------------------
    var result = basic_evaluate_expression_v2(expr);

    // We don’t force-type; whatever evaluate returns is stored
    global.basic_variables[? varname] = result;

    if (is_string(result)) {
        show_debug_message("LET: Assigned string value: '" + string(result) + "' to '" + varname + "'");
    } else {
        show_debug_message("LET: Assigned numeric value: " + string(result) + " to '" + varname + "'");
    }
}

/// @script build_if_block_map
/// @description Scan basic_program for IF…ELSEIF…ELSE…ENDIF block structure,
///              but skip inline IFs so they don’t trigger mismatches.

function build_if_block_map() {
    // 1) Destroy any old map
    if (variable_global_exists("if_block_map") && ds_exists(global.if_block_map, ds_type_map)) {
        ds_map_destroy(global.if_block_map);
    }
    global.if_block_map = ds_map_create();

    // 2) Temp stack for nested block IFs
    var openStack = ds_stack_create();
    var total     = ds_list_size(global.basic_line_numbers);

    // 3) Walk every line
    for (var idx = 0; idx < total; idx++) {
        var lineNum = global.basic_line_numbers[| idx];
        var rawText = string_trim(global.basic_program[? lineNum]);
        var text    = string_upper(rawText);
        var sp      = string_pos(" ", text);
        var kw      = (sp > 0) ? string_copy(text, 1, sp - 1) : text;

        switch (kw) {
            case "IF":
                // detect inline IF: IF … THEN <command> on same line
                var thenPos = string_pos("THEN", text);
                var after   = (thenPos > 0)
                              ? string_trim(string_copy(rawText, thenPos + 4, string_length(rawText)))
                              : "";
                if (thenPos > 0 && string_length(after) > 0) {
                    // Inline IF → skip block indexing entirely
                    show_debug_message("INLINE IF skip at line " + string(lineNum));
                    break;
                }
                // Block IF → record it
                var info = ds_map_create();
                ds_map_add(info, "startIndex",       idx);
                ds_map_add(info, "elseifIndices",    ds_list_create());
                ds_map_add(info, "elseIndex",        -1);
                ds_map_add(info, "endifIndex",       -1);
                ds_map_add(info, "firstBranchIndex", idx + 1);
                ds_stack_push(openStack, info);
                break;

            case "ELSEIF":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_top(openStack);
                    ds_list_add(top[? "elseifIndices"], idx);
                } else {
                    show_debug_message("?MISMATCH ERROR: ELSEIF at line " + string(lineNum) + " without IF");
                }
                break;

            case "ELSE":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_top(openStack);
                    ds_map_replace(top, "elseIndex", idx);
                } else {
                    show_debug_message("?MISMATCH ERROR: ELSE at line " + string(lineNum) + " without IF");
                }
                break;

            case "ENDIF":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_pop(openStack);
                    ds_map_replace(top, "endifIndex", idx);

                    // recompute firstBranchIndex
                    var eList = top[? "elseifIndices"];
                    var fb = (ds_list_size(eList) > 0)
                             ? eList[| 0]
                             : ((top[? "elseIndex"] >= 0) ? top[? "elseIndex"] : idx);
                    ds_map_replace(top, "firstBranchIndex", fb);

                    ds_map_add(global.if_block_map, top[? "startIndex"], top);
                } else {
                    show_debug_message("?MISMATCH ERROR: ENDIF at line " + string(lineNum) + " without IF");
                }
                break;
        }
    }

    // 4) Any unclosed IFs left on the stack?
    while (!ds_stack_empty(openStack)) {
        var orphan = ds_stack_pop(openStack);
        var startIdx  = orphan[? "startIndex"];
        var startLine = global.basic_line_numbers[| startIdx];
        show_debug_message("?MISMATCH ERROR: IF at line " + string(startLine) + " missing ENDIF");
        ds_map_destroy(orphan);
    }
    ds_stack_destroy(openStack);

    show_debug_message("Built IF block map with " + string(ds_map_size(global.if_block_map)) + " entries.");
}

/// @script basic_cmd_elseif
/// @description Handle an ELSEIF in a block‐structured IF…THEN…ELSEIF…ELSE…ENDIF chain
function basic_cmd_elseif(arg) {
    show_debug_message("ELSEIF START — Raw arg: '" + arg + "'");
    
    // ── GUARD 1: Must have an open IF on the stack ──
    if (ds_stack_empty(global.if_stack)) {
        show_debug_message("?ELSEIF ERROR: ELSEIF without matching IF");
        return;
    }
    
    // 1) Where are we in the program?
    var current_index = global.interpreter_current_line_index;
    
    // 2) Peek the top IF‐frame
    var frame = ds_stack_top(global.if_stack);
    
    // ── GUARD 2: Must have block metadata for this IF ──
    if (!ds_map_exists(global.if_block_map, frame[? "startIndex"])) {
        show_debug_message("?ELSEIF ERROR: No IF‐block metadata (bad nesting?)");
        return;
    }
    
    var taken       = frame[? "takenBranch"];
    var elseif_list = frame[? "elseifIndices"]; // ds_list of all ELSEIF positions
    var else_index  = frame[? "elseIndex"];
    var endif_index = frame[? "endifIndex"];
    
    // 3) Find which ELSEIF this is
    var pos = ds_list_find_index(elseif_list, current_index);
    if (pos < 0) {
        show_debug_message("?ELSEIF ERROR: Unexpected ELSEIF at index " + string(current_index));
        return;
    }
    
    // 4) If we’ve already taken a branch, skip straight through
    if (taken) {
        // decide next jump: next ELSEIF, or ELSE, or ENDIF
        var next_index = -1;
        if (pos < ds_list_size(elseif_list) - 1) {
            next_index = elseif_list[| pos + 1];
        } else if (else_index >= 0) {
            next_index = else_index;
        } else {
            next_index = endif_index;
        }
        global.interpreter_next_line = next_index;
        show_debug_message("ELSEIF skipping to index " + string(next_index));
        return;
    }
    
    // 5) Parse and evaluate this ELSEIF’s condition
    var raw      = string_trim(arg);
    var upperRaw = string_upper(raw);
    var then_pos = string_pos("THEN", upperRaw);
    if (then_pos <= 0) {
        show_debug_message("?ELSEIF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var cond_text = string_trim(string_copy(raw, 1, then_pos - 1));
    show_debug_message("Parsed ELSEIF condition: '" + cond_text + "'");
    
    // Reuse your AND/OR logic from basic_cmd_if
    var result = false;
    var logic_op = "";
    var upcond   = string_upper(cond_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";
    if (logic_op != "") {
        var parts = string_split(cond_text, logic_op);
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        show_debug_message("Combined ELSEIF (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(cond_text);
        show_debug_message("ELSEIF single condition result: " + string(result));
    }
    
    // 6) If it’s true, mark the frame as “taken” and fall into this block…
    if (result) {
        frame[? "takenBranch"] = true;
        global.interpreter_next_line = current_index + 1;
        show_debug_message("ELSEIF TRUE: entering branch at index " + string(global.interpreter_next_line));
    } else {
        // …otherwise skip to the next ELSEIF/ELSE/ENDIF
        var next_index = (pos < ds_list_size(elseif_list) - 1)
                         ? elseif_list[| pos + 1]
                         : (else_index >= 0 ? else_index : endif_index);
        global.interpreter_next_line = next_index;
        show_debug_message("ELSEIF FALSE: skipping to index " + string(next_index));
    }
}

/// @description Cleanup all global DS structures at game end

// ─────────────────────────────
// MAPS
// ─────────────────────────────
if (ds_exists(global.basic_variables, ds_type_map)) ds_map_destroy(global.basic_variables);
if (ds_exists(global.program_lines, ds_type_map)) ds_map_destroy(global.program_lines);
if (ds_exists(global.basic_program, ds_type_map)) ds_map_destroy(global.basic_program);
if (ds_exists(global.program_map, ds_type_map)) ds_map_destroy(global.program_map);
if (ds_exists(global.colors, ds_type_map)) ds_map_destroy(global.colors);


// ─────────────────────────────
// ARRAYS
// ─────────────────────────────
if (ds_exists(global.basic_arrays, ds_type_map)) {
    // Destroy each backing list…
    var _key = ds_map_find_first(global.basic_arrays);
    while (!is_undefined(_key)) {
        var _lst = global.basic_arrays[? _key];
        ds_list_destroy(_lst);
        _key = ds_map_find_next(global.basic_arrays, _key);
    }
    // Then destroy the map itself
    ds_map_destroy(global.basic_arrays);
}


// ─────────────────────────────
// LISTS
// ─────────────────────────────
if (ds_exists(global.line_list, ds_type_list)) ds_list_destroy(global.line_list);
if (ds_exists(global.line_numbers, ds_type_list)) ds_list_destroy(global.line_numbers);

if (variable_global_exists("basic_line_numbers")) {
    if (ds_exists(global.basic_line_numbers, ds_type_list)) {
        ds_list_destroy(global.basic_line_numbers);
    }
}

if (ds_exists(global.undo_stack, ds_type_list)) ds_list_destroy(global.undo_stack);
if (ds_exists(global.output_lines, ds_type_list)) ds_list_destroy(global.output_lines);
if (ds_exists(global.output_colors, ds_type_list)) ds_list_destroy(global.output_colors);
if (ds_exists(global.input_history, ds_type_list)) ds_list_destroy(global.input_history);

// ─────────────────────────────
// STACKS
// ─────────────────────────────
if (ds_exists(global.gosub_stack, ds_type_stack)) ds_stack_destroy(global.gosub_stack);
if (ds_exists(global.for_stack, ds_type_stack)) ds_stack_destroy(global.for_stack);
if (ds_exists(global.while_stack, ds_type_stack)) ds_stack_destroy(global.while_stack);

// ─────────────────────────────
// TEMPORARY LIST (used in interpreter object)
// ─────────────────────────────
if (variable_global_exists("interpreter_current_program")) {
    if (ds_exists(interpreter_current_program, ds_type_list)) {
        ds_list_destroy(interpreter_current_program);
    }
}

// ─────────────────────────────
// Buffer & State Cleanup
// ─────────────────────────────
global.print_line_buffer = "";
global.editor_spawned = false;

/// @function basic_cmd_dim(rest)
/// @description DIM NAME(expr) or DIM NAME1(expr1), NAME2(expr2), ...
/// Allocates 1-D arrays in global.basic_arrays as zero-filled ds_lists.
/// Semantics: inclusive upper bound like C64 — DIM A(10) => valid indices 0..10.
/// Notes:
/// - Safe alongside LET auto-grow: DIM preallocates; LET keeps working the same.
/// - Multiple arrays supported, comma-separated at top level (commas inside () are ignored).
function basic_cmd_dim(rest) {
    var s  = string_trim(rest);
    if (s == "") {
        show_debug_message("DIM ERROR: Missing arguments");
        return;
    }

    // Ensure array registry exists
    if (is_undefined(global.basic_arrays)) {
        global.basic_arrays = ds_map_create();
        show_debug_message("DIM: Created global.basic_arrays map");
    }

    // Split on top-level commas (ignore commas inside parentheses or quotes)
    var defs = [];
    {
        var _depth = 0;
        var in_q  = false;
        var start = 1;
        for (var i = 1; i <= string_length(s); i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { in_q = !in_q; }
            if (!in_q) {
                if (ch == "(") _depth++;
                else if (ch == ")") _depth = max(0, _depth - 1);
                else if (ch == "," && _depth == 0) {
                    array_push(defs, string_trim(string_copy(s, start, i - start)));
                    start = i + 1;
                }
            }
        }
        // tail
        if (start <= string_length(s)) {
            array_push(defs, string_trim(string_copy(s, start, string_length(s) - start + 1)));
        }
    }

    // Process each NAME(expr)
    for (var d = 0; d < array_length(defs); d++) {
        var item = defs[d];
        if (item == "") continue;

        var openPos  = string_pos("(", item);
        var closePos = string_last_pos(")", item);

        if (openPos <= 0 || closePos <= openPos) {
            show_debug_message("DIM ERROR: Expected NAME(expr), got: " + item);
            continue;
        }

        var nm_raw  = string_trim(string_copy(item, 1, openPos - 1));
        var nm      = string_upper(nm_raw);
        var lenExpr = string_copy(item, openPos + 1, (closePos - openPos - 1));
        var lenVal  = basic_evaluate_expression_v2(lenExpr);

        if (!is_real(lenVal)) {
            show_debug_message("DIM ERROR: Length expression not numeric for " + nm + " -> [" + lenExpr + "]");
            continue;
        }

        var n    = floor(max(0, lenVal));
        var size = n + 1; // inclusive upper bound (0..n)

        // Replace any existing ds_list to avoid leaks
        if (ds_map_exists(global.basic_arrays, nm)) {
            var _old = global.basic_arrays[? nm];
            if (ds_exists(_old, ds_type_list)) {
                ds_list_destroy(_old);
            }
        }

        // Create and zero-fill list
        var lst = ds_list_create();
        for (var i = 0; i < size; i++) ds_list_add(lst, 0);

        global.basic_arrays[? nm] = lst;

        show_debug_message("DIM: " + nm + " sized to " + string(size) + " (indices 0.." + string(n) + ")"
            + " | lenExpr=[" + lenExpr + "] -> " + string(lenVal));
    }
}

function basic_cmd_print(arg, line_number) {

if (!ds_exists(global.output_lines, ds_type_list))  global.output_lines  = ds_list_create();
if (!ds_exists(global.output_colors, ds_type_list)) global.output_colors = ds_list_create();





	var suppress_newline = false;

    // Check for and remove trailing semicolon
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        show_debug_message("PRINT: Trailing semicolon detected; suppressing newline");
    }

    arg = string_trim(arg);
    var output = "";

    // Split into parts by semicolon for multi-part print
   var parts = split_on_unquoted_semicolons(arg);


    for (var i = 0; i < array_length(parts); i++) {
        var part = string_trim(parts[i]);

        if (part == "") continue;

        var treat_as_literal = false;

        if (is_quoted_string(part)) {
            var inner = string_copy(part, 2, string_length(part) - 2);
            if (!string_pos("+", inner) && !string_pos("-", inner) && !string_pos("*", inner) && !string_pos("/", inner)) {
                treat_as_literal = true;
            }
        }

        if (treat_as_literal) {
            output += string_copy(part, 2, string_length(part) - 2);
            show_debug_message("PRINT: Part " + string(i) + " is string literal → " + string_copy(part, 2, string_length(part) - 2));
        } else {
            show_debug_message("PRINT: Part " + string(i) + " is expression → " + part);
            var tokens = basic_tokenize_expression_v2(part);
            show_debug_message("PRINT: Tokens = " + string(tokens));

            var postfix = infix_to_postfix(tokens);
            show_debug_message("PRINT: Postfix = " + string(postfix));

            var result = evaluate_postfix(postfix);
            show_debug_message("PRINT: Evaluated result = " + string(result));

		if (is_real(result)) {
		    if (frac(result) == 0) {
		        output += string(round(result)); // whole number → no decimal
		    } else {
		        output += string_format(result, 12, 8); // retain full format for decimals
		    }
		} else {
		    output += string(result);
		}

        }
    }

    // Append to line buffer with wrap
    var wrap_width = 40;
    var full_line = global.print_line_buffer + output;

	while (string_length(full_line) > wrap_width) {
	    var line = string_copy(full_line, 1, wrap_width);
	    ds_list_add(global.output_lines, line);
	    ds_list_add(global.output_colors, global.current_draw_color);
	    full_line = string_copy(full_line, wrap_width + 1, string_length(full_line) - wrap_width);
	}


    global.print_line_buffer = full_line;

    if (!suppress_newline) {
		basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        show_debug_message("PRINT: Line committed → " + global.print_line_buffer);
        global.print_line_buffer = "";
    } else {
        show_debug_message("PRINT: Output buffered without newline → " + global.print_line_buffer);
    }
}

if (global.justreturned == 1) {
    current_input = "";
    cursor_pos = 0;
    keyboard_string = "";
    global.justreturned = 0;
    exit; // skip the rest of this Step event
}

if (showing_dir_overlay) {
    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
        showing_dir_overlay = false;
        dir_listing = []; // Clear the array
    }
    exit; // prevent editor interaction while overlay is up
}




// Handle Enter key
if (keyboard_check_pressed(vk_enter)) {
    add_to_history(current_input);
    process_input_line(current_input);
    current_input = "";
    cursor_pos = 0;
    global.history_index = -1;
    input_buffer = keyboard_string; // reset keyboard buffer
}

 else if (keyboard_check_released(vk_backspace)) {
    if (cursor_pos > 0) {
        current_input = string_delete(current_input, cursor_pos, 1);
        cursor_pos--;
    }
 }
 else if (keyboard_check_pressed(vk_left)) {
    cursor_pos = max(0, cursor_pos - 1);
 }
 else if (keyboard_check_pressed(vk_right)) {
    cursor_pos = min(string_length(current_input), cursor_pos + 1);
 }
 else if (keyboard_check_pressed(vk_up)) {
    navigate_history_up();
 }
 else if (keyboard_check_pressed(vk_down)) {
    navigate_history_down();
 }
 else if (keyboard_check_pressed(vk_pageup)) {
    display_start_line = max(0, display_start_line - lines_per_screen);
 }
 else if (keyboard_check_pressed(vk_pagedown)) {
    var max_start = max(0, ds_list_size(global.line_numbers) - lines_per_screen);
    display_start_line = min(max_start, display_start_line + lines_per_screen);
 }
 else if (keyboard_check(vk_control) && keyboard_check_pressed(ord("Z"))) {
    undo_last_change();
 }
 else if (keyboard_check(vk_f5)) {
    dump_program_to_console();
	basic_show_message("Dumped program to Console");	 
 }
 else {
    // Handle character input with repeat
    handle_character_input();
 }
 
  // In Step Event
 if (message_timer > 0) {
    message_timer--;
    if (message_timer <= 0) {
        message_text = "";
    }
 }
 
/*  // Add to Step event
 if (drag_enabled && drag_files > 0) {
    var file_path = drag_file[0];
    if (string_pos(".bas", string_lower(file_path)) > 0) {
        // Extract filename without path and extension
        var filename_start = 1;
        for (var i = string_length(file_path); i >= 1; i--) {
            if (string_char_at(file_path, i) == "/" || string_char_at(file_path, i) == "\\") {
                filename_start = i + 1;
                break;
            }
        }
        var full_filename = string_copy(file_path, filename_start, string_length(file_path));
        var dot_pos = string_pos(".", full_filename);
        var filename = string_copy(full_filename, 1, dot_pos - 1);
        
        load_program_from_path(file_path, filename);
    }
    drag_clear();
 }

*/

/// @description obj_basic_interpreter Draw interpreter output and current input
draw_set_font(fnt_basic);

// === BACKGROUND === //
if (global.background_draw_enabled) {
    draw_set_color(global.background_draw_color);
    draw_rectangle(0, 0, room_width, room_height, false);
}

var font_height = string_height("A");
var visible_lines = floor(room_height / font_height) - 2;
var total_lines = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);

// === SCROLL MANAGEMENT === //
if (!global.scroll_lock && global.interpreter_running && !global.awaiting_input && !global.program_has_ended) {
    global.scroll_offset = max(0, total_lines - visible_lines);
}
global.scroll_offset = clamp(global.scroll_offset, 0, max(0, total_lines - visible_lines));

// === OUTPUT TEXT === //
var y1 = 0;
for (var i = global.scroll_offset; i < ds_list_size(global.output_lines); i++) {
    var col = (i < ds_list_size(global.output_colors)) ? global.output_colors[| i] : global.basic_text_color;
    draw_set_color(col);
    draw_text(16, y1, global.output_lines[| i]);
    y1 += font_height;
}

// === INPUT LINE OR PAUSE === //
if (global.awaiting_input) {
    draw_set_color(global.basic_text_color);
    var input_str = "";

    if (global.input_expected) {
        // We're in INPUT mode
        input_str = "? " + global.interpreter_input;
    } else {
        // We're in PAUSE mode
        input_str = global.interpreter_input;

        var curr_color = draw_get_color();
        var txt = "PAUSED...";
        var xx = room_width div 2;
        var yy = room_height div 2;

        draw_set_color(c_black);
        draw_text(xx - 1, yy - 1, txt);
        draw_text(xx + 1, yy - 1, txt);
        draw_text(xx - 1, yy + 1, txt);
        draw_text(xx + 1, yy + 1, txt);

        draw_set_color(c_yellow);
        draw_text(xx, yy, txt);

        draw_set_color(curr_color);
    }

    if (current_time mod 1000 < 500) input_str += "|";
    draw_text(16, y1, input_str);
    y1 += font_height;
}

// === END MESSAGE === //
if (global.program_has_ended) {
    draw_set_color(c_lime);
    draw_text(16, y1 + 16, "Program has ended - ESC or ENTER to return");
}

function basic_cmd_while(arg) {
    var condition = string_upper(arg);
    show_debug_message("WHILE: Raw condition string: '" + condition + "'");

    var value = basic_evaluate_condition(condition);

    show_debug_message("WHILE: Evaluated result of '" + condition + "' → " + string(value));

    if (!value) {
        show_debug_message("WHILE: Condition is FALSE — skipping ahead to matching WEND");
        var _depth = 1;

        for (var i = line_index + 1; i < ds_list_size(global.line_list); i++) {
            var _ln = ds_list_find_value(global.line_list, i);
            var code = ds_map_find_value(global.program_map, _ln);
            var cmd = string_upper(string_trim(string_copy(code, 1, string_pos(" ", code + " ") - 1)));

            show_debug_message("WHILE: Inspecting line " + string(_ln) + " → Command: " + cmd);

            if (cmd == "WHILE") _depth++;
            if (cmd == "WEND") _depth--;

            if (_depth == 0) {
                show_debug_message("WHILE: Found matching WEND at line index " + string(i) + ", line " + string(_ln));
                global.interpreter_next_line = i;
                return;
            }
        }

        show_debug_message("?WHILE ERROR: No matching WEND found — control flow may break");
    } else {
        show_debug_message("WHILE: Condition is TRUE — evaluating stack push logic");

        // Ensure stack exists
        if (!ds_exists(global.while_stack, ds_type_stack)) {
            global.while_stack = ds_stack_create();
            show_debug_message("WHILE: Created new while_stack");
        }

        // Only push if not already at top
        if (ds_stack_empty(global.while_stack) || ds_stack_top(global.while_stack) != line_index) {
            ds_stack_push(global.while_stack, line_index);
            show_debug_message("WHILE: Pushed line_index " + string(line_index) + " onto while_stack");
        } else {
            show_debug_message("WHILE: Stack already contains this line_index at top — skipping push");
        }

        // Ensure interpreter continues to next line
        global.interpreter_next_line = -1;
    }
}

function basic_cmd_clschar(arg) {
    show_debug_message("=== CLSCHAR DEBUG START ===");
    show_debug_message("Raw arg: '" + string(arg) + "'");
    
    var args = string_split(arg, ",");
    show_debug_message("Split args count: " + string(array_length(args)));
    for (var i = 0; i < array_length(args); i++) {
        show_debug_message("Arg[" + string(i) + "]: '" + string(args[i]) + "'");
    }

    var char_index = 0;
    var fg_color = c_white;
    var bg_color = c_black;

    if (array_length(args) >= 1) {
        char_index = real(string_trim(args[0]));
        show_debug_message("Parsed char_index: " + string(char_index));
    }

    if (array_length(args) >= 2) {
        var fg_str = string_upper(string_trim(args[1]));
        show_debug_message("Looking for fg color: '" + fg_str + "'");
        if (ds_map_exists(global.colors, fg_str)) {
            fg_color = global.colors[? fg_str];
            show_debug_message("Found fg color: " + string(fg_color));
        } else {
            show_debug_message("FG COLOR NOT FOUND!");
        }
    }

    if (array_length(args) >= 3) {
        var bg_str = string_upper(string_trim(args[2]));
        show_debug_message("Looking for bg color: '" + bg_str + "'");
        if (ds_map_exists(global.colors, bg_str)) {
            bg_color = global.colors[? bg_str];
            show_debug_message("Found bg color: " + string(bg_color));
        } else {
            show_debug_message("BG COLOR NOT FOUND!");
        }
    }

    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        show_debug_message("❌ CLSCHAR: No obj_mode1_grid found!");
    } else {
        show_debug_message("✅ CLSCHAR: Found grid obj - calling fill...");
        show_debug_message("Calling fill with: char=" + string(char_index) + ", fg=" + string(fg_color) + ", bg=" + string(bg_color));
        grid_obj.mode1_grid_fill(char_index, fg_color, bg_color);
    }
    show_debug_message("=== CLSCHAR DEBUG END ===");
}
/// @function basic_array_set(name, idx, value)
/// @description Sets a value in a 1D array stored in global.basic_arrays (0-based indexing, auto-grows)
/// @param name  The name of the array (string)
/// @param idx   The index to set (0-based)
/// @param value The value to set
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_set(_name, _idx, _val) {
    var nm = string_upper(string_trim(_name));
    show_debug_message("ARRAY_SET: Setting " + nm + "[" + string(_idx) + "] = " + string(_val));

    // Ensure the map entry exists and is a ds_list
    if (!ds_map_exists(global.basic_arrays, nm)) {
        show_debug_message("ARRAY_SET: Creating new ds_list for " + nm);
        global.basic_arrays[? nm] = ds_list_create();
    }

    var lst = global.basic_arrays[? nm];
    if (!ds_exists(lst, ds_type_list)) {
        show_debug_message("ARRAY_SET: Replacing non-list backing store for " + nm);
        lst = ds_list_create();
        global.basic_arrays[? nm] = lst;
    }

    // Normalize index
    var idx = floor(real(_idx)); // integer index (use floor to avoid +1 surprises near boundaries)

    // OPTIONAL: hard-stop on negative indexes (comment this out if you prefer silent ignore)
    if (idx < 0) {
        show_debug_message("ARRAY_SET ERROR: Negative index " + string(idx) + " for array " + nm);
        return;
    }

    // Grow to fit (fills with 0)
    while (ds_list_size(lst) <= idx) {
        ds_list_add(lst, 0);
        // OPTIONAL: verbose growth log (disable if noisy)
        // show_debug_message("ARRAY_SET: Growing " + nm + " to size " + string(ds_list_size(lst)));
    }

    // Assign
    ds_list_replace(lst, idx, _val);
    // OPTIONAL: confirmation log (disable if noisy)
    // show_debug_message("ARRAY_SET: Set " + nm + "[" + string(idx) + "] = " + string(_val));
}

/// @description ob_mode1_grid Draw Event
//draw_sprite(spr_charactersheet,10,10,10);
var cols = 40;
var rows = 25;
var tile_w = 32;
var tile_h = 32;
var max_chars = sprite_get_number(spr_charactersheet);

if (global.grid_refresh_needed) {
    global.grid_refresh_needed = false;
    
    for (var row = 0; row < 25; row++) {
        for (var col = 0; col < 40; col++) {
            var i = col + row * 40;
            if (i < array_length(grid)) {
                grid[i].char = global.grid_refresh_char;
            }
        }
    }
}



for (var _y = 0; _y < rows; _y++) {
    for (var _x = 0; _x < cols; _x++) {
        var i = _x + _y * cols;
        if (i < array_length(grid)) {
            var tile = grid[i];
            
            // Draw background
            draw_set_color(tile.bg);
            draw_rectangle(_x * tile_w, _y * tile_h, (_x + 1) * tile_w, (_y + 1) * tile_h, false);
            
            // Draw foreground (sprite tint)
            draw_set_color(tile.fg);
            
            // ADD THESE LINES TO FORCE PROPER BLENDING:
            gpu_set_blendmode(bm_normal);
            draw_set_alpha(1.0);
            
            var subimg = clamp(tile.char, 0, max_chars - 1);
            
            // Draw character sprite
            draw_sprite_ext(global.active_font_sprite, subimg, _x * tile_w, _y * tile_h, 1, 1, 0, tile.fg, 1.0);
	//if (drewfont  < 5000) {show_debug_message(global.active_font_sprite);drewfont++;}
		//enable the following to debug
		//draw_text(_x * tile_w, _y * tile_h + tile_h - 12, string(tile.char));

		}
    }
}

// Reset draw state after the loop
draw_set_color(c_white);
gpu_set_blendmode(bm_normal);

//draw_text(10, 24, "Font: " + global.active_font_name);

function basic_cmd_wend() {
    show_debug_message("WEND: Entering handler...");

    if (!ds_exists(global.while_stack, ds_type_stack)) {
        show_debug_message("WEND: ERROR — while_stack does not exist");
        basic_show_message("WEND without matching WHILE");
        return;
    }

    if (ds_stack_empty(global.while_stack)) {
        show_debug_message("WEND: ERROR — while_stack is empty");
        basic_show_message("WEND without matching WHILE");
        return;
    }

    var while_line_index = ds_stack_top(global.while_stack); // Peek, do not pop yet
    show_debug_message("WEND: Top of while_stack is line index: " + string(while_line_index));

    var while_line_number = ds_list_find_value(global.line_list, while_line_index);
    var while_code = ds_map_find_value(global.program_map, while_line_number);
    show_debug_message("WEND: WHILE line " + string(while_line_number) + " code: '" + while_code + "'");

    var condition_str = string_trim(string_delete(while_code, 1, string_pos(" ", while_code)));
    show_debug_message("WEND: Extracted condition for re-evaluation: '" + condition_str + "'");

    var condition_value = basic_evaluate_condition(string_upper(condition_str));
    show_debug_message("WEND: Re-evaluated condition result: " + string(condition_value));

    if (condition_value) {
        show_debug_message("WEND: Condition is TRUE — setting line_index = " + string(while_line_index - 1));
        line_index = while_line_index - 1; // So next Step brings us back to WHILE
    } else {
        show_debug_message("WEND: Condition is FALSE — popping WHILE from stack");
        ds_stack_pop(global.while_stack);
    }
}

/// @script basic_cmd_gosub
/// @description Handle GOSUB line-number jumps, stripping inline comments
function basic_cmd_gosub(arg) {
    // 1) Strip off anything after a ':' (inline comment or extra code)
    var raw = string_trim(arg);
    var colonPos = string_pos(":", raw);
    if (colonPos > 0) {
        raw = string_trim(string_copy(raw, 1, colonPos - 1));
        show_debug_message("GOSUB: Stripped argument to '" + raw + "'");
    }

    // 2) Parse the target line number
    var target = real(raw);
    show_debug_message("GOSUB: Target line requested: " + string(target));

    // 3) Push return point (the *next* line index) onto the gosub stack
    var return_index = line_index + 1;
    ds_stack_push(global.gosub_stack, return_index);
    show_debug_message("GOSUB: Pushed return index: " + string(return_index));

    // 4) Find the target in the sorted line_list
    global.interpreter_next_line = -1;
    var listSize = ds_list_size(global.line_list);
    for (var i = 0; i < listSize; i++) {
        if (ds_list_find_value(global.line_list, i) == target) {
            global.interpreter_next_line = i;
            show_debug_message("GOSUB: Found target line at index " + string(i));
            break;
        }
    }

    // 5) Error if not found
    if (global.interpreter_next_line == -1) {
        show_debug_message("GOSUB: ERROR — Target line " + string(target) + " not found");
        basic_show_error_message("GOSUB target line not found: " + string(target));
        global.interpreter_running = false;
    }
}

function basic_system_message(_msg, _color) {
    show_debug_message("=== basic_system_message START ===");
    show_debug_message("Incoming message: " + string(_msg));
    show_debug_message("Incoming color arg: " + string(_color));

    // Do NOT create here — run_program owns creation.
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        show_debug_message("basic_system_message: output buffers not initialized; SKIPPING write.");
        show_debug_message("=== basic_system_message END (skipped) ===");
        return;
    }

    var wrap_width = 40; // keep in sync with PRINT path
    var col = is_undefined(_color) ? global.current_draw_color : _color;
    show_debug_message("Using color: " + string(col));

    var text = string(_msg);
    show_debug_message("Wrapping text: " + text);

    while (string_length(text) > wrap_width) {
        var chunk = string_copy(text, 1, wrap_width);
        show_debug_message("Adding wrapped chunk: '" + chunk + "'");
        ds_list_add(global.output_lines, chunk);
        ds_list_add(global.output_colors, col);
        text = string_delete(text, 1, wrap_width);
    }

    show_debug_message("Adding final remainder: '" + text + "'");
    ds_list_add(global.output_lines, text);
    ds_list_add(global.output_colors, col);

    show_debug_message("=== basic_system_message END ===");
}

function basic_wrap_and_commit(_text, _color) {
    show_debug_message("=== basic_wrap_and_commit START ===");
    show_debug_message("Incoming text: " + string(_text));
    show_debug_message("Incoming color: " + string(_color));

    // Do NOT create here — avoid nuking prior output!
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        show_debug_message("basic_wrap_and_commit: output buffers not initialized; SKIPPING write.");
        show_debug_message("=== basic_wrap_and_commit END (skipped) ===");
        return;
    }

    var wrap_width = 40;
    var remaining = string(_text);
    show_debug_message("Initial remaining text: " + remaining);

    while (string_length(remaining) > wrap_width) {
        var line = string_copy(remaining, 1, wrap_width);
        show_debug_message("Adding wrapped line: '" + line + "'");
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, _color);
        remaining = string_copy(remaining, wrap_width + 1, string_length(remaining) - wrap_width);
        show_debug_message("Remaining after wrap: '" + remaining + "'");
    }

    show_debug_message("Adding final line: '" + remaining + "'");
    ds_list_add(global.output_lines, remaining);
    ds_list_add(global.output_colors, _color);

    show_debug_message("=== basic_wrap_and_commit END ===");
}

function tokenize_expression(expr) {
    var tokens = [];
    var i = 1;
    while (i <= string_length(expr)) {
        var ch = string_char_at(expr, i);

        if (ch == " " || ch == "\t") {
            i++;
            continue;
        }

        if (ch == "+" || ch == "-" || ch == "*" || ch == "/" || ch == "^" || ch == "(" || ch == ")") {
            array_push(tokens, ch);
            i++;
        }
        else if (ord(ch) >= 48 && ord(ch) <= 57) {
            var num = "";
            while (i <= string_length(expr) && (ord(string_char_at(expr, i)) >= 48 && ord(string_char_at(expr, i)) <= 57)) {
                num += string_char_at(expr, i);
                i++;
            }
            array_push(tokens, num);
        }
        else if (is_letter(ch)) {
            var ident = "";
            while (i <= string_length(expr) && (is_letter_or_digit(string_char_at(expr, i)))) {
                ident += string_char_at(expr, i);
                i++;
            }
            if (string_char_at(expr, i) == "(") {
                array_push(tokens, ident); // Function name
            } else {
                array_push(tokens, ident); // Variable
            }
        }
        else if (ch == ",") {
            array_push(tokens, ",");
            i++;
        }
        else {
            show_debug_message("Unknown character in expression: " + ch);
            i++;
        }
    }

    return tokens;
}


function editor_handle_paste_command() {
    var raw_clip = clipboard_get_text();
    if (string_length(raw_clip) <= 0) {
        show_message("Clipboard is empty.");
        return;
    }

    var lines = string_split(raw_clip, "\n");

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);

        if (string_length(line) == 0) continue;

        // Expect format: line_number followed by space and code
        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var line_num_str = string_copy(line, 1, space_pos - 1);
            var code_str = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            // ✅ Only proceed if line_num_str is a valid number
            if (string_digits(line_num_str) == line_num_str) {
                var line_num = real(line_num_str);

                if (line_num > 0 && string_length(code_str) > 0) {
                    ds_map_replace(global.program_lines, line_num, code_str);

                    if (!ds_list_find_index(global.line_numbers, line_num)) {
                        ds_list_add(global.line_numbers, line_num);
                        ds_list_sort(global.line_numbers, true);
                    }
                }
            }
        }
    }

    basic_show_message("Program pasted successfully.");
}

function save_undo_state() {
    // Placeholder for undo system
    // Eventually, you could push a copy of global.program_lines to a stack
	/// TODO: Implement undo functionality for BASIC editor
/// --------------------------------------------------
/// This function should snapshot the current program state so it can be restored later via an "UNDO" command.
/// A stack-based approach is recommended, where each saved state is pushed onto a list (e.g., global.undo_stack).
///
/// Suggested structure per snapshot:
/// - A ds_map with keys like "global.program_lines", "global.line_numbers", and optionally "cursor_pos"
/// - Each key maps to a *copy* (not a reference) of the original ds_map or ds_list
///
/// Pseudocode for future implementation:
/// ```gml
/// var snapshot = ds_map_create();
/// ds_map_add_list(snapshot, "global.line_numbers", ds_list_copy(global.line_numbers));
/// ds_map_add_map(snapshot, "global.program_lines", ds_map_copy(global.program_lines));
/// ds_stack_push(global.undo_stack, snapshot);
/// ```
///
/// Don't forget to:
/// - Create `global.undo_stack` once during initialization (e.g., in obj_globals)
/// - Clean up with `ds_map_destroy()` and `ds_list_destroy()` when popping or discarding states
///
/// For now, this is a placeholder to suppress runtime errors.

}

/// @desc Saves the current program to a .bas file
/// @param filename The filename to save as (without extension)
function save_program_as(filename) {
    // Trim spaces
    filename = string_trim(filename);

    // Remove surrounding quotes if present
    if (string_length(filename) >= 2) {
        var first = string_char_at(filename, 1);
        var last  = string_char_at(filename, string_length(filename));
        if ((first == "\"" || first == "'") && first == last) {
            filename = string_copy(filename, 2, string_length(filename) - 2);
        }
    }

    var file_path = working_directory + filename + ".bas";
    var file = file_text_open_write(file_path);
    if (file == -1) {
        show_error_message("COULD NOT OPEN FILE: " + filename);
        return;
    }

    var count = ds_list_size(global.line_numbers);
    for (var i = 0; i < count; i++) {
        var line_num = ds_list_find_value(global.line_numbers, i);
        var code     = ds_map_find_value(global.program_lines, line_num);
        file_text_write_string(file, string(line_num) + " " + code);
        file_text_writeln(file);
    }

    file_text_close(file);
    current_filename = filename;
    basic_show_message("SAVED: " + filename + " (working_directory)");
}

// @description obj_mode1_grid Create Event
//Create 40x25 grid for 32x32 character tiles
grid_cols = 40;
grid_rows = 25;
tile_width = 32;
tile_height = 32;

grid = array_create(grid_cols * grid_rows);

// Each grid cell will be a struct:
function make_tile_struct(char = 32, fg = c_white, bg = c_black) {
    return { char: char, fg: fg, bg: bg };
}

// Initialize all tiles
for (var i = 0; i < array_length(grid); i++) {
    grid[i] = make_tile_struct();
}

self.mode1_grid_fill = function(char, fg, bg) {
    show_debug_message(">> GRID FILL START: char=" + string(char) + ", fg=" + string(fg) + ", bg=" + string(bg));
    show_debug_message(">> Grid array length: " + string(array_length(grid)));
    
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char;
        grid[i].fg = fg;
        grid[i].bg = bg;
    }
    
    // Check first few tiles to verify they were set
    for (var i = 0; i < 3; i++) {
        show_debug_message(">> Tile[" + string(i) + "]: char=" + string(grid[i].char) + ", fg=" + string(grid[i].fg) + ", bg=" + string(grid[i].bg));
    }
    show_debug_message(">> GRID FILL END");
}

drewfont = 0;//temp var


function basic_cmd_printat(arg) {
    // arg: x,y,"string",fgcolor,bgcolor
    var args = basic_parse_csv_args(arg);
    if (array_length(args) < 3) {
        show_debug_message("PRINTAT ERROR: Not enough arguments.");
        return;
    }

    var _x = basic_evaluate_expression_v2(args[0]);
    var _y = basic_evaluate_expression_v2(args[1]);
    var str = string(args[2]); // keep quotes if present
    var fg = (array_length(args) > 3) ? basic_parse_color(args[3]) : c_white;
    var bg = (array_length(args) > 4) ? basic_parse_color(args[4]) : c_black;

    // Remove quotes from string if present
    if (string_length(str) >= 2 && string_char_at(str, 1) == "\"" && string_char_at(str, string_length(str)) == "\"") {
        str = string_copy(str, 2, string_length(str) - 2);
    }

    for (var i = 0; i < string_length(str); i++) {
        var ch = ord(string_char_at(str, i + 1));
        mode1_grid_set(_x + i, _y, ch, fg, bg);
    }

    show_debug_message("PRINTAT → (" + string(_x) + "," + string(_y) + ") = '" + str + "'");
}

/// @script basic_cmd_else
/// @description Handle ELSE in a structured IF…ELSEIF…ELSE…ENDIF
function basic_cmd_else() {
    show_debug_message("ELSE START");
    // ← GUARD: must have an open IF
    if (ds_stack_empty(global.if_stack)) {
        show_debug_message("?ELSE ERROR: ELSE without matching IF");
        return;
    }
	
    var frame = ds_stack_top(global.if_stack);
    var taken = frame[? "takenBranch"];

    var current_index = global.interpreter_current_line_index;
    var endifIx = frame[? "endifIndex"];

    if (taken) {
        // Already ran IF or an ELSEIF → skip entire ELSE-block
        global.interpreter_next_line = endifIx;
        show_debug_message("ELSE skipping to ENDIF at index " + string(endifIx));
    } else {
        // No branch yet taken → run ELSE body
        ds_map_replace(frame, "takenBranch", true);
        global.interpreter_next_line = current_index + 1;
        show_debug_message("ELSE entering branch at index " + string(global.interpreter_next_line));
    }
}

/// @function basic_cmd_goto(arg)
/// @description Sets the program counter to a new line number if it exists.
function basic_cmd_goto(arg) {
    show_debug_message("GOTO START — Raw arg: '" + arg + "'");

    var trimmed_arg = string_trim(arg);
    var target_line = real(trimmed_arg);

    show_debug_message("GOTO: Parsed target line number: " + string(target_line));

    // Find the index in your line_list
    var index = -1;
	for (var i = 0; i < ds_list_size(global.line_list); i++) {
	    if (real(ds_list_find_value(global.line_list, i)) == target_line) {
	        index = i;
	        break;
	    }
	}

	
    if (index >= 0) {
        global.interpreter_next_line = index;
        show_debug_message("GOTO SUCCESS → Jumping to line " + string(target_line) + " (list index " + string(index) + ")");
    } else {
        show_debug_message("?GOTO ERROR: Line number " + string(target_line) + " not found in global.line_list");
    }
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function set_color_scheme(scheme) {
    scheme = string_upper(scheme);
    switch (scheme) {
        case "GREEN":
            keyword_color = c_lime;
            text_color = c_green;
            number_color = c_yellow;
            break;
        case "BLUE":
            keyword_color = c_cyan;
            text_color = c_blue;
            number_color = c_white;
            break;
        case "AMBER":
            keyword_color = c_orange;
            text_color = c_yellow;
            number_color = c_white;
            break;
        default:
            show_error_message("UNKNOWN COLOR SCHEME");
            return;
    }
    basic_show_message("COLOR SCHEME: " + scheme);
    update_display();
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function process_input_line(input_text) {
    // Trim whitespace
    input_text = string_trim(input_text);
    
    if (input_text == "") return;
    
    // Check if line starts with a number
    var first_space = string_pos(" ", input_text);
    var potential_line_num = "";
    
    if (first_space > 0) {
        potential_line_num = string_copy(input_text, 1, first_space - 1);
    } else {
        potential_line_num = input_text;
    }
    
    // Check if it's a valid line number
    if (is_line_number(potential_line_num)) {
        handle_program_line(input_text);
    } else {
        handle_command(input_text);
    }
 }
function mode1_grid_set(col, row, char_index, fg, bg) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        show_debug_message("mode1_grid_set: No grid object found.");
        return;
    }

    var cols = 40;
    var rows = 25;

    if (col >= 0 && col < cols && row >= 0 && row < rows) {
        var index = col + row * cols;
        grid_obj.grid[index].char = char_index;
        grid_obj.grid[index].fg = fg;
        grid_obj.grid[index].bg = bg;
        show_debug_message("mode1_grid_set: Set (" + string(col) + "," + string(row) + ") = " + string(char_index));
    } else {
        show_debug_message("mode1_grid_set: Coordinates out of bounds (" + string(col) + "," + string(row) + ")");
    }
}

function basic_parse_csv_args(str) {
    var args = [];
    var current = "";
    var in_quotes = false;
    var i = 1;
    var len = string_length(str);

    while (i <= len) {
        var c = string_char_at(str, i);

        if (c == "\"") {
            in_quotes = !in_quotes;
            current += c; // Preserve quote so later commands can detect strings
        }
        else if (c == "," && !in_quotes) {
            array_push(args, string_trim(current));
            current = "";
        }
        else {
            current += c;
        }

        i += 1;
    }

    if (string_length(current) > 0) {
        array_push(args, string_trim(current));
    }

    return args;
}

// SCRIPT: basic_stop_execution
function basic_stop_execution() {
    show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    show_debug_message("BASIC_STOP_EXECUTION CALLED!");
    show_debug_message("Call Stack:");
    show_debug_message(debug_get_callstack()); // THIS IS THE KEY!
    show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

    global.interpreter_running = false;
    global.awaiting_input = false;
    global.program_has_ended = true;

    // Clear input buffer if input was pending
    if (global.input_buffer != undefined && ds_list_exists(global.input_buffer, ds_type_list)) {
        ds_list_clear(global.input_buffer);
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function list_program() {
    display_start_line = 0;
    update_display();
 }
 function list_program_range(range) {
    // Parse range like "10-50" or single number "10"
    var dash_pos = string_pos("-", range);
    if (dash_pos > 0) {
        var start_line = real(string_copy(range, 1, dash_pos - 1));
        var end_line = real(string_copy(range, dash_pos + 1, string_length(range)));
        list_between_lines(start_line, end_line);
    } else {
        var single_line = real(range);
        list_single_line(single_line);
    }
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function navigate_history_up() {
	
	if (global.justreturned == 1) return; // 🛑 Block history on return
	
    if (ds_list_size(global.input_history) > 0) {
        if (global.history_index == -1) {
            global.history_index = ds_list_size(global.input_history) - 1;
        } else {
            global.history_index = max(0, global.history_index - 1);
        }
        current_input = ds_list_find_value(global.input_history, global.history_index);
        cursor_pos = string_length(current_input);
    }
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function navigate_history_down() {
	 if (global.justreturned == 1) return; // 🛑 Block history on return
	 
    if (global.history_index != -1) {
        global.history_index++;
        if (global.history_index >= ds_list_size(global.input_history)) {
            global.history_index = -1;
            current_input = "";
        } else {
            current_input = ds_list_find_value(global.input_history, global.history_index);
        }
        cursor_pos = string_length(current_input);
    }
 }
function is_function(t) {
    var fn = string_upper(string_trim(t));
    return  fn == "RND"    // your original BASIC call
         || fn == "RND1"   // internal 1-arg postfix token
         || fn == "RND2"   // internal 2-arg postfix token
         || fn == "STR$"
         || fn == "CHR$"
         || fn == "LEFT$"
         || fn == "RIGHT$"
         || fn == "MID$"
         || fn == "ABS"
         || fn == "INT"
         || fn == "EXP"
         || fn == "LOG"
         || fn == "LOG10"
         || fn == "SGN"
         || fn == "SIN"
         || fn == "COS"
         || fn == "TAN"
         || fn == "REPEAT$";
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function insert_line_number_ordered(new_line_num) {
    var size = ds_list_size(global.line_numbers);
    var inserted = false;
    
    for (var i = 0; i < size; i++) {
        if (ds_list_find_value(global.line_numbers, i) > new_line_num) {
            ds_list_insert(global.line_numbers, i, new_line_num);
            inserted = true;
            break;
      }
    }
    
    if (!inserted) {
        ds_list_add(global.line_numbers, new_line_num);
    }
 }
/// Remove single quote comments, unless inside double quotes
function strip_basic_remark(arg) {
    var len = string_length(arg);
    var inside_string = false;

    for (var i = 1; i <= len; i++) {
        var c = string_char_at(arg, i);

        if (c == "\"") {
            inside_string = !inside_string;
        }
        else if (c == "'" && !inside_string) {
            // Found unquoted remark start – strip everything after
            return string_trim(string_copy(arg, 1, i - 1));
        }
    }

    // No unquoted remark found – return original
    return arg;
}

function list_saved_programs() {
    if (!variable_instance_exists(obj_editor, "dir_listing")) return;

    obj_editor.dir_listing = [];
    var fname = file_find_first(working_directory + "*.bas", 0); // 0 = file
    while (fname != "") {
        array_push(obj_editor.dir_listing, fname);
        fname = file_find_next();
    }
    file_find_close();

    obj_editor.showing_dir_overlay = true;

    if (array_length(obj_editor.dir_listing) == 0) {
        array_push(obj_editor.dir_listing, "No .bas files found.");
    }
}

function basic_cmd_return() {
    if (ds_stack_empty(global.gosub_stack)) {
        show_debug_message("RETURN: ERROR — gosub_stack is empty");
        basic_show_error_message("RETURN called with empty stack.");
        global.interpreter_running = false;
        return;
    }

    var return_index = ds_stack_pop(global.gosub_stack);
    global.interpreter_next_line = return_index;
    show_debug_message("RETURN: Popped return index from gosub_stack: " + string(return_index));
}

/// @function interpreter_cmd_print(argument)
/// @description Handles the BASIC PRINT command.
/// @param arg - The string argument from the BASIC code

function interpreter_cmd_print(arg) {
    // Remove surrounding double quotes if present
    if (string_length(arg) >= 2 &&
        string_char_at(arg, 1) == "\"" &&
        string_char_at(arg, string_length(arg)) == "\"") {
        arg = string_copy(arg, 2, string_length(arg) - 2);
    }

    ds_list_add(output_lines, arg);
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function add_or_update_program_line(line_num, code) {
    ds_map_set(global.program_lines, line_num, code);
    
    // Update ordered line numbers list
    var pos = ds_list_find_index(global.line_numbers, line_num);
    if (pos == -1) {
        // Insert in correct order
        insert_line_number_ordered(line_num);
    }
 }
/// @function is_function_token(token)
/// @description Checks if a given token is a recognized BASIC function.
/// @param {string} token The token to check.
/// @returns {boolean} True if it's a function, false otherwise.
function is_function_token(token) {
    var upper_token = string_upper(token);
    // Add more functions here as you implement them in evaluate_postfix
    return upper_token == "RND" || upper_token == "ABS";
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function delete_program_line(line_num) {
    ds_map_delete(global.program_lines, line_num);
    var pos = ds_list_find_index(global.line_numbers, line_num);
    if (pos != -1) {
        ds_list_delete(global.line_numbers, pos);
    }
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function toggle_syntax_highlighting() {
    syntax_highlighting = !syntax_highlighting;
    basic_show_message("SYNTAX HIGHLIGHTING: " + (syntax_highlighting ? "ON" : "OFF"));
    update_display();
 }

function dbg(cat, msg) {
    // Off fast-path
    if ((global.debug_mask & cat) == 0) return;

    // Per-frame quota (avoid tanking fps)
    if (global.dbg_frame_count >= global.dbg_frame_quota) {
        global.dbg_dropped_count++;
        return;
    }
    global.dbg_frame_count++;
    show_debug_message(msg);
}


/// @param char_index
/// @param fg_color
/// @param bg_color
function mode1_grid_fill(char_index, fg_color, bg_color) {
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char_index;
        grid[i].fg = fg_color;
        grid[i].bg = bg_color;
    }
}

function basic_cmd_end() {
    show_debug_message("END: Program termination requested");
    global.program_has_ended = true;
    global.interpreter_running = false;
	 global.current_mode = 0;
    show_debug_message("END: interpreter_running set to false");
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_valid_line_number(line_num) {
    return (line_num >= 1 && line_num <= global.config[? "max_line_number"]);
 }

function is_operator(op) {
    return (op == "+" || op == "-" || op == "*" || op == "/" || op == "^" || 
            op == "%" || string_upper(op) == "MOD" ||
        op == "=" || op == "<>" || op == "<" || op == ">" || op == "<=" || op == ">=");
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_current_colors() {
    basic_show_message("CURRENT SCHEME - USE: COLOR GREEN/BLUE/AMBER");
 }
function is_quoted_string(str) {
    return (string_length(str) >= 2 &&
            string_char_at(str, 1) == "\"" &&
            string_char_at(str, string_length(str)) == "\"");
}

// Call this to display a message for roughly 2 seconds (120 frames at 60 fps).
function basic_show_message(msg) {
    message_text  = msg;
    global.message_timer = 120;
}
// obj_globals Step Event
if (room == rm_editor) {
    if (!instance_exists(obj_editor)) {
        instance_create_layer(0, 0, "Instances", obj_editor);
    }
}


// Optional helper for errors: prefix message with a "?" as classic BASIC did.
function basic_show_error_message(err) {
    basic_show_message("?" + err);
}



function is_letter(ch) {
    var o = ord(string_upper(ch));
    return (o >= 65 && o <= 90);
}



function is_letter_or_digit(ch) {
    return is_letter(ch) || (ord(ch) >= 48 && ord(ch) <= 57);
}
function is_right_associative(op) {
    return (op == "^");
}

