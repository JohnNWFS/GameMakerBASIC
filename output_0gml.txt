/// help_build_program() - CORRECTED VERSION
function help_build_program() {
    // clear current program and line numbers
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // Work out how many topics we're going to list
    var topic_count = ds_list_size(global.help_topics);

    // Seed the runtime variable store
    if (!is_undefined(global.basic_variables)) {
        global.basic_variables[? "TOPIC_COUNT"] = topic_count;
    }

    var add = function(n, s) {
        ds_map_add(global.program_lines, n, s);
        ds_list_add(global.line_numbers, n);
    };

    // ==== BASIC "HELP BROWSER" PROGRAM ====
add(10,"REM NW-BASIC HELP SYSTEM - Clean Version (ASCII-safe)");
add(15,"HDR$ = \"\"             : REM avoid undefined var on first header call");
add(20,"CLS: COLOR YELLOW: HDR$=\"NW-BASIC HELP\": GOSUB 7000");
add(30,"PRINT \"Select a topic by number. 0 returns to editor.\"");
add(35,"REM -- Arrays must exist BEFORE we READ into them");
add(36,"DIM TOPIC$(32), TOPIC_START(32), TOPIC_LEN(32)");
add(37,"DIM SUB$(128), SUBTOPIC_OF(128), SUB_START(128), SUB_LEN(128)");
add(38,"DIM IDX(32)");
add(40,"GOSUB 9500   : REM Load data");
add(50,"REM --- MAIN MENU LOOP ---");
add(60,"CLS: HDR$=\"TOPICS - Select a topic (0=Exit)\": GOSUB 7000");
add(65,"PRINT");
add(70,"FOR I=1 TO TOPIC_COUNT: PRINT I; \") \"; TOPIC$(I): NEXT");
add(80,"PRINT");
add(90,"INPUT \"Topic (0=Exit): \", T");
add(100,"IF T=0 THEN END");
add(110,"IF T<1 OR T>TOPIC_COUNT THEN PRINT \"Invalid.\": GOTO 80");
add(120,"REM --- SUBTOPIC MENU LOOP ---");
add(130,"CLS: HDR$=\"TOPIC: \" + TOPIC$(T) + \"  (0=Back)\": GOSUB 7000");
add(140,"C=0");
add(150,"FOR I=1 TO SUB_COUNT");
add(160,"  IF SUBTOPIC_OF(I)=T THEN C=C+1: PRINT C; \") \"; SUB$(I): IDX(C)=I");
add(170,"NEXT");
add(180,"IF C=0 THEN PRINT \"(No subtopics)\": INPUT \"[ENTER]\", X$: GOTO 50");
add(190,"PRINT");
add(200,"INPUT \"Subtopic (0=Back): \",K");
add(210,"IF K=0 THEN GOTO 50");
add(220,"IF K<1 OR K>C THEN GOTO 190");
add(230,"REM --- SHOW CONTENT ---");
add(240,"I = IDX(K): S = SUB_START(I): N = SUB_LEN(I)");
add(250,"GOSUB 8000");
add(260,"GOTO 120");
add(6999,"REM ---- helpers ----");
add(7000,"REM Print a decorated header (no LEN, no REPEAT$)");
add(7005,"D$=\"\": FOR J=1 TO 40: D$=D$ + \"-\": NEXT");
add(7010,"PRINT D$");
add(7015,"IF HDR$ <> \"\" THEN PRINT HDR$");
add(7020,"PRINT D$");
add(7030,"RETURN");
add(8000,"REM --- CONTENT DISPLAY: seek once to first page, then stream N pages ---");
add(8010,"REM We want pages S..S+N-1. Land on page S once, then read forward.");
add(8030,"RESTORE");
add(8040,"READ TC, SC, PC");
add(8050,"FOR SKT = 1 TO TC: READ TMP$, TMP1, TMP2: NEXT SKT");
add(8060,"FOR SKS = 1 TO SC: READ TMP2$, TMP3, TMP4, TMP5: NEXT SKS");
add(8080,"FOR SK = 1 TO S - 1");
add(8090,"  READ L: FOR R = 1 TO L: READ D$: NEXT R");
add(8100,"NEXT SK");
add(8120,"FOR PP = 1 TO N");
add(8130,"  CLS");
add(8140,"  PRINT \"HELP: \"; SUB$(I)");
add(8150,"  HDR$ = \"TOPIC: \" + TOPIC$( SUBTOPIC_OF(I) ) + \"  (0=Back)\": GOSUB 7000");
add(8160,"  PRINT \"Page \"; PP; \" of \"; N");
add(8170,"  PRINT");
add(8180,"  READ L");
add(8190,"  FOR R = 1 TO L");
add(8200,"    READ D$: PRINT D$");
add(8210,"  NEXT R");
add(8220,"  PRINT");
add(8230,"  INPUT \"[ENTER=Next/Back]\", X$");
add(8240,"NEXT PP");
add(8250,"RETURN");
add(9500,"REM -- Load all data --");
add(9510,"RESTORE");
add(9520,"READ TOPIC_COUNT, SUB_COUNT, PAGE_COUNT");
add(9530,"FOR I=1 TO TOPIC_COUNT: READ TOPIC$(I), TOPIC_START(I), TOPIC_LEN(I): NEXT");
add(9550,"FOR I=1 TO SUB_COUNT: READ SUB$(I), SUBTOPIC_OF(I), SUB_START(I), SUB_LEN(I): NEXT");
add(9560,"RETURN");
add(9900,"DATA 9, 27, 38");
add(9910,"REM Topic data: name, start_page, length");
add(9920,"DATA \"Program Structure\", 1, 2");
add(9921,"DATA \"Variables & Data Types\", 3, 3");
add(9922,"DATA \"Input/Output\", 6, 4");
add(9923,"DATA \"Program Control\", 10, 5");
add(9924,"DATA \"MODE / Graphics\", 15, 5");
add(9925,"DATA \"Math & Random\", 20, 4");
add(9926,"DATA \"Strings\", 24, 3");
add(9927,"DATA \"Data & Arrays\", 27, 5");
add(9928,"DATA \"Editor & Files\", 32, 7");
add(9930,"REM Subtopic data: name, parent_topic, start_page, length");
add(9931,"DATA \"Line Numbers\", 1, 1, 1");
add(9932,"DATA \"Multiple Statements\", 1, 2, 1");
add(9933,"DATA \"LET & Types\", 2, 3, 1");
add(9934,"DATA \"Arrays (DIM)\", 2, 4, 2");
add(9935,"DATA \"PRINT\", 3, 6, 2");
add(9936,"DATA \"INPUT\", 3, 8, 1");
add(9937,"DATA \"CLS/Color\", 3, 9, 1");
add(9938,"DATA \"IF / ELSE / ENDIF\", 4, 10, 2");
add(9939,"DATA \"FOR/NEXT\", 4, 12, 1");
add(9940,"DATA \"WHILE/WEND\", 4, 13, 1");
add(9941,"DATA \"GOTO/GOSUB/RETURN\", 4, 14, 1");
add(9942,"DATA \"MODE 1 & Fonts\", 5, 15, 2");
add(9943,"DATA \"PRINTAT/CHARAT\", 5, 17, 2");
add(9944,"DATA \"CLSCHAR/SCROLL\", 5, 19, 1");
add(9945,"DATA \"Math & Trig\", 6, 20, 2");
add(9946,"DATA \"RND\", 6, 22, 1");
add(9947,"DATA \"Operators\", 6, 23, 1");
add(9948,"DATA \"Substring & Len\", 7, 24, 1");
add(9949,"DATA \"CHR$/ASC\", 7, 25, 1");
add(9950,"DATA \"Concatenation\", 7, 26, 1");
add(9951,"DATA \"DATA/READ/RESTORE\", 8, 27, 2");
add(9952,"DATA \"Named Streams\", 8, 29, 1");
add(9953,"DATA \"Arrays\", 8, 30, 2");
add(9954,"DATA \"Editor Commands\", 9, 32, 3");
add(9955,"DATA \"DIR Overlay\", 9, 35, 1");
add(9956,"DATA \"SAVE/LOAD\", 9, 36, 1");
add(9957,"DATA \"Shortcuts\", 9, 37, 2");
add(10000,"REM === Page 1: Program Structure / Line Numbers ===");
add(10010,"DATA 9");
add(10011,"DATA \"PROGRAM STRUCTURE\"");
add(10012,"DATA \"What: Programs are a list of numbered lines.\"");
add(10013,"DATA \"Syntax: 10 STATEMENT  : 20 STATEMENT\"");
add(10014,"DATA \"Type: 10 PRINT \"\"Hello\"\"  : 20 END\"");
add(10015,"DATA \"Gotchas: Use gaps 10,20,30 so you can insert.\"");
add(10016,"DATA \"Gotchas: A repeated number overwrites that line.\"");
add(10017,"DATA \"See also: Multiple Statements, GOTO, GOSUB\"");
add(10018,"DATA \"SCREENEDIT or SE = full screen editor\"");
add(10019,"DATA \"Use REM or ' to start a comment to end of line\"");
add(10020,"REM === Page 2: Program Structure / Multiple Statements ===");
add(10030,"DATA 7");
add(10031,"DATA \"PROGRAM STRUCTURE\"");
add(10032,"DATA \"What: Put several statements on one line.\"");
add(10033,"DATA \"Syntax: STAT : STAT : STAT\"");
add(10034,"DATA \"Type: 10 A=1: B=2: PRINT A+B\"");
add(10035,"DATA \"Gotchas: Keep lines short for readability.\"");
add(10036,"DATA \"See also: LET & Types, IF, FOR/NEXT\"");
add(10037,"DATA \"\"");
add(10040,"REM === Page 3: Variables & Data Types / LET & Types ===");
add(10050,"DATA 9");
add(10051,"DATA \"VARIABLES & TYPES\"");
add(10052,"DATA \"What: Store numbers or text in named variables.\"");
add(10053,"DATA \"Syntax: A=5  or  LET A=5  ;  N$=\"\"Name\"\"\"");
add(10054,"DATA \"Type: A=3: B=4: PRINT A+B   :  N$=\"\"Joe\"\"\"");
add(10055,"DATA \"Type: PRINT \"\"Hello, \"\" + N$\"");
add(10056,"DATA \"Gotchas: Names ending in $ are strings only.\"");
add(10057,"DATA \"Gotchas: Others are numeric; default is 0.\"");
add(10058,"DATA \"See also: Strings, PRINT\"");
add(10059,"DATA \"\"");
add(10060,"REM === Page 4: Variables & Data Types / Arrays (DIM) p1 ===");
add(10070,"DATA 9");
add(10071,"DATA \"ARRAYS (DIM) - Part 1\"");
add(10072,"DATA \"What: Store many values under one name.\"");
add(10073,"DATA \"Syntax: DIM A(10)  ;  DIM N$(5)\"");
add(10074,"DATA \"Type: DIM A(3): A(1)=10: A(2)=20: PRINT A(1)+A(2)\"");
add(10075,"DATA \"Type: DIM N$(2): N$(1)=\"\"OK\"\": PRINT N$(1)\"");
add(10076,"DATA \"Gotchas: Indexing is 1-based in this build.\"");
add(10077,"DATA \"Gotchas: Out of range gives 0 or empty string.\"");
add(10078,"DATA \"See also: Arrays p2, Data & Arrays\"");
add(10079,"DATA \"\"");
add(10080,"REM === Page 5: Variables & Data Types / Arrays (DIM) p2 ===");
add(10090,"DATA 8");
add(10091,"DATA \"ARRAYS (DIM) - Part 2\"");
add(10092,"DATA \"What: Use expressions for the index.\"");
add(10093,"DATA \"Type: I=3: DIM A(5): A(I-1)=7: PRINT A(2)\"");
add(10094,"DATA \"Type: DIM N$(3): N$(1)=\"\"A\"\": PRINT N$(1)\"");
add(10095,"DATA \"Gotchas: Arrays and scalars are distinct names.\"");
add(10096,"DATA \"Gotchas: Re-DIM by defining before use.\"");
add(10097,"DATA \"See also: Substring & LEN, Data & Arrays\"");
add(10098,"DATA \"\"");
add(10100,"REM === Page 6: Input/Output / PRINT p1 ===");
add(10110,"DATA 9");
add(10111,"DATA \"PRINT - Part 1\"");
add(10112,"DATA \"What: Show text or values on the screen.\"");
add(10113,"DATA \"Syntax: PRINT expr   ;   PRINT A;B   ;   PRINT A,B\"");
add(10114,"DATA \"Type: PRINT \"\"Hello\"\"   :   PRINT 1,2,3\"");
add(10115,"DATA \"Type: A=3: B=4: PRINT \"\"Sum=\"\";A+B\"");
add(10116,"DATA \"Output: 1       2       3\"");
add(10117,"DATA \"Gotchas: A trailing ; keeps the cursor on the line.\"");
add(10118,"DATA \"See also: PRINT p2, INPUT\"");
add(10119,"DATA \"\"");
add(10120,"REM === Page 7: Input/Output / PRINT p2 ===");
add(10130,"DATA 8");
add(10131,"DATA \"PRINT - Part 2\"");
add(10132,"DATA \"What: Format with strings for labels.\"");
add(10133,"DATA \"Type: PRINT \"\"A=\"\"+STR$(5)\"");
add(10134,"DATA \"Type: PRINT \"\"First\"\";: PRINT \"\" line\"\"\"");
add(10135,"DATA \"Gotchas: , uses tab columns; ; no spacing.\"");
add(10136,"DATA \"Gotchas: Use CHR$(13)+CHR$(10) for custom breaks.\"");
add(10137,"DATA \"See also: Strings, CHR$/ASC\"");
add(10138,"DATA \"\"");
add(10140,"REM === Page 8: Input/Output / INPUT ===");
add(10150,"DATA 8");
add(10151,"DATA \"INPUT\"");
add(10152,"DATA \"What: Ask the user for a number or text.\"");
add(10153,"DATA \"Syntax: INPUT \"\"Prompt: \"\", X   or   INPUT \"\"Name: \"\", N$\"");
add(10154,"DATA \"Type: INPUT \"\"Name: \"\", N$: PRINT \"\"Hello, \"\";N$\"");
add(10155,"DATA \"INKEY$ returns one key from the queue; \"\"\"\" if none\"");
add(10156,"DATA \"Gotchas: Use $ names for text; others are numeric.\"");
add(10157,"DATA \"Gotchas: Entering nothing keeps current value.\"");
add(10158,"DATA \"See also: PRINT, IF, Shortcuts\"");
add(10160,"REM === Page 9: Input/Output / CLS & Color ===");
add(10170,"DATA 8");
add(10171,"DATA \"CLS & COLOR\"");
add(10172,"DATA \"What: Clear the screen and set text color.\"");
add(10173,"DATA \"Syntax: CLS    ;   COLOR YELLOW\"");
add(10174,"DATA \"Type: CLS: COLOR YELLOW: PRINT \"\"Ready\"\"\"");
add(10175,"DATA \"Gotchas: Use a small set of named colors.\"");
add(10176,"DATA \"Gotchas: Clear before drawing a new view.\"");
add(10177,"DATA \"See also: MODE 1, PRINTAT\"");
add(10178,"DATA \"\"");
add(10180,"REM === Page 10: Program Control / IF-ELSE-ENDIF p1 ===");
add(10190,"DATA 9");
add(10191,"DATA \"IF / ELSE / ENDIF - Part 1\"");
add(10192,"DATA \"What: Run code only when a test is true.\"");
add(10193,"DATA \"Syntax:\"");
add(10194,"DATA \"IF A>0 THEN\"");
add(10195,"DATA \"  PRINT \"\"POSITIVE\"\"\"");
add(10196,"DATA \"ELSE\"");
add(10197,"DATA \"  PRINT \"\"NON-POSITIVE\"\"\"");
add(10198,"DATA \"ENDIF\"");
add(10199,"DATA \"\"");
add(10200,"REM === Page 11: Program Control / IF-ELSE-ENDIF p2 ===");
add(10210,"DATA 7");
add(10211,"DATA \"IF / ELSE / ENDIF - Part 2\"");
add(10212,"DATA \"What: Single-line IF for short actions.\"");
add(10213,"DATA \"Type: IF A=0 THEN PRINT \"\"ZERO\"\"\"");
add(10214,"DATA \"Gotchas: Use parentheses to group tests.\"");
add(10215,"DATA \"Gotchas: Strings compare with = and <>.\"");
add(10216,"DATA \"See also: FOR/NEXT, WHILE/WEND\"");
add(10217,"DATA \"\"");
add(10220,"REM === Page 12: Program Control / FOR-NEXT ===");
add(10230,"DATA 8");
add(10231,"DATA \"FOR / NEXT\"");
add(10232,"DATA \"What: Repeat a block a set number of times.\"");
add(10233,"DATA \"Syntax: FOR I=start TO end [STEP s] ... NEXT\"");
add(10234,"DATA \"Type: FOR I=1 TO 5: PRINT I: NEXT\"");
add(10235,"DATA \"Type: FOR T=10 TO 0 STEP -2: PRINT T: NEXT\"");
add(10236,"DATA \"Gotchas: Do not change I inside the loop.\"");
add(10237,"DATA \"See also: WHILE/WEND, IF\"");
add(10238,"DATA \"\"");
add(10240,"REM === Page 13: Program Control / WHILE-WEND ===");
add(10250,"DATA 6");
add(10251,"DATA \"WHILE / WEND\"");
add(10252,"DATA \"What: Repeat while a condition is true.\"");
add(10253,"DATA \"Syntax: WHILE cond: ... : WEND\"");
add(10254,"DATA \"Type: A=3: WHILE A>0: PRINT A: A=A-1: WEND\"");
add(10255,"DATA \"Gotchas: Ensure progress to avoid an infinite loop.\"");
add(10256,"DATA \"\"");
add(10260,"REM === Page 14: Program Control / GOTO-GOSUB-RETURN ===");
add(10270,"DATA 8");
add(10271,"DATA \"GOTO / GOSUB / RETURN\"");
add(10272,"DATA \"What: Jump or call a subroutine by line number.\"");
add(10273,"DATA \"Type: 100 GOSUB 900 : PRINT \"\"Back\"\" : END\"");
add(10274,"DATA \"Type: 900 PRINT \"\"Hi\"\": RETURN\"");
add(10275,"DATA \"Gotchas: RETURN goes to the line after GOSUB.\"");
add(10276,"DATA \"Gotchas: Use small helpers; avoid deep nesting.\"");
add(10277,"DATA \"See also: Line Numbers, IF\"");
add(10278,"DATA \"\"");
add(10280,"REM === Page 15: MODE / Graphics / MODE1 & Fonts p1 ===");
add(10290,"DATA 8");
add(10291,"DATA \"MODE 1 & FONTS - Part 1\"");
add(10292,"DATA \"What: Character grid display with sprite fonts.\"");
add(10293,"DATA \"Syntax: FONT \"\"DEFAULT_16\"\"\"");
add(10294,"DATA \"Type: FONT \"\"DEFAULT_16\"\": PRINT \"\"Hello\"\"\"");
add(10295,"DATA \"Gotchas: Tile size sets columns and rows.\"");
add(10296,"DATA \"Gotchas: Keep a consistent font for readability.\"");
add(10297,"DATA \"See also: PRINTAT/CHARAT\"");
add(10298,"DATA \"\"");
add(10300,"REM === Page 16: MODE / Graphics / MODE1 & Fonts p2 ===");
add(10310,"DATA 7");
add(10311,"DATA \"MODE 1 & FONTS - Part 2\"");
add(10312,"DATA \"What: Pick a tile size for your layout.\"");
add(10313,"DATA \"Guide: 16x16 is readable; 8x8 fits more text.\"");
add(10314,"DATA \"Tip: Test on your target window size.\"");
add(10315,"DATA \"Tip: Use headers and spacing to reduce clutter.\"");
add(10316,"DATA \"See also: PRINTAT/CHARAT, CLSCHAR/SCROLL\"");
add(10317,"DATA \"\"");
add(10320,"REM === Page 17: MODE / Graphics / PRINTAT-CHARAT p1 ===");
add(10330,"DATA 8");
add(10331,"DATA \"PRINTAT / CHARAT - Part 1\"");
add(10332,"DATA \"What: Draw at a grid position.\"");
add(10333,"DATA \"Syntax: PRINTAT x,y,\"\"Text\"\"\"");
add(10334,"DATA \"Syntax: CHARAT x,y,code[,fg[,bg]]\"");
add(10335,"DATA \"Type: PRINTAT 1,1,\"\"TOP\"\"\"");
add(10336,"DATA \"Type: CHARAT 10,5,45  ' draw '-'\"");
add(10337,"DATA \"See also: MODE 1, CLSCHAR/SCROLL\"");
add(10338,"DATA \"\"");
add(10340,"REM === Page 18: MODE / Graphics / PRINTAT-CHARAT p2 ===");
add(10350,"DATA 7");
add(10351,"DATA \"PRINTAT / CHARAT - Part 2\"");
add(10352,"DATA \"Tip: To center: start=(cols-LEN)/2 (manual).\"");
add(10353,"DATA \"Tip: Redraw only the parts that change.\"");
add(10354,"DATA \"Tip: Keep a cursor state if you blink text.\"");
add(10355,"DATA \"Tip: Use constants for colors and codes.\"");
add(10356,"DATA \"See also: MODE 1, DIR Overlay\"");
add(10357,"DATA \"\"");
add(10360,"REM === Page 19: MODE / Graphics / CLSCHAR-SCROLL ===");
add(10370,"DATA 7");
add(10371,"DATA \"CLSCHAR / SCROLL\"");
add(10372,"DATA \"What: Fill the screen or move text rows.\"");
add(10373,"DATA \"Syntax: CLSCHAR code[,fg[,bg]]\"");
add(10374,"DATA \"Syntax: SCROLL dir[,rows]\"");
add(10375,"DATA \"Tip: Use SCROLL for pager effects.\"");
add(10376,"DATA \"See also: PRINTAT, Page Reader\"");
add(10377,"DATA \"\"");
add(10380,"REM === Page 20: Math & Random / Math & Trig p1 ===");
add(10390,"DATA 8");
add(10391,"DATA \"MATH & TRIG - Part 1\"");
add(10392,"DATA \"What: Common numeric functions.\"");
add(10393,"DATA \"Funcs: ABS, INT, SGN, EXP, LOG\"");
add(10394,"DATA \"Funcs: SIN, COS, TAN   (radians)\"");
add(10395,"DATA \"Type: PRINT ABS(-3), INT(3.9)\"");
add(10396,"DATA \"Tip: Use parentheses for clarity.\"");
add(10397,"DATA \"See also: Operators, RND\"");
add(10398,"DATA \"\"");
add(10400,"REM === Page 21: Math & Random / Math & Trig p2 ===");
add(10410,"DATA 7");
add(10411,"DATA \"MATH & TRIG - Part 2\"");
add(10412,"DATA \"What: More math helpers and tips.\"");
add(10413,"DATA \"Type: PRINT SGN(-5), EXP(1)\"");
add(10414,"DATA \"Tip: Compare floats with a small tolerance.\"");
add(10415,"DATA \"Tip: Use MOD for wrap-around indices.\"");
add(10416,"DATA \"See also: RND, Operators\"");
add(10417,"DATA \"\"");
add(10420,"REM === Page 22: Math & Random / RND ===");
add(10430,"DATA 7");
add(10431,"DATA \"RND\"");
add(10432,"DATA \"What: Random number generator.\"");
add(10433,"DATA \"Type: PRINT RND()         ' 0.0..1.0\"");
add(10434,"DATA \"Type: PRINT RND(6)       ' 1..6\"");
add(10435,"DATA \"Type: PRINT RND(2,5)     ' 2..5\"");
add(10436,"DATA \"See also: Math & Trig, Operators\"");
add(10437,"DATA \"\"");
add(10440,"REM === Page 23: Math & Random / Operators ===");
add(10450,"DATA 7");
add(10451,"DATA \"OPERATORS\"");
add(10452,"DATA \"What: + - * /  \\  MOD  ^  and comparisons.\"");
add(10453,"DATA \"Type: PRINT 3+4*2, 7 MOD 5, 5^2\"");
add(10454,"DATA \"Tip: '\\' is integer divide; trunc toward zero.\"");
add(10455,"DATA \"Tip: Use parentheses to control order.\"");
add(10456,"DATA \"See also: Math & Trig\"");
add(10457,"DATA \"\"");
add(10460,"REM === Page 24: Strings / Substring & LEN ===");
add(10470,"DATA 8");
add(10471,"DATA \"STRINGS - Substrings\"");
add(10472,"DATA \"What: Slice parts of a string.\"");
add(10473,"DATA \"Syntax: LEFT$(S$,N), RIGHT$(S$,N), MID$(S$,s,l)\"");
add(10474,"DATA \"Type: S$=\"\"HELLO\"\": PRINT LEFT$(S$,2)   ' HE\"");
add(10475,"DATA \"Type: PRINT MID$(S$,2,3)               ' ELL\"");
add(10476,"DATA \"Note: LEN is not provided in this build.\"");
add(10477,"DATA \"See also: CHR$/ASC, Concatenation, REPEAT$\"");
add(10478,"DATA \"\"");
add(10480,"REM === Page 25: Strings / CHR$ & ASC ===");
add(10490,"DATA 7");
add(10491,"DATA \"STRINGS - CHR$ & ASC\"");
add(10492,"DATA \"What: Convert between codes and characters.\"");
add(10493,"DATA \"Type: PRINT CHR$(65)      ' A\"");
add(10494,"DATA \"Type: PRINT ASC(\"\"A\"\")     ' 65\"");
add(10495,"DATA \"Tip: Useful for line chars or input parsing.\"");
add(10496,"DATA \"See also: Substrings, Concatenation\"");
add(10497,"DATA \"\"");
add(10500,"REM === Page 26: Strings / Concatenation ===");
add(10510,"DATA 8");
add(10511,"DATA \"STRINGS - Concatenation, semicolon or +\"");
add(10512,"DATA \"What: Join strings with +.\"");
add(10513,"DATA \"Type: NAME$=\"\"Ada\"\": PRINT \"\"Hi, \"\"+NAME$\"");
add(10514,"DATA \"Type: PRINT \"\"A=\"\" + STR$(3)\"");
add(10515,"DATA \"Type: PRINT REPEAT$(\"\"-\"\",5) ' -----\"");
add(10516,"DATA \"Semicolon = no line feed after string\"");
add(10517,"DATA \"Tip: Build long lines piece by piece.\"");
add(10518,"DATA \"See also: PRINT, Substrings, REPEAT$\"");
add(10520,"REM === Page 27: Data & Arrays / DATA-READ-RESTORE p1 ===");
add(10530,"DATA 8");
add(10531,"DATA \"DATA / READ / RESTORE - Part 1\"");
add(10532,"DATA \"What: Store constants in the code and read them.\"");
add(10533,"DATA \"Syntax: DATA ...  ;  READ A,B$  ;  RESTORE\"");
add(10534,"DATA \"Type: RESTORE: READ N$,X: PRINT N$,X\"");
add(10535,"DATA \"Type: DATA \"\"OK\"\", 42\"");
add(10536,"DATA \"Tip: Keep tables grouped at the end.\"");
add(10537,"DATA \"See also: Named Streams, Arrays\"");
add(10538,"DATA \"\"");
add(10540,"REM === Page 28: Data & Arrays / DATA-READ-RESTORE p2 ===");
add(10550,"DATA 8");
add(10551,"DATA \"DATA / READ / RESTORE - Part 2\"");
add(10552,"DATA \"What: Seek by rewinding then skipping blocks.\"");
add(10553,"DATA \"Step 1: RESTORE\"");
add(10554,"DATA \"Step 2: READ past headers and tables\"");
add(10555,"DATA \"Step 3: Skip pages by count to your target\"");
add(10556,"DATA \"This help program uses that exact pattern.\"");
add(10557,"DATA \"See also: Page Reader code path\"");
add(10558,"DATA \"\"");
add(10560,"REM === Page 29: Data & Arrays / Named Streams ===");
add(10570,"DATA 7");
add(10571,"DATA \"NAMED DATA STREAMS\"");
add(10572,"DATA \"What: Keep multiple logical DATA streams.\"");
add(10573,"DATA \"Syntax: RESTORE but no line #;   READ ...\"");
add(10574,"DATA \"\"");
add(10575,"DATA \"Use: Separate content tables by purpose.\"");
add(10576,"DATA \"See also: DATA/READ/RESTORE\"");
add(10577,"DATA \"\"");
add(10580,"REM === Page 30: Data & Arrays / Arrays topic p1 ===");
add(10590,"DATA 7");
add(10591,"DATA \"ARRAYS - Topic (Part 1)\"");
add(10592,"DATA \"What: Use arrays for menus and listings.\"");
add(10593,"DATA \"Type: DIM IDX(32): IDX(1)=7: PRINT IDX(1)\"");
add(10594,"DATA \"Tip: 1-based loops pair well with arrays.\"");
add(10595,"DATA \"Tip: Always check user input bounds.\"");
add(10596,"DATA \"See also: Arrays p2, INPUT\"");
add(10597,"DATA \"\"");
add(10600,"REM === Page 31: Data & Arrays / Arrays topic p2 ===");
add(10610,"DATA 7");
add(10611,"DATA \"ARRAYS - Topic (Part 2)\"");
add(10612,"DATA \"What: Store records in parallel arrays.\"");
add(10613,"DATA \"Type: DIM A(3),B$(3): A(1)=10: B$(1)=\"\"OK\"\"\"");
add(10614,"DATA \"\"");
add(10615,"DATA \"\"");
add(10616,"DATA \"See also: Data & Arrays\"");
add(10617,"DATA \"\"");
add(10620,"REM === Page 32: Editor & Files / Editor Commands p1 ===");
add(10630,"DATA 8");
add(10631,"DATA \"EDITOR COMMANDS - Part 1\"");
add(10632,"DATA \"What: Basic editor actions.\"");
add(10633,"DATA \"Type: LIST   : RUN   : NEW   : SAVE \"\"NAME\"\"\"");
add(10634,"DATA \"Use: COPY then :PASTE to move blocks of code\"");
add(10635,"DATA \"Use: DIR overlay to pick files\"");
add(10636,"DATA \"Tip: Keep frequent saves and backups.\"");
add(10637,"DATA \"See also: Shortcuts, DIR Overlay\"");
add(10638,"DATA \"\"");
add(10640,"REM === Page 33: Editor & Files / Editor Commands p2 ===");
add(10650,"DATA 7");
add(10651,"DATA \"EDITOR COMMANDS - Part 2\"");
add(10652,"DATA \"What: Edit by line number; retype to replace.\"");
add(10653,"DATA \"Use: LIST to view lines; NEW clears program\"");
add(10654,"DATA \"Use: RUN to execute; ESC to stop\"");
add(10655,"DATA \"Tip: Save often with SAVE \"\"NAME\"\"\"");
add(10656,"DATA \"SCREENEDIT or SE to load full screen editor.\"");
add(10657,"DATA \"See also: SAVE/LOAD\"");
add(10660,"REM === Page 34: Editor & Files / Editor Commands p3 ===");
add(10670,"DATA 7");
add(10671,"DATA \"EDITOR COMMANDS - Part 3\"");
add(10672,"DATA \"What: Debugging tips.\"");
add(10673,"DATA \"Use: Console logs for tracing (HTML)\"");
add(10674,"DATA \"Use: RUN to Run Program, ESC to stop\"");
add(10675,"DATA \"\"");
add(10676,"DATA \"See also: Shortcuts\"");
add(10677,"DATA \"\"");
add(10680,"REM === Page 35: Editor & Files / DIR Overlay ===");
add(10690,"DATA 7");
add(10691,"DATA \"DIR OVERLAY\"");
add(10692,"DATA \"What: Pick files from a directory overlay.\"");
add(10693,"DATA \"Keys: Arrows to move, ENTER select, ESC cancel\"");
add(10694,"DATA \"Tip: Pause editor input while overlay is open.\"");
add(10695,"DATA \"Tip: Validate names and paths.\"");
add(10696,"DATA \"See also: SAVE/LOAD\"");
add(10697,"DATA \"NOTE: Currently some oddities 9 Sept 2025\"");
add(10700,"REM === Page 36: Editor & Files / SAVE-LOAD ===");
add(10710,"DATA 8");
add(10711,"DATA \"SAVE / LOAD\"");
add(10712,"DATA \"What: Save a program and load it later.\"");
add(10713,"DATA \"Type: SAVE \"\"DEMO\"\"   :   LOAD \"\"DEMO\"\"\"");
add(10714,"DATA \"Tip: Avoid spaces or odd characters in \"");
add(10715,"DATA \"names.\"");
add(10716,"DATA \"Tip: Confirm overwrite; keep versions.\"");
add(10717,"DATA \"Tip: Consider auto-save on run or exit.\"");
add(10718,"DATA \"See also: Editor Commands, DIR Overlay\"");
add(10720,"REM === Page 37: Editor & Files / Shortcuts p1 ===");
add(10730,"DATA 7");
add(10731,"DATA \"SHORTCUTS - Part 1\"");
add(10732,"DATA \"F5 Dumps program to Console (HTML); ESC = STOP\"");
add(10733,"DATA \"Ctrl+C Copy   ;   Ctrl+V Paste (browser perms)\"");
add(10734,"DATA \"Command: HELP to open this help\"");
add(10735,"DATA \"Tip: Show hints in the status bar.\"");
add(10736,"DATA \"SE short for SCREENEDIT; Full screen editor\"");
add(10737,"DATA \"See also: Shortcuts p2\"");
add(10740,"REM === Page 38: Editor & Files / Shortcuts p2 ===");
add(10750,"DATA 7");
add(10751,"DATA \"SHORTCUTS - Part 2\"");
add(10752,"DATA \"Tips: Keep lines short; use gaps 10,20,30\"");
add(10753,"DATA \"Tips: Label output: PRINT \"\"A=\"\" ; A\"");
add(10754,"DATA \"Tips: Use comments with REM or '\"");
add(10755,"DATA \"Tips: Re-run often; save before big edits\"");
add(10756,"DATA \"See also: Editor Commands\"");
add(10757,"DATA \"\"");

}
/// @event obj_basic_interpreter/Step
// ==============================
// obj_basic_interpreter → Step Event
// ==============================

// (Optional debug tap)
// if (keyboard_check_pressed(vk_enter)) {
//     show_debug_message("ENTER pressed - pause_in_effect: " + string(global.pause_in_effect) +
//                        ", awaiting_input: " + string(global.awaiting_input) +
//                        ", pause_mode: " + string(global.pause_mode));
// }

// ---------- Feed INKEY$ queue once per frame ----------
// (The function itself arbitrates INPUT vs. INKEY modal wait.)
inkey_capture_keys();

global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    if (dbg_on(DBG_PERF)) show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}

// ==============================
// Sort program lines in ascending order
// ==============================
if (ds_exists(global.line_list, ds_type_list)) {
    ds_list_sort(global.line_list, true);
}

// ==============================
// === Program Ended: Wait for user action ===
// ==============================
if (global.program_has_ended) {
    if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
    if (keyboard_check_pressed(vk_pagedown)) {
        var font_height = string_height("A");
        var visible_lines = floor(room_height / font_height) - 2;
        var total_lines = ds_list_size(global.output_lines);
        global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines - visible_lines));
    }

    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {

        // ==== INSERTED HELP RESTORE HOOK ====
        if (variable_global_exists("help_active") && global.help_active) {
            help_restore_program();   // puts the user's code back
            global.help_active = false;
        }
        // ==== END INSERT ====

        global.program_has_ended = false;
        global.current_mode = 0;

        var _ret = variable_global_exists("editor_return_room")
               ? global.editor_return_room
               : room_first; // fallback if something goes weird

        room_goto(_ret);
    }
    return;
}


// ==============================
// INPUT mode (line editor) routing — keep your working flow
// ==============================
if (global.awaiting_input) {
    if (global.pause_mode) {
        if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: ENTER/ESC detected, resuming...");
            global.awaiting_input   = false;
            global.pause_mode       = false;
            global.pause_in_effect  = false;
            global.input_target_var = "";
            global.interpreter_input = "";
            global.interpreter_resume_stmt_index = global.interpreter_current_stmt_index + 1;
        }
    } else {
        for (var _k = 32; _k <= 126; _k++) if (keyboard_check_pressed(_k)) handle_interpreter_character_input(_k);
        if (keyboard_check_pressed(vk_enter))     handle_interpreter_character_input(vk_enter);
        if (keyboard_check_pressed(vk_backspace)) handle_interpreter_character_input(vk_backspace);
    }
    return;
}

// ==============================
// INKEY$ modal wait handler (blocking GET-style)
// Armed by LET when RHS is pure INKEY$ (your basic_cmd_let should set:
//   global.inkey_waiting = true; global.pause_in_effect = true;)
// This handler captures ONE key, stashes it, and lets the same LET re-run next frame.
// ==============================
if (global.inkey_waiting) {
    // If we ALREADY have a captured char, DO NOT pause or return here.
    // Let the interpreter proceed so LET ... = INKEY$ can commit and clear flags.
    if (string_length(global.inkey_captured) > 0) {
        global.pause_in_effect = false; // allow interpreter to advance
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: resume for commit (cached='" + global.inkey_captured + "')");
        // NOTE: NO 'return' here — fall through to the interpreter loop
    } else {
        // Try to obtain exactly one key this frame
        var _ch = "";

        // Prefer queued key captured by inkey_capture_keys()
        if (ds_exists(global.__inkey_queue, ds_type_queue) && ds_queue_size(global.__inkey_queue) > 0) {
            _ch = ds_queue_dequeue(global.__inkey_queue);
            if (is_real(_ch)) _ch = chr(_ch);
        }

        // Fallback: direct pressed-edge scan this frame
        if (_ch == "") {
            for (var _kc = 32; _kc <= 126; _kc++) {
                if (keyboard_check_pressed(_kc)) { _ch = chr(_kc); break; }
            }
        }

        if (_ch != "") {
            // Stash and allow interpreter to proceed THIS frame to re-run LET
            global.inkey_captured  = string(_ch);
            global.pause_in_effect = false;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: captured '" + global.inkey_captured + "', resuming for commit");
            // NOTE: NO 'return' here — fall through to the interpreter loop
        } else {
            // Nothing yet: keep interpreter paused and try again next frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: still waiting for key");
            return; // only return when we truly don't have a key this frame
        }
    }
}

// ==============================
// Synchronize for structured IF…ELSE handling
// ==============================
global.interpreter_current_line_index = line_index;

// ==============================
// Handle Jumps (prefer legacy line jump)
// ==============================
if (global.interpreter_next_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: legacy line jump wins → line=" + string(global.interpreter_next_line));
    line_index = global.interpreter_next_line;
    global.interpreter_current_line_index = global.interpreter_next_line;
    global.interpreter_resume_stmt_index = 0;

    // Clear any stale statement-level jump
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line   = -1;
    global.interpreter_target_stmt   = 0;

    global.interpreter_next_line = -1;
} else if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: using statement-level jump → line=" + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt));
    line_index = global.interpreter_target_line;
    global.interpreter_current_line_index = global.interpreter_target_line;
    global.interpreter_resume_stmt_index = max(0, global.interpreter_target_stmt);
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line = -1;
    global.interpreter_target_stmt = 0;
    global.interpreter_next_line = -1;
}

// ==============================
// End of Program Check
// ==============================
if (line_index >= ds_list_size(global.line_list)) {
    global.interpreter_running = false;
}

// ==============================
// Execute BASIC Line
// ==============================
if (line_index < ds_list_size(global.line_list)) {
    var line_number = ds_list_find_value(global.line_list, line_index);
    var code        = ds_map_find_value(global.program_map, line_number);

    var trimmed = string_trim(code);
    var parts   = split_on_unquoted_colons(trimmed);

    global.current_line_number = line_number;
    if (dbg_on(DBG_FLOW)) show_debug_message("Running line " + string(line_number));

    var _start_stmt = 0;
    if (global.interpreter_resume_stmt_index > 0) {
        _start_stmt = global.interpreter_resume_stmt_index;
        if (dbg_on(DBG_FLOW)) show_debug_message("Resuming at statement index " + string(_start_stmt)
            + " on line " + string(line_number));
        global.interpreter_resume_stmt_index = 0;
    }

    for (var p = _start_stmt; p < array_length(parts); p++) {
        var stmt = string_trim(parts[p]);
        if (stmt == "") continue;

        var sp2  = string_pos(" ", stmt);
        var cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        var arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        // REM / apostrophe: stop the physical line
        if (cmd2 == "REM" || string_char_at(stmt, 1) == "'") {
            if (dbg_on(DBG_FLOW)) {
                show_debug_message("REM/' : stop parsing remainder of line "
                    + string(line_number) + " at part " + string(p) + "/"
                    + string(array_length(parts) - 1));
            }
            break;
        }

        // Strip inline remark then recompute verb/arg
        stmt = strip_basic_remark(stmt);
        sp2  = string_pos(" ", stmt);
        cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        global.interpreter_current_stmt_index = p;

        if (dbg_on(DBG_FLOW)) show_debug_message("Command: " + cmd2 + " | Arg: " + arg2);
        handle_basic_command(cmd2, arg2);

        // If a pause was armed (e.g., modal INKEY$), stop RIGHT HERE
        if (global.pause_in_effect) {
            global.interpreter_resume_stmt_index = p; // retry this colon slot next frame
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: engaged during statement; will retry stmt index " + string(p) + " next frame");
            break;
        }

        // Prefer legacy line jump; clear stale stmt-level flags
        if (global.interpreter_next_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for LEGACY LINE jump");
            global.interpreter_use_stmt_jump = false;
            global.interpreter_target_line   = -1;
            global.interpreter_target_stmt   = 0;
            break;
        }
        if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for STATEMENT-LEVEL jump request");
            break;
        }
    }

    // If no jump requested and NOT paused, advance to next line
    if (!(global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0)
     && !(global.interpreter_next_line >= 0)
     && !global.pause_in_effect) {
        line_index++;
    }
} else {
    global.interpreter_running = false;
}

// ==============================
// Escape Returns to Editor
// ==============================
if (keyboard_check_pressed(vk_escape)) {
    global.current_mode = 0;
    room_goto(global.editor_return_room);
}

// ==============================
// F5 Dumps BASIC to Console
// ==============================
if (keyboard_check_released(vk_f5) && basic_run_to_console_flag == false) {
    basic_run_to_console_flag = true;
    basic_run_to_console();
}

// ==============================
// Manual Scroll (Always Available)
// ==============================
if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
if (keyboard_check_pressed(vk_pagedown)) {
    var font_height2 = string_height("A");
    var visible_lines2 = floor(room_height / font_height2) - 2;
    var total_lines2 = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);
    global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines2 - visible_lines2));
}

// (Legacy path retained; harmless with new flow)
if (global.pause_in_effect && global.inkey_mode) {
    handle_inkey_input();
}
// === END: obj_basic_interpreter.Step ===

function basic_tokenize_expression_v2(expr) { 
    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting expression: '" + expr + "'");

    var tokens  = [];
    var i       = 1;
    var len     = string_length(expr);
    var current = "";

    // Names that, when immediately followed by '(', should be treated as function calls
    var function_names = ["RND","ABS","EXP","LOG","LOG10","SGN","INT","SIN","COS","TAN","STR$","CHR$","REPEAT$","ASC","LEN"];

    while (i <= len) {
        var c = string_char_at(expr, i);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");

        // --------------------------------------------------------------------
        // STRING LITERALS: copy verbatim `"..."` including the closing quote.
        // --------------------------------------------------------------------
        if (c == "\"") {
            var str = "\"";
            i++;
            while (i <= len) {
                var ch = string_char_at(expr, i);
                str += ch;
                if (ch == "\"") break;   // NOTE: this keeps doubled quotes as-is; evaluator unescapes "" → "
                i++;
            }
            array_push(tokens, str);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added (quoted string): " + str);
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // WHITESPACE: finalize any pending token and skip the space.
        // --------------------------------------------------------------------
        if (c == " ") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token from space: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // RELATIONAL (two-char first): <=  >=  <>
        // We must emit these as single tokens so "ROLL<3" → ["ROLL","<","3"].
        // --------------------------------------------------------------------
        if (c == "<" || c == ">") {
            // finalize any pending identifier/number before the operator
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before relation: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            var two = (i < len) ? c + string_char_at(expr, i + 1) : "";
            if (two == "<=" || two == ">=" || two == "<>") {
                array_push(tokens, two);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Relation token added: " + two);
                i += 2;
                continue;
            } else {
                array_push(tokens, c);  // bare < or >
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Relation token added: " + c);
                i += 1;
                continue;
            }
        }

        // --------------------------------------------------------------------
        // EQUALITY: single '='
        // --------------------------------------------------------------------
        if (c == "=") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before '=': '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, "=");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: '=' token added");
            i += 1;
            continue;
        }

        // --------------------------------------------------------------------
        // ARITHMETIC / PARENS / POWER / INT-DIV: +  *  /  \  (  )  %  ^
        //  - If '(' follows a known function name token, we still just emit '(';
        //    the function-ness is used later by the parser, not the tokenizer.
        // --------------------------------------------------------------------
        if (c == "+" || c == "*" || c == "/" || c == "\\" || c == "(" || c == ")" || c == "%" || c == "^") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before operator: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            // We still push "(" literally. Detection of "NAME(" being a function call
            // is handled later by your infix/postfix logic (it looks at the NAME token).
            array_push(tokens, c);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);

            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // ARG SEPARATOR: comma
        // --------------------------------------------------------------------
        if (c == ",") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before comma: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, ",");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Comma token added");
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // MINUS: subtraction or start of a negative number token.
        // Heuristic: if '-' is at start, or follows another operator/paren/relation,
        // and is followed by a digit, we treat it as the start of a numeric literal.
        // --------------------------------------------------------------------
        if (c == "-") {
            // finalize any pending token first
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before minus: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            var is_negative = false;

            // only consider negative if a digit follows
            if (i < len) {
                var next_is_digit = (ord(string_char_at(expr, i + 1)) >= 48 && ord(string_char_at(expr, i + 1)) <= 57);
                if (next_is_digit) {
                    if (array_length(tokens) == 0) {
                        is_negative = true; // start of expression → negative
                    } else {
                        var last_token = tokens[array_length(tokens) - 1];
                        // If previous token is an operator/paren/relation, this '-' starts a number
                        if ( last_token == "+" || last_token == "-" || last_token == "*" 
                          || last_token == "/" || last_token == "(" || last_token == "%" 
                          || last_token == "^" || string_upper(last_token) == "MOD" 
                          || last_token == "=" || last_token == "<" || last_token == ">" 
                          || last_token == "<=" || last_token == ">=" || last_token == "<>" ) {
                            is_negative = true;
                        }
                    }
                }
            }

            if (is_negative) {
                current = "-"; // begin building a numeric literal like "-12"
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting negative number");
            } else {
                array_push(tokens, "-"); // subtraction operator
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Added subtraction operator");
            }

            i++;
            continue;
        }
        // ------------------------- END '-' handling -------------------------

        // --------------------------------------------------------------------
        // DEFAULT: accumulate chars for identifiers or number bodies.
        // --------------------------------------------------------------------
        current += c;
        i++;
    }

    // ------------------------------------------------------------------------
    // END: flush any leftover token.
    // ------------------------------------------------------------------------
    if (current != "") {
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing last token: '" + current + "'");
        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Final token list = " + string(tokens));
    return tokens;
}

/// @script dbg_macros.gml
#macro DBG_PARSE  1     // tokenizer, parser, DIM/LET parsing
#macro DBG_EVAL   2     // postfix eval, expression values
#macro DBG_FLOW   4     // IF/WHILE/GOTO/GOSUB flow
#macro DBG_IO     8     // INPUT/PRINT/UI prompts
#macro DBG_ARRAY  16    // array get/set, DIM
#macro DBG_PERF   32    // performance
#macro DBG_STEP   64    // Execution
#macro DBG_EXEC   128	// EXEC
#macro DBG_ALL    0x7fffffff

/*
DEBUG MASKING — HOW TO USE (READ THIS FIRST)
============================================

## WHAT THIS FILE IS

These `#macro` lines define **compile-time constants** used to *categorize* your
debug logs. They are simple bit flags (1, 2, 4, …) that you OR together to
decide which kinds of messages should print at runtime.

```
#macro DBG_PARSE  1     // tokenizer & parser chatter
#macro DBG_EVAL   2     // postfix evaluation & expression results
#macro DBG_FLOW   4     // IF/WHILE/WEND/GOTO/GOSUB decisions
#macro DBG_IO     8     // INPUT/PRINT/UI prompts & commits
#macro DBG_ARRAY  16    // DIM + array get/set + bounds logs
#macro DBG_ALL    0x7fffffff  // convenience: everything on
```

> IMPORTANT: Macros must live at **top level** (not inside a function). Keep
> this file as-is; don’t wrap these lines in a function.

## REQUIRED COMPANION (dbg.gml)

You also have two helper functions defined in `dbg.gml`:

```
function dbg_on(cat) -> bool
    // Returns TRUE if the category bit is enabled in global.debug_mask.
    // Very cheap; use around *occasional* logs.

function dbg(cat, msg) -> void
    // Prints a message if the category bit is enabled AND you haven’t
    // exceeded the per-frame quota. Use inside tight loops to avoid FPS hits.
```

Both helpers rely on these globals, which you should initialize once in your
interpreter’s Create/Init event:

```
if (!variable_global_exists("debug_mask")) {
    global.debug_mask        = DBG_ALL;   // start verbose; tune later
    global.dbg_frame_quota   = 1200;      // max logs per frame before dropping
    global.dbg_frame_count   = 0;         // internal counter (do not set manually)
    global.dbg_dropped_count = 0;         // internal counter (do not set manually)
}
```

And reset the quota each frame (Step Start of the interpreter object):

```
global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}
```

## HOW TO WRAP EXISTING LOGS

You have hundreds of `show_debug_message(...)` calls. Wrap them gradually:

• High-volume / in loops (tokenizer, postfix, array hot-paths) → **use `dbg()`**
This enforces the per-frame quota automatically.
BEFORE:
show\_debug\_message("TOKENIZER: Char\[" + string(i) + "]='" + c + "'");
AFTER:
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "]='" + c + "'");

• Low-volume / occasional (flow decisions, one-off prints) → **use `dbg_on()`**
This is a tiny mask check; then you call `show_debug_message` yourself.
BEFORE:
show\_debug\_message("WEND: Condition is TRUE — looping");
AFTER:
if (dbg\_on(DBG\_FLOW)) show\_debug\_message("WEND: Condition is TRUE — looping");

Tip: It’s fine to mix both styles. Prefer `dbg()` anywhere that can spam.

## WHAT EACH MASK MEANS (AND WHERE TO USE IT)

• DBG\_PARSE
Use on: tokenizer (`basic_tokenize_expression_v2`), parser/splitters,
command lexing (verb/arg extraction).
Goal: see how text becomes tokens. No evaluation yet.

• DBG\_EVAL
Use on: postfix creation/evaluation, math/operator application, variable loads.
Goal: see stack pushes/pops and numeric/string results.

• DBG\_FLOW
Use on: `basic_cmd_if/_if_inline`, `basic_cmd_while`, `basic_cmd_wend`,
loop stack push/pop, `GOTO/GOSUB/RETURN` target resolution.
Goal: follow control flow decisions and jumps.

• DBG\_IO
Use on: `basic_cmd_input`, `basic_cmd_print`, wrapping/commit pipeline,
prompt emission, input state flips.
Goal: ensure prompts and outputs render and input mode is toggled correctly.

• DBG\_ARRAY
Use on: `basic_cmd_dim`, `basic_array_get`, `basic_array_set`, bounds checks.
Goal: track sizes, indices, auto-grow, and OOB warnings.

• DBG\_ALL
Convenience macro: enable all categories at once.

## HOW TO TURN CATEGORIES ON/OFF

At runtime (debugger Watch window, a script, or once in Create):

```
// All off:
global.debug_mask = 0;

// Only FLOW:
global.debug_mask = DBG_FLOW;

// Only IO:
global.debug_mask = DBG_IO;

// FLOW + IO together:
global.debug_mask = DBG_FLOW | DBG_IO;

// Everything on:
global.debug_mask = DBG_ALL;
```

You can also toggle bits on the fly:

```
// Flip the PARSE bit:
global.debug_mask ^= DBG_PARSE;
```

If you temporarily cranked the quota for a heavy trace, put it back:

```
global.dbg_frame_quota = 1200;    // typical safe value
// (set larger, e.g., 100000, if you want to capture *everything* for a short run)
```

## OPTIONAL: QUICK HOTKEY TO CYCLE VERBOSITY

Add this to the interpreter object’s Step (or Step Begin):

```
if (keyboard_check_pressed(vk_f9)) {
    var next = (global.debug_mask == 0)
        ? (DBG_FLOW | DBG_IO)   // useful day-to-day
        : (global.debug_mask == (DBG_FLOW | DBG_IO) ? DBG_ALL : 0);
    global.debug_mask = next;
    show_debug_message("DBG: mask now = " + string(next));
}
```

## COMMON PITFALLS & TIPS

• Macros not recognized → Ensure this file (`dbg_macros.gml`) is a separate
script asset with **only** the `#macro` lines at top level. If you still see
“variable not defined” on a macro name, **Clean** the project and rebuild.

• Compile order → Place `dbg_macros.gml` near the top of your Scripts folder so
everything else sees it. (Macros are compile-time, but ordering can trip
partial rebuilds.)

• Use `dbg()` for anything inside loops; it’s quota-aware. If you use
`dbg_on()` + `show_debug_message(...)` in a hot loop you can still tank FPS.

• Migration strategy → You don’t need to wrap everything at once. Start with:
tokenizer (DBG\_PARSE), evaluation (DBG\_EVAL), flow (DBG\_FLOW). That usually
kills 90% of the spam while keeping the most actionable signal.

## EXAMPLES (COPY/PASTE)

Tokenizer char echo (quota-aware):
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "] = '" + string\_char\_at(s, i) + "'");

Flow decision:
if (dbg\_on(DBG\_FLOW))
show\_debug\_message("IF: result=" + string(result) + " → " + (result ? "THEN" : "ELSE"));

Input prompt emission:
dbg(DBG\_IO, "INPUT: Prompt='" + rawPrompt + "' → var=" + varName);

Array set:
dbg(DBG\_ARRAY, "ARRAY SET: " + name + "\[" + string(idx) + "] = " + string(val));

## QUICK START

1. Keep these macros here (top level).
2. Ensure `dbg.gml` exists with `dbg_on` and `dbg`.
3. Initialize the globals in Create, reset counters in Step Start.
4. Wrap high-volume logs with `dbg(cat, msg)`, occasional logs with `dbg_on`.
5. Control verbosity by setting `global.debug_mask` at runtime:
   • All off: 0
   • Only FLOW: DBG\_FLOW
   • Only IO: DBG\_IO
   • FLOW + IO: DBG\_FLOW | DBG\_IO
   • Everything: DBG\_ALL
6. If things feel slow, reduce the mask and/or lower `global.dbg_frame_quota`.

That’s it. You keep the power of your detailed logs without drowning the Runner.
*/

/// Build/refresh the in-memory help topics tree
function help_build_topics() {
    // Initialize help_state if it doesn't exist
    if (!variable_global_exists("help_state")) {
        global.help_state = { built: false };
    }
    
    // Initialize or recreate list
    if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }

    // ==== Topics ====
    
    // Topic 1: Editor Commands
    var t1 = { title: "Editor Commands", subs: [] };
    array_push(t1.subs, { 
        title: "RUN / NEW / CLEAR / LIST", 
        lines: [
            "RUN - Execute the current BASIC program.",
            "NEW or CLEAR - Remove all lines from memory.",
            "LIST [start-end] - Show program lines.",
            "F5 - Dump listing to console."
        ]
    });
    array_push(t1.subs, { 
        title: "FILES: SAVE / LOAD / DIR", 
        lines: [
            "SAVE \"name\" - Adds .BAS, writes to Documents/BasicInterpreter.",
            "LOAD \"name\" - Loads program.",
            "DIR - Interactive browser (arrows, Enter, D/X delete, ESC quit)."
        ]
    });
    ds_list_add(global.help_topics, t1);

    // Topic 2: Language Basics
    var t2 = { title: "Language Basics", subs: [] };
    array_push(t2.subs, { 
        title: "Lines, Variables, PRINT", 
        lines: [
            "Lines run in numeric order unless redirected.",
            "Numeric vars: A, X1; Strings: NAME$; Arrays: DIM A(10).",
            "PRINT text or values; ; keeps the cursor on the line."
        ]
    });
    array_push(t2.subs, { 
        title: "INPUT / INKEY$", 
        lines: [
            "INPUT prompts and waits; assigns to variable.",
            "INKEY$ returns last key (\"\" when none).",
            "Extended keys return 2-char sequences."
        ]
    });
    ds_list_add(global.help_topics, t2);

    // Topic 3: Control Flow
    var t3 = { title: "Control Flow", subs: [] };
    array_push(t3.subs, { 
        title: "IF / ELSE / ENDIF", 
        lines: [
            "Inline IF: IF X=1 THEN PRINT \"HI\"",
            "Block IF ... ELSE ... ENDIF is supported."
        ]
    });
    array_push(t3.subs, { 
        title: "FOR / NEXT, WHILE / WEND", 
        lines: [
            "FOR I=1 TO 10 [STEP S] ... NEXT",
            "WHILE condition ... WEND"
        ]
    });
    ds_list_add(global.help_topics, t3);

    // Topic 4: MODE 1 (Tile) Basics
    var t4 = { title: "MODE 1 (Tile) Basics", subs: [] };
    array_push(t4.subs, { 
        title: "PRINTAT / CHARAT / PSET", 
        lines: [
            "PRINTAT x,y,\"TEXT\"[,FG,BG]",
            "CHARAT x,y,code[,FG,BG] places a tile/char.",
            "PSET x,y,code[,FG,BG,BG] shorthand."
        ]
    });
    // Topic 5: Math & Random
    var t5 = { title: "Math & Random", subs: [] };
    array_push(t5.subs, { 
        title: "Math Functions", 
        lines: [
            "ABS, INT, SGN, EXP, LOG, LOG10",
            "SIN, COS, TAN (work in radians)",
            "^ for exponentiation",
            "Standard operator precedence"
        ]
    });
    array_push(t5.subs, { 
        title: "Random Numbers", 
        lines: [
            "RND(6) returns 1 to 6",
            "RND(1,10) returns range 1 to 10", 
            "RND or RND(1) returns 0 to 1"
        ]
    });
    ds_list_add(global.help_topics, t5);

    // Topic 6: Strings
    var t6 = { title: "Strings", subs: [] };
    array_push(t6.subs, { 
        title: "String Functions", 
        lines: [
            "LEFT$, RIGHT$, MID$ for substrings",
            "LEN for string length",
            "CHR$(65) converts to \"A\"",
            "ASC(\"A\") converts to 65"
        ]
    });
    ds_list_add(global.help_topics, t6);

    // Topic 7: Data & Arrays  
    var t7 = { title: "Data & Arrays", subs: [] };
    array_push(t7.subs, { 
        title: "DATA/READ/RESTORE", 
        lines: [
            "DATA statement stores values",
            "READ loads into variables", 
            "RESTORE resets to start",
            "Named streams: DATA @name: values"
        ]
    });
    array_push(t7.subs, { 
        title: "Arrays", 
        lines: [
            "DIM A(10) creates array 0 to 10",
            "Use in loops: FOR I=0 TO 10",
            "Multi-dimensional: DIM A(5,5)",
            "Dynamic sizing: DIM A(X+5)"
        ]
    });
    ds_list_add(global.help_topics, t7);

    // Topic 8: Input/Output
    var t8 = { title: "Input/Output", subs: [] };
    array_push(t8.subs, { 
        title: "PRINT Variations", 
        lines: [
            "PRINT X prints value and newline",
            "PRINT X; keeps cursor on line",
            "PRINT X,Y,Z uses tab columns",
            "PRINT without args = blank line"
        ]
    });
    array_push(t8.subs, { 
        title: "INPUT and Keys", 
        lines: [
            "INPUT \"Prompt: \",VAR waits for input",
            "INKEY$ returns last key pressed",
            "CLS clears screen",
            "COLOR FG,BG sets colors"
        ]
    });
    ds_list_add(global.help_topics, t8);

    // Topic 9: Editor & Files
    var t9 = { title: "Editor & Files", subs: [] };
    array_push(t9.subs, { 
        title: "File Operations", 
        lines: [
            "SAVE \"filename\" saves program",
            "LOAD \"filename\" loads program",
            "DIR opens file browser",
            "Drag & drop .BAS files to load"
        ]
    });
    array_push(t9.subs, { 
        title: "Editor Commands", 
        lines: [
            "LIST shows program lines",
            "RUN executes program",
            "NEW or CLEAR erases program",
            "F5 dumps to console"
        ]
    });
    ds_list_add(global.help_topics, t9);

    global.help_state.built = true;
}
/// @function basic_cmd_for(arg) 
/// @description Parses and handles BASIC FOR loop initialization (spacing-tolerant; optional STEP)
function basic_cmd_for(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Entering handler with argument: '" + string(arg) + "'");

    // 1) Parse "VAR = start TO end [STEP step]"
    var raw   = string_trim(string(arg));
    var eqpos = string_pos("=", raw);
    if (eqpos <= 0) {
        basic_syntax_error("FOR missing '=' - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var varname = string_upper(string_trim(string_copy(raw, 1, eqpos - 1)));
    if (varname == "") {
        basic_syntax_error("FOR missing variable name before '='",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var rhs = string_trim(string_copy(raw, eqpos + 1, string_length(raw) - eqpos));

    // find TO
    var to_at = -1;
    for (var p = 1; p <= string_length(rhs) - 1; p++) {
        if (string_upper(string_copy(rhs, p, 2)) == "TO") { to_at = p; break; }
    }
    if (to_at < 0) {
        basic_syntax_error("FOR missing TO - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var start_expr = string_trim(string_copy(rhs, 1, to_at - 1));
    var after_to   = string_trim(string_copy(rhs, to_at + 2, string_length(rhs) - (to_at + 1)));
    if (start_expr == "" || after_to == "") {
        basic_system_message("SYNTAX ERROR IN FOR (incomplete expressions): " + raw);
        global.interpreter_running = false;
        return;
    }

    // optional STEP
    var step_expr = "1";
    var to_expr   = after_to;

    var step_at = -1;
    for (var q = 1; q <= string_length(after_to) - 3; q++) {
        if (string_upper(string_copy(after_to, q, 4)) == "STEP") { step_at = q; break; }
    }
    if (step_at > 0) {
        to_expr   = string_trim(string_copy(after_to, 1, step_at - 1));
        step_expr = string_trim(string_copy(after_to, step_at + 4, string_length(after_to) - (step_at + 3)));
        if (step_expr == "") step_expr = "1";
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Header pieces → var='" + varname
        + "' | start='" + start_expr + "' | to='" + to_expr + "' | step='" + step_expr + "'");

    // 2) Evaluate start, to, step
    var start_tokens  = basic_tokenize_expression_v2(start_expr);
    var start_postfix = infix_to_postfix(start_tokens);
    var start_val     = evaluate_postfix(start_postfix);

    var to_val_eval   = basic_evaluate_expression_v2(to_expr);
    var step_val_eval = basic_evaluate_expression_v2(step_expr);

    // --- SAFE RESOLUTION: only accept string if it's a variable name; never call real() on text ---
    if (is_string(to_val_eval)) {
        var key_to = string_upper(string_trim(to_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_to)) {
            to_val_eval = global.basic_variables[? key_to];
        } else {
            basic_syntax_error("FOR ... TO must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_RANGE");
            return;
        }
    }
    if (is_string(step_val_eval)) {
        var key_step = string_upper(string_trim(step_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_step)) {
            step_val_eval = global.basic_variables[? key_step];
        } else {
            // if user wrote STEP "" or a non-var string, reject
            basic_syntax_error("FOR ... STEP must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_STEP");
            return;
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Eval → start=" + string(start_val)
        + " | to(eval)=" + string(to_val_eval) + " [raw='" + to_expr + "']"
        + " | step(eval)=" + string(step_val_eval) + " [raw='" + step_expr + "']");

    // 3) Initialize loop var
    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }
    global.basic_variables[? varname] = start_val;
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Initialized variable " + varname + " = " + string(start_val));

    // 4) Push frame (legacy + inline stmt coordinates)
    var legacy_return_line = line_index;
    var loop_line_idx = line_index;
    var loop_stmt_idx = -1;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        loop_stmt_idx = global.interpreter_current_stmt_index + 1;
    }

    if (!ds_exists(global.for_stack, ds_type_stack)) {
        global.for_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Safety — created global.for_stack");
    }

    var frame = {
        varname     : varname,
        to          : to_val_eval,
        step        : step_val_eval,
        to_raw      : to_expr,       // keep raw for dynamic re-eval in NEXT
        step_raw    : step_expr,     // keep raw for dynamic re-eval in NEXT
        return_line : legacy_return_line,
        loop_line   : loop_line_idx,
        loop_stmt   : loop_stmt_idx
    };
    ds_stack_push(global.for_stack, frame);

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Pushed frame → {var=" + varname
        + ", to=" + string(to_val_eval)
        + ", step=" + string(step_val_eval)
        + ", return_line=" + string(legacy_return_line)
        + ", loop=(" + string(loop_line_idx) + "," + string(loop_stmt_idx) + ")}");
}

/// === BEGIN: basic_cmd_let ===
/// LET handler with modal INKEY$ support and array handling
function basic_cmd_let(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("LET: Raw input: '" + arg + "'");

    // Split "NAME = EXPR"
    var eq = string_pos("=", arg);
    if (eq <= 0) {
        basic_syntax_error("LET requires '='", /*line*/ undefined, global.interpreter_current_stmt_index, "LET_MISSING_EQUALS");
        return;
    }

    var varName = string_trim(string_copy(arg, 1, eq - 1));
    var exprStr = string_trim(string_copy(arg, eq + 1, string_length(arg) - eq));

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("LET: Parsed variable name: '" + varName + "'");
        show_debug_message("LET: Parsed expression    : '" + exprStr + "'");
    }

    // ---------- MODAL INKEY$: pure RHS detection ----------
    var expr_uc = string_upper(exprStr);
    var is_pure_inkey = false;

    // Allow "INKEY$" or "INKEY$()" with arbitrary spaces
    // Strip whitespace
    var expr_compact = string_replace_all(string_replace_all(expr_uc, " ", ""), "\t", "");
    if (expr_compact == "INKEY$" || expr_compact == "INKEY$()") is_pure_inkey = true;

    if (is_pure_inkey) {

        // 1) If we are resuming from a prior wait and have a captured char, COMMIT now.
        if (variable_global_exists("inkey_waiting") && global.inkey_waiting) {
            if (variable_global_exists("inkey_captured") && string_length(global.inkey_captured) > 0) {
                var ch_commit = string(global.inkey_captured);
                
                // Handle array vs regular variable for INKEY$ assignment
                if (basic_is_array_reference(varName)) {
                    basic_assign_to_array(varName, ch_commit);
                } else {
                    var k = basic_normvar(varName);
                    global.basic_variables[? k] = ch_commit;
                }

                // Clear modal flags
                global.inkey_captured   = "";
                global.inkey_waiting    = false;
                global.pause_in_effect  = false;
                global.inkey_target_var = "";

                if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: committed '" + ch_commit + "' to " + varName + " (resume)");
                return;
            }

            // Still waiting, keep paused this frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: still waiting (no captured char yet)");
            return;
        }

        // 2) Not waiting yet – FAST PATH: assign immediately if queue already has a key
        // Support either queue name (__inkey_queue primary; inkey_queue legacy)
        var _q = undefined;
        if (ds_exists(global.__inkey_queue, ds_type_queue)) _q = global.__inkey_queue;
        else if (variable_global_exists("inkey_queue") && ds_exists(global.inkey_queue, ds_type_queue)) _q = global.inkey_queue;

        if (!is_undefined(_q) && ds_queue_size(_q) > 0) {
            var ch2 = ds_queue_dequeue(_q);
            if (is_real(ch2)) ch2 = chr(ch2);
            
            // Handle array vs regular variable for INKEY$ assignment
            if (basic_is_array_reference(varName)) {
                basic_assign_to_array(varName, string(ch2));
            } else {
                var k = basic_normvar(varName);
                global.basic_variables[? k] = string(ch2);
            }
            
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: fast-path assign '" + string(ch2) + "' to " + varName);
            return;
        }

        // 3) Arm modal wait: no key ready yet → pause interpreter and let Step capture ONE key
        global.inkey_waiting    = true;
        global.pause_in_effect  = true;
        global.inkey_target_var = varName; // Store the full variable name including array syntax
        global.inkey_captured   = "";
        if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: armed modal wait for " + varName);
        return;
    }
    // ---------- END MODAL INKEY$ special case ----------

    // ---------- Default LET path: evaluate expression and assign ----------
    var tokens  = basic_tokenize_expression_v2(exprStr);
    var postfix = infix_to_postfix(tokens);
    var val     = evaluate_postfix(postfix);

    // Check if this is an array assignment
    if (basic_is_array_reference(varName)) {
        basic_assign_to_array(varName, val);
        return;
    }

    // Regular variable assignment (existing logic)
    var k = basic_normvar(varName);

    // Coerce based on variable sigil: trailing $ means string var
    var is_string_var = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");
    if (is_string_var) {
        global.basic_variables[? k] = string(val);
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned string value: '" + string(val) + "' to '" + k + "'");
    } else {
        // Numeric: if it looks numeric, coerce to real; else 0 (or keep as-is if you prefer)
        if (is_real(val)) {
            global.basic_variables[? k] = val;
        } else if (basic_looks_numeric(string(val))) {
            global.basic_variables[? k] = real(val);
        } else {
            global.basic_variables[? k] = 0;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned value: '" + string(global.basic_variables[? k]) + "' to '" + k + "'");
    }
}


/// @function editor_html_handle_paste_command
// === BEGIN: editor_html_handle_paste_command ===
function editor_html_handle_paste_command() {
    // Only meaningful in browser builds; desktop uses editor_handle_paste_command
    if (os_browser == browser_not_a_browser) {
        show_error_message("Use normal Paste on desktop. :PASTE is for browser builds.");
        return;
    }

    // Gate to avoid double-bind/log spam
    if (is_undefined(global.__editor_html_paste_bound)) global.__editor_html_paste_bound = false;
    if (global.__editor_html_paste_bound) {
        // Already waiting for a Ctrl/Cmd+V from the user
        basic_show_message("Paste is already waiting — click the game, then press Ctrl+V (⌘V on Mac).");
        if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE/HTML] already bound");
        return;
    }

    // Accept text only
    var _filter = function(kind, type) {
        // kind: "string" for text; "file" for files
        return (kind == "string");
    };

    // One-shot handler: identical parsing/mutation to Windows path
    var _handler = function(data, name, type) {
        // For text, YellowAfterLife sets name==undefined
        if (!is_undefined(name)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE/HTML] ignored non-text paste: name=" + string(name) + " type=" + string(type));
            // unbind and reset
            browser_paste_bind();
            global.__editor_html_paste_bound = false;
            return;
        }

        var raw_clip = string(data);
        if (string_length(raw_clip) <= 0) {
            show_message("Clipboard is empty.");
            browser_paste_bind();
            global.__editor_html_paste_bound = false;
            return;
        }

        var lines = string_split(raw_clip, "\n");
        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: captured " + string(array_length(lines)) + " raw lines");

        for (var i = 0; i < array_length(lines); i++) {
            var line = string_trim(lines[i]);
            if (string_length(line) == 0) continue;

            // Expect: <number><space><code>
            var space_pos = string_pos(" ", line);
            if (space_pos > 0) {
                var line_num_str = string_copy(line, 1, space_pos - 1);
                var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

                // Windows CRLF: trim trailing '\r' if present
                if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
                    code_str = string_copy(code_str, 1, string_length(code_str) - 1);
                }

                if (string_digits(line_num_str) == line_num_str) {
                    var line_num = real(line_num_str);

                    if (line_num > 0 && string_length(code_str) > 0) {
                        // INSERT or REPLACE program text
                        ds_map_set(global.program_lines, line_num, code_str);
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");

                        // Maintain ordered line number list — add only if not present
                        var idx = ds_list_find_index(global.line_numbers, line_num);
                        if (idx == -1) {
                            ds_list_add(global.line_numbers, line_num);
                            ds_list_sort(global.line_numbers, true);
                            if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
                        } else if (dbg_on(DBG_FLOW)) {
                           if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
                        }
                    }
                }
            }
        }

        basic_show_message("Program pasted successfully.");

        // One-shot: unbind after handling a paste so normal keys resume
        browser_paste_bind();
        global.__editor_html_paste_bound = false;
    };

    // Bind paste; some wrappers don’t return a bool to GML, so don’t trust the return value
    browser_paste_bind(_handler, _filter);
    global.__editor_html_paste_bound = true;

    // Match your existing UX/logging
    if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Bound. Click the game, then press Ctrl/Cmd+V.");
    basic_show_message("Paste ready — click the game, then press Ctrl+V (⌘V on Mac).");
}
// === END: editor_html_handle_paste_command ===

/// @function basic_cmd_next(arg)
/// @description Handles BASIC NEXT loop continuation (legacy-compatible; optional inline-colon support)
function basic_cmd_next(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Entering handler with arg: '" + string(arg) + "'");

    if (!ds_exists(global.for_stack, ds_type_stack) || ds_stack_empty(global.for_stack)) {
        basic_syntax_error("NEXT without matching FOR",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_MISMATCH");
        return;
    }

    var frame = ds_stack_top(global.for_stack);

    // Optional check: NEXT I
    var user_var = string_trim(string_upper(string(arg)));
    if (user_var != "" && is_struct(frame) && variable_struct_exists(frame, "varname")) {
        if (string_upper(frame.varname) != user_var && dbg_on(DBG_FLOW)) {
            show_debug_message("NEXT: WARNING — NEXT " + user_var + " does not match active FOR var " + string(frame.varname));
        }
    }

    var varname     = frame.varname;
    var to_val      = frame.to;
    var step_val    = frame.step;
    var return_line = frame.return_line;
    var loop_line   = (variable_struct_exists(frame, "loop_line")) ? frame.loop_line : -1;
    var loop_stmt   = (variable_struct_exists(frame, "loop_stmt")) ? frame.loop_stmt : -1;

    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }

    // Re-evaluate TO / STEP each iteration if they weren’t numeric
    if (!is_real(to_val)) {
        var to_expr_local = variable_struct_exists(frame, "to_raw") ? frame.to_raw : to_val;
        to_val = basic_evaluate_expression_v2(to_expr_local);
        if (is_string(to_val)) {
            var key_to = string_upper(string_trim(to_expr_local));
            if (!ds_map_exists(global.basic_variables, key_to)) {
                basic_syntax_error("FOR ... TO must be numeric",
                    global.current_line_number, global.interpreter_current_stmt_index, "FOR_TO_NONNUM");
                return;
            }
            to_val = global.basic_variables[? key_to];
        }
        frame.to = to_val;
    }
    if (!is_real(step_val)) {
        var step_expr_local = variable_struct_exists(frame, "step_raw") ? frame.step_raw : step_val;
        step_val = basic_evaluate_expression_v2(step_expr_local);
        if (is_string(step_val)) {
            var key_step = string_upper(string_trim(step_expr_local));
            if (!ds_map_exists(global.basic_variables, key_step)) {
                // default if someone did STEP with a non-numeric symbol
                step_val = 1;
            } else {
                step_val = global.basic_variables[? key_step];
            }
        }
        frame.step = step_val;
    }

    var current = global.basic_variables[? varname];

    if (step_val == 0) {
        var inferred = (to_val >= current) ? 1 : -1;
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: STEP=0; defaulting to " + string(inferred));
        step_val = inferred;
        frame.step = step_val;
    }

    current += step_val;
    global.basic_variables[? varname] = current;

    var continue_loop = (step_val > 0) ? (current <= to_val) : (current >= to_val);
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: to=" + string(to_val)
        + " step=" + string(step_val) + " current=" + string(current)
        + " → continue=" + string(continue_loop));

    if (continue_loop) {
        var have_stmt_jump =
            variable_global_exists("interpreter_target_line") &&
            variable_global_exists("interpreter_target_stmt");

        if (have_stmt_jump && loop_line >= 0 && loop_stmt >= 0) {
            global.interpreter_target_line = loop_line;
            global.interpreter_target_stmt = loop_stmt;
            if (variable_global_exists("interpreter_use_stmt_jump")) {
                global.interpreter_use_stmt_jump = true;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Inline jump → (" + string(loop_line) + "," + string(loop_stmt) + ")");
        } else {
            global.interpreter_next_line = return_line + 1; // legacy line jump
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Legacy jump → line index " + string(global.interpreter_next_line));
        }
    } else {
        ds_stack_pop(global.for_stack);
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Loop complete — popped FOR frame");
    }
}

/// @script basic_cmd_if
/// @description Block‐structured IF…THEN…ELSEIF…ELSE…ENDIF initializer
function basic_cmd_if(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("IF START — Raw arg: '" + arg + "'");

    // 1) Compute the current line‐list index (we assume global.interpreter_next_line was pre-incremented)
    var current_index = global.interpreter_current_line_index;

// DEBUG: Show what's in the IF block map
    if (dbg_on(DBG_FLOW))  show_debug_message("DEBUG: current_index = " + string(current_index));
    var keys = ds_map_keys_to_array(global.if_block_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (dbg_on(DBG_FLOW))  show_debug_message("DEBUG: IF block map key[" + string(i) + "] = " + string(keys[i]));
    }



    // ── Legacy inline IF?  If no block metadata exists, invoke old handler ──
    if (!ds_map_exists(global.if_block_map, current_index)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("No block metadata for line " + string(current_index) + 
                           " — falling back to INLINE IF");
        basic_cmd_if_inline(arg);
        return;
    }

    // 2) Strip off the trailing THEN and isolate the condition
    var raw     = string_trim(arg);
    var upper   = string_upper(raw);
    var then_pos = string_pos("THEN", upper);
    if (then_pos <= 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var condition_text = string_trim(string_copy(raw, 1, then_pos - 1));
    if (dbg_on(DBG_FLOW))  show_debug_message("Parsed condition: '" + condition_text + "'");

    // 3) Evaluate the condition (supporting simple AND/OR)
    var result    = false;
    var logic_op  = "";
    var upcond    = string_upper(condition_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";

    if (logic_op != "") {
        var parts = string_split(condition_text, logic_op);
        if (array_length(parts) != 2) {
            if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: Malformed " + logic_op + " condition: '" + condition_text + "'");
            return;
        }
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        if (dbg_on(DBG_FLOW))  show_debug_message("Combined condition (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(condition_text);
        if (dbg_on(DBG_FLOW))  show_debug_message("Single condition result: " + string(result));
    }

    // 4) Fetch the precomputed block‐metadata for this IF
    if (!ds_map_exists(global.if_block_map, current_index)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: No IF block metadata for line index " + string(current_index));
        return;
    }
    var blockInfo    = global.if_block_map[? current_index];
    var firstBranch  = blockInfo[? "firstBranchIndex"];

    // 5) Push a new frame onto the IF‐stack
    var frame = ds_map_create();
    ds_map_add(frame, "startIndex",      current_index);
    ds_map_add(frame, "takenBranch",     result);
    ds_map_add(frame, "firstBranchIndex", firstBranch);
    ds_map_add(frame, "endifIndex",      blockInfo[? "endifIndex"]);
    ds_map_add(frame, "elseifIndices",   blockInfo[? "elseifIndices"]);  // a ds_list of indices
    ds_map_add(frame, "elseIndex",       blockInfo[? "elseIndex"]);      // –1 if none
    ds_stack_push(global.if_stack, frame);

    // 6) Jump into THEN‐block or skip to the first ELSEIF/ELSE/ENDIF
    if (result) {
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("IF TRUE: entering THEN at index " + string(global.interpreter_next_line));
    } else {
        global.interpreter_next_line = firstBranch;
        if (dbg_on(DBG_FLOW))  show_debug_message("IF FALSE: skipping to index " + string(global.interpreter_next_line));
    }
}

/// handle_interpreter_character_input(key)
/// Processes editor keystrokes while awaiting BASIC INPUT.
/// Assumes helpers basic_normvar(name) and basic_looks_numeric(s) exist,
/// and global.basic_variables (ds_map) is initialized.
function handle_interpreter_character_input(key) {
    // --- PRINTABLE ASCII (uses keyboard_lastchar) ---
    if (key >= 32 && key <= 126) {
        var ch = string(keyboard_lastchar); // ensure string
        if (string_length(ch) > 0) {
            global.interpreter_input = string_insert(ch, global.interpreter_input, global.interpreter_cursor_pos + 1);
            global.interpreter_cursor_pos += 1;
        }
        return;
    }

    // --- BACKSPACE ---
    if (key == vk_backspace) {
        if (global.interpreter_cursor_pos > 0) {
            // Delete the character just to the left of the cursor
            global.interpreter_input = string_delete(global.interpreter_input, global.interpreter_cursor_pos, 1);
            global.interpreter_cursor_pos -= 1;
        }
        return;
    }

    // --- SPACE ---
    if (key == vk_space) {
        global.interpreter_input = string_insert(" ", global.interpreter_input, global.interpreter_cursor_pos + 1);
        global.interpreter_cursor_pos += 1;
        return;
    }

    // --- LEFT ARROW ---
    if (key == vk_left) {
        if (global.interpreter_cursor_pos > 0) {
            global.interpreter_cursor_pos -= 1;
        }
        return;
    }

    // --- RIGHT ARROW ---
    if (key == vk_right) {
        if (global.interpreter_cursor_pos < string_length(global.interpreter_input)) {
            global.interpreter_cursor_pos += 1;
        }
        return;
    }

    // --- ENTER: finalize INPUT and resume execution ---
    if (key == vk_enter) {
        var raw = string_trim(string(global.interpreter_input));
        var k   = basic_normvar(global.input_target_var);

        // String var if the normalized name ends with '$'
        var ends_with_dollar = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");

        var val;
        if (ends_with_dollar) {
            // String variable: commit exactly what the user typed
            val = raw;
        } else {
            // Numeric variable: only accept numeric-looking input (prevents silent 0 bugs)
            if (basic_looks_numeric(raw)) {
                val = real(raw);
            } else {
                // Stay in input mode; do not commit or advance
                if (!is_undefined(global.DEBUG_INPUT) && global.DEBUG_INPUT) {
                    show_debug_message("[INPUT] Type mismatch for " + k + " got '" + raw + "'. Still waiting.");
                }
                return;
            }
        }

        // Store under canonical key
        global.basic_variables[? k] = val;

        if (!is_undefined(global.DEBUG_INPUT) && global.DEBUG_INPUT) {
            show_debug_message("[INPUT] commit " + k + " <= '" + string(val) + "'");
        }

        // --- Post-commit housekeeping (keep these consistent with your existing flow) ---
        // Clear the input buffer and cursor
        global.interpreter_input      = "";
        global.interpreter_cursor_pos = 0;

        // Clear input mode flags/targets
        global.awaiting_input   = false;
        global.input_target_var = "";

        // If you echo the entered line to your output, do it here (optional):
        // ds_list_add(global.output_lines, string(val));
        // ds_list_add(global.output_colors, global.current_draw_color);

        return;
    }

    // (Optional) HOME / END support
    // if (key == vk_home) { global.interpreter_cursor_pos = 0; return; }
    // if (key == vk_end)  { global.interpreter_cursor_pos = string_length(global.interpreter_input); return; }
}

/// Helper function to assign values to arrays (BASIC-visible index is 1-based)
function basic_assign_to_array(varName, val) {
    // Parse array name and index from varName like "TOPIC$(I)"
    var open_paren  = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
    if (open_paren <= 0 || close_paren <= open_paren) {
        basic_syntax_error("Invalid array syntax: " + varName,
                           /*line_no*/ undefined,
                           /*stmt_idx*/ global.interpreter_current_stmt_index,
                           "ARRAY_SYNTAX");
        return;
    }

    var arrayName = string_trim(string_copy(varName, 1, open_paren - 1));
    var indexExpr = string_trim(string_copy(varName, open_paren + 1, close_paren - open_paren - 1));

    // Normalize array name used in your maps
    var normalizedArrayName = basic_normvar(arrayName);

    // Evaluate index expression (BASIC-side index, expected 1..N)
    var indexTokens  = basic_tokenize_expression_v2(indexExpr);
    var indexPostfix = infix_to_postfix(indexTokens);
    var indexVal     = evaluate_postfix(indexPostfix);

    // Safeguard against invalid index evaluation
    if (is_string(indexVal) || is_undefined(indexVal)) {
        basic_syntax_error("Invalid array index expression: " + indexExpr + " (evaluated to " + string(indexVal) + ")",
                           /*line_no*/ undefined,
                           /*stmt_idx*/ global.interpreter_current_stmt_index,
                           "ARRAY_INDEX_EVAL");
        return;
    }

    // Coerce to integer and enforce 1-based external indexing
    var idx1 = floor(real(indexVal));
    if (!is_real(idx1) || idx1 < 1) {
        basic_syntax_error("Array index must be >= 1 for " + arrayName + " (got " + string(indexVal) + ")",
                           /*line_no*/ undefined,
                           /*stmt_idx*/ global.interpreter_current_stmt_index,
                           "ARRAY_INDEX_RANGE");
        return;
    }

    // Convert to 0-based for ds_list
    var ds_idx = idx1 - 1;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("ARRAY ASSIGN: Array='" + normalizedArrayName
            + "' BASIC-idx=" + string(idx1) + " (ds_idx=" + string(ds_idx)
            + ") Value='" + string(val) + "'");
    }

    // Ensure the array map/list exists
    if (!ds_map_exists(global.basic_arrays, normalizedArrayName)) {
        global.basic_arrays[? normalizedArrayName] = ds_list_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: Created array '" + normalizedArrayName + "'");
    }

    var arrayList = global.basic_arrays[? normalizedArrayName];

    // Ensure capacity up to ds_idx (0-based)
    while (ds_list_size(arrayList) <= ds_idx) {
        ds_list_add(arrayList, 0); // default fill
    }

    // String arrays end with $, numeric otherwise
    var is_string_array = (string_length(normalizedArrayName) > 0)
                       && (string_char_at(normalizedArrayName, string_length(normalizedArrayName)) == "$");

    if (is_string_array) {
        ds_list_replace(arrayList, ds_idx, string(val));
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: " + normalizedArrayName + "[" + string(idx1) + "] (ds " + string(ds_idx) + ") = '" + string(val) + "' (string)");
    } else {
        var numVal = is_real(val) ? val : (basic_looks_numeric(string(val)) ? real(val) : 0);
        ds_list_replace(arrayList, ds_idx, numVal);
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: " + normalizedArrayName + "[" + string(idx1) + "] (ds " + string(ds_idx) + ") = " + string(numVal) + " (numeric)");
    }
}
/// @event obj_inkey_feeder/Step
if (os_browser != browser_not_a_browser) exit;
// === EARLY EXIT GUARDS ===
var _is_editor_room =
    (variable_global_exists("editor_return_room") && room == global.editor_return_room)
 || (variable_global_exists("editor_room") && room == global.editor_room)
 || (asset_get_index("rm_editor") != -1 && room == asset_get_index("rm_editor"))
 || instance_exists(obj_editor);

if (_is_editor_room) { keyboard_string = ""; exit; }
if (variable_global_exists("interpreter_running") && !global.interpreter_running) { keyboard_string = ""; exit; }

// === Ensure queue exists ===
if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
    global.inkey_queue = ds_queue_create();
}

// Capacity-aware enqueue (pass cap explicitly to avoid scope issues)
var _enq = function(val, cap) {
    while (ds_queue_size(global.inkey_queue) >= cap) ds_queue_dequeue(global.inkey_queue);
    ds_queue_enqueue(global.inkey_queue, val);
    if (dbg_on(DBG_PARSE)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("##KEYFEED## ENQ='" + string(val) + "'"
            + " A1=" + string((is_string(val) && string_length(val)>=1) ? ord(string_char_at(val,1)) : -1)
            + " A2=" + string((is_string(val) && string_length(val)>=2) ? ord(string_char_at(val,2)) : -1));
    }
};
var _CAP = 128;

// === 1) DISPLAYABLE TEXT (letters, digits, punctuation, space, shifted forms) ===
if (keyboard_string != "") {
    var s = keyboard_string;
    var n = string_length(s);
    for (var i = 1; i <= n; i++) {
        _enq(string_char_at(s, i), _CAP);
    }
    keyboard_string = "";
}

// === 2) STANDARD CONTROL KEYS (single-char control codes) ===
if (keyboard_check_pressed(vk_enter))     _enq(chr(13), _CAP); // Enter
if (keyboard_check_pressed(vk_tab))       _enq(chr(9),  _CAP); // Tab
if (keyboard_check_pressed(vk_backspace)) _enq(chr(8),  _CAP); // Backspace
if (keyboard_check_pressed(vk_escape))    _enq(chr(27), _CAP); // Escape

// === 3) NUMPAD DIGITS (show up even if keyboard_string doesn't) ===
if (keyboard_check_pressed(vk_numpad0)) _enq("0", _CAP);
if (keyboard_check_pressed(vk_numpad1)) _enq("1", _CAP);
if (keyboard_check_pressed(vk_numpad2)) _enq("2", _CAP);
if (keyboard_check_pressed(vk_numpad3)) _enq("3", _CAP);
if (keyboard_check_pressed(vk_numpad4)) _enq("4", _CAP);
if (keyboard_check_pressed(vk_numpad5)) _enq("5", _CAP);
if (keyboard_check_pressed(vk_numpad6)) _enq("6", _CAP);
if (keyboard_check_pressed(vk_numpad7)) _enq("7", _CAP);
if (keyboard_check_pressed(vk_numpad8)) _enq("8", _CAP);
if (keyboard_check_pressed(vk_numpad9)) _enq("9", _CAP);

// === 4) EXTENDED KEYS (QBASIC style: CHR$(0)+CHR$(scan)) ===
var _enqueue_ext = function(sc) { _enq(chr(0) + chr(sc), _CAP); };
if (keyboard_check_pressed(vk_up))    _enqueue_ext(72); // Up
if (keyboard_check_pressed(vk_down))  _enqueue_ext(80); // Down
if (keyboard_check_pressed(vk_left))  _enqueue_ext(75); // Left
if (keyboard_check_pressed(vk_right)) _enqueue_ext(77); // Right

// Convenience WASD (uppercase; add lowercase if desired)
if (keyboard_check_pressed(ord("W"))) _enq("W", _CAP);
if (keyboard_check_pressed(ord("A"))) _enq("A", _CAP);
if (keyboard_check_pressed(ord("S"))) _enq("S", _CAP);
if (keyboard_check_pressed(ord("D"))) _enq("D", _CAP);

function basic_cmd_wend() {
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Entering handler...");

    if (!ds_exists(global.while_stack, ds_type_stack) || ds_stack_empty(global.while_stack)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: ERROR — while_stack missing or empty");
        basic_show_message("WEND without matching WHILE");
        return;
    }

    var while_line_index = ds_stack_top(global.while_stack); // Peek, do not pop yet
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Top of while_stack is line index: " + string(while_line_index));

    // Prefer exact condition & resume slot captured at WHILE time
    var have_meta = (variable_global_exists("while_meta") && ds_exists(global.while_meta, ds_type_map)
                     && ds_map_exists(global.while_meta, string(while_line_index)));

    var cond_str, stmt_after;

    if (have_meta) {
        var meta = global.while_meta[? string(while_line_index)];
        cond_str   = string(meta[? "cond_str"]);
        stmt_after = meta[? "stmt_after"];
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Using stored cond='" + cond_str + "', stmt_after=" + string(stmt_after));
    } else {
        // === Legacy fallback (keeps prior behavior if meta missing) ===
        var while_line_number = ds_list_find_value(global.line_list, while_line_index);
        var while_code        = ds_map_find_value(global.program_map, while_line_number);
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Fallback WHILE line " + string(while_line_number) + " code: '" + while_code + "'");

        cond_str = string_trim(string_delete(while_code, 1, string_pos(" ", while_code)));
        stmt_after = 0; // we’ll jump to start of line as before in fallback
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Fallback extracted condition: '" + cond_str + "'");
    }

    var condition_value = basic_evaluate_condition(string_upper(cond_str));
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Re-evaluated condition result: " + string(condition_value));

    if (condition_value) {
        if (have_meta) {
            // === FIX 2: loop back to the colon slot immediately AFTER the WHILE header ===
            global.interpreter_use_stmt_jump = true;
            global.interpreter_target_line   = while_line_index;
            global.interpreter_target_stmt   = max(0, stmt_after);
            global.interpreter_next_line     = -1;
            if (dbg_on(DBG_FLOW)) show_debug_message("WEND: TRUE → jump to (line="
                + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt) + ")");
        } else {
            // Legacy behavior
            if (dbg_on(DBG_FLOW)) show_debug_message("WEND: TRUE (fallback) — setting line_index = " + string(while_line_index - 1));
            line_index = while_line_index - 1; // causes Step to re-run the WHILE line
        }
    } else {
        // Exit loop
        ds_stack_pop(global.while_stack);
        if (have_meta) {
            // Clean up stored meta for this WHILE
            ds_map_delete(global.while_meta, string(while_line_index));
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: FALSE → pop and continue");
    }
}

/// FILE: scripts/basic_parse_color.gml
/// FUNCTION: basic_parse_color(colstr)
/// Behavior:
/// 1) Try global.colors map (case-insensitive; quotes ok; aliases normalized)
/// 2) Try hex formats: &Hrrggbb, 0xrrggbb, #rrggbb, $rrggbb
/// 3) Try decimal integer
/// 4) Fallback to c_white with a debug note

function basic_parse_color(colstr) {
    var s = string_trim(colstr);

    // Strip matching quotes
    if (string_length(s) >= 2) {
        var f = string_char_at(s, 1);
        var l = string_char_at(s, string_length(s));
        if ((f == "\"" || f == "'") && f == l) s = string_copy(s, 2, string_length(s) - 2);
    }

    // Normalize for name lookup
    var key = string_upper(s);

    // Alias normalization to your existing keys
    if (key == "GREY") key = "GRAY";
    if (key == "DARKGRAY" || key == "DARKGREY") key = "DKGRAY";
    // LIGHTGRAY not in your map; handle as special case

    // 1) Named color via global.colors (global is a struct, so check the variable)
    if (variable_global_exists("colors")) {
        if (key == "LIGHTGRAY" || key == "LIGHTGREY") {
            return make_color_rgb(192,192,192);
        }
        if (ds_map_exists(global.colors, key)) {
            return ds_map_find_value(global.colors, key);
        }
    }

    // 2) Hex parsing (RRGGBB)
    var hex = "";
    var ku  = string_upper(s);
    if (string_length(ku) >= 3 && string_copy(ku,1,2) == "&H") {
        hex = string_copy(s, 3, string_length(s)-2);
    } else if (string_length(ku) >= 3 && string_copy(ku,1,2) == "0X") {
        hex = string_copy(s, 3, string_length(s)-2);
    } else if (string_length(ku) >= 1 && string_char_at(ku,1) == "#") {
        hex = string_copy(s, 2, string_length(s)-1);
    } else if (string_length(ku) >= 1 && string_char_at(ku,1) == "$") {
        hex = string_copy(s, 2, string_length(s)-1);
    }

    if (hex != "") {
        var clean = "";
        for (var i = 1; i <= string_length(hex); i++) {
            var ch = string_upper(string_char_at(hex, i));
            if ((ch >= "0" && ch <= "9") || (ch >= "A" && ch <= "F")) clean += ch;
        }
        if (string_length(clean) == 6) {
            var rr = string_copy(clean,1,2);
            var gg = string_copy(clean,3,2);
            var bb = string_copy(clean,5,2);
            return make_color_rgb(__hex_byte(rr), __hex_byte(gg), __hex_byte(bb));
        }
    }

    // 3) Decimal integer fallback
    if (is_numeric_string(s)) {
        return real(s);
    }

    // 4) Fallback
    if (dbg_on(DBG_FLOW)) show_debug_message("basic_parse_color: unknown color '" + s + "', defaulting to WHITE");
    return c_white;
}

function __hex_byte(two) {
    var hi = string_char_at(two,1);
    var lo = string_char_at(two,2);
    return __hex_nibble(hi) * 16 + __hex_nibble(lo);
}
function __hex_nibble(ch) {
    ch = string_upper(ch);
    if (ch >= "0" && ch <= "9") return ord(ch) - ord("0");
    if (ch >= "A" && ch <= "F") return 10 + (ord(ch) - ord("A"));
    return 0;
}

/// @script basic_cmd_color
/// @description Change text color (and optional background): COLOR fg[, bg]
function basic_cmd_color(arg) {
    // Split into up to two parts: foreground and optional background
    ///
	// Split on commas, but not inside parentheses
		var parts = [];
		var current = "";
		var paren_depth = 0;
		var trimmed_arg = string_trim(arg);

		for (var i = 1; i <= string_length(trimmed_arg); i++) {
		    var ch = string_char_at(trimmed_arg, i);
		    if (ch == "(") {
		        paren_depth++;
		        current += ch;
		    } else if (ch == ")") {
		        paren_depth--;
		        current += ch;
		    } else if (ch == "," && paren_depth == 0) {
		        array_push(parts, string_trim(current));
		        current = "";
		    } else {
		        current += ch;
		    }
		}
		if (string_trim(current) != "") {
		    array_push(parts, string_trim(current));
		}
	
	///
    var fgStr = string_upper(string_trim(parts[0]));
    var bgStr = (array_length(parts) > 1)
                ? string_upper(string_trim(parts[1]))
                : "";

    // Helper: parse a single color spec (named or RGB), returns -1 on error
    var parse_color = function(colSpec) {
        // RGB(r,g,b) form?
        if (string_copy(colSpec, 1, 4) == "RGB("
            && string_char_at(colSpec, string_length(colSpec)) == ")")
        {
            var inner = string_copy(colSpec, 5, string_length(colSpec) - 5);
            var comps = string_split(inner, ",");
            if (array_length(comps) == 3) {
                var r = clamp(real(string_trim(comps[0])), 0, 255);
                var g = clamp(real(string_trim(comps[1])), 0, 255);
                var b = clamp(real(string_trim(comps[2])), 0, 255);
                return make_color_rgb(r, g, b);
            } else {
                return -1;
            }
        }
        // Named color lookup
        if (ds_map_exists(global.colors, colSpec)) {
            return global.colors[? colSpec];
        }
        return -1;
    };

    // Parse and apply foreground
    var fgCol = parse_color(fgStr);
    if (fgCol >= 0) {
        global.basic_text_color   = fgCol;
        global.current_draw_color = fgCol;
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("?COLOR ERROR: Unknown foreground color '" + fgStr + "'");
    }

    // Parse and apply background (if provided)
    if (bgStr != "") {
        var bgCol = parse_color(bgStr);
        if (bgCol >= 0) {
            global.background_draw_color   = bgCol;
            global.background_draw_enabled = true;
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("?COLOR ERROR: Unknown background color '" + bgStr + "'");
        }
    }
}

/// Load a selected file (by 1-based index or exact filename) into program_lines/line_numbers
function editor_html_dir_open(which) {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("html_dir_files") || ds_list_size(global.html_dir_files) == 0) {
        show_message("No files selected. Use DIR to choose files first.");
        return false;
    }

    var idx = -1, n = ds_list_size(global.html_dir_files);
    var w = string_trim(which), W = string_upper(w);

    // numeric index (1-based)
    if (string_digits(w) == w) {
        var k = real(w);
        if (k >= 1 && k <= n) idx = k - 1;
    }
    // filename match
    if (idx < 0) {
        for (var i = 0; i < n; i++) {
            var rec_i = global.html_dir_files[| i];
            if (string_upper(ds_map_find_value(rec_i, "name")) == W) { idx = i; break; }
        }
    }
    if (idx < 0) { show_message("Not found. Use DIR SHOW to see indexes."); return false; }

    var rec = global.html_dir_files[| idx];
    var text = editor_html_decode_data_url_to_text(ds_map_find_value(rec, "data"));
    if (string_length(text) <= 0) {
        show_message("Unable to read file text.");
        return false;
    }

    // Parse exactly like your paste/Windows path
    var lines = string_split(text, "\n");
   if (dbg_on(DBG_FLOW)) show_debug_message("LOAD(HTML): captured " + string(array_length(lines)) + " raw lines");

    for (var j = 0; j < array_length(lines); j++) {
        var line = string_trim(lines[j]);
        if (string_length(line) == 0) continue;

        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var ln_str = string_copy(line, 1, space_pos - 1);
            var code   = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            if (string_length(code) > 0 && string_char_at(code, string_length(code)) == chr(13)) {
                code = string_copy(code, 1, string_length(code) - 1);
            }

            if (string_digits(ln_str) == ln_str) {
                var _ln = real(ln_str);
                if (_ln > 0 && string_length(code) > 0) {
                    ds_map_set(global.program_lines, _ln, code);
                    var found = ds_list_find_index(global.line_numbers, _ln);
                    if (found == -1) { ds_list_add(global.line_numbers, _ln); ds_list_sort(global.line_numbers, true); }
                }
            }
        }
    }

    basic_show_message("Program loaded: " + ds_map_find_value(rec, "name"));
    return true;
}

function load_program_from(filename)
{
    // Normalize input
    filename = string_trim(filename);
    if (string_length(filename) == 0) {
        basic_show_error_message("NO FILENAME PROVIDED");
        return;
    }
    // Strip quotes if present
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename) - 2);
    }
    // Add .bas if missing
    var ext = string_lower(string_copy(filename, string_length(filename) - 3, 4));
    if (ext != ".bas") {
        filename += ".bas";
    }

    // Build full path from the same directory used by SAVE
    var file_path = get_save_directory() + filename;

    if (!file_exists(file_path)) {
        basic_show_error_message("FILE NOT FOUND: " + filename);
        return;
    }

    // Clear current program (your function should reset global.program_lines etc.)
    new_program();

    var file = file_text_open_read(file_path);
    if (file == -1) {
        basic_show_error_message("COULD NOT OPEN FILE: " + filename);
        return;
    }

    // Read file line-by-line
    while (!file_text_eof(file)) {
        var line = file_text_read_string(file);
        file_text_readln(file); // consume newline
        line = string_trim(line);

        if (string_length(line) == 0) {
            continue; // skip empties
        }

        // Split on first space to detect a numeric line number
        var sp = string_pos(" ", line);
        if (sp <= 0) {
            // No space → treat as free text; assign a synthetic line number by asking your helper,
            // or just skip if you strictly require numeric lines. Here we skip to keep behavior predictable.
            continue;
        }

        var line_num_str = string_copy(line, 1, sp - 1);
        var code_content = string_copy(line, sp + 1, string_length(line) - sp);
        var line_num = real(line_num_str);

        // Use your existing validation helpers
        if (is_line_number(line_num_str) && is_valid_line_number(line_num)) {
            // Store into your canonical container and order list
            ds_map_set(global.program_lines, line_num, code_content);
            insert_line_number_ordered(line_num);
        }
    }

    file_text_close(file);
    current_filename = filename;
    basic_show_message("LOADED: " + filename);
    update_display();
}

function basic_cmd_bgcolor(arg) {
    var colstr = string_upper(string_trim(arg));
    if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Raw argument: '" + arg + "', Normalized: '" + colstr + "'");
    
    var bg_color = c_black;
    var matched = false;

    // Look up named color
    if (ds_map_exists(global.colors, colstr)) {
        bg_color = global.colors[? colstr];
        matched = true;
        if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Matched named color → " + string(bg_color));
    }
    // RGB() syntax
   else if (string_pos("RGB(", colstr) == 1) {
    var l = string_pos("(", colstr), r = string_last_pos(")", colstr);
    if (r > l) {
        var inner = string_copy(colstr, l + 1, r - l - 1);
        var parts = []; var buf = ""; var _depth = 0;
        for (var i = 1; i <= string_length(inner); i++) {
            var ch = string_char_at(inner, i);
            if (ch == "(") _depth++; else if (ch == ")") _depth--;
            if (ch == "," && _depth == 0) { array_push(parts, buf); buf = ""; } else buf += ch;
        }
        array_push(parts, buf);
        if (array_length(parts) == 3) {
            var rV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[0]))), 0, 255);
            var gV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[1]))), 0, 255);
            var bV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[2]))), 0, 255);
            bg_color = make_color_rgb(rV, gV, bV); matched = true;
        } else if (dbg_on(DBG_FLOW))  {show_debug_message("BGCOLOR: Invalid RGB arg count in '" + inner + "'");}
    } else if (dbg_on(DBG_FLOW))  {show_debug_message("BGCOLOR: Missing ) in '" + colstr + "'");}
}
 else {
        if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: No matching named color or RGB format found for '" + colstr + "'");
    }

    global.background_draw_color = bg_color;
    global.background_draw_enabled = (bg_color != c_black);

    if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Final color set to " + string(bg_color) + ", background_draw_enabled: " + string(global.background_draw_enabled));
}

/// scripts/list_saved_programs/list_saved_programs.gml
function list_saved_programs()
{
    var ed = instance_find(obj_editor, 0);
    if (ed == noone) { if (dbg_on(DBG_IO)) show_debug_message("[DIR] no obj_editor instance"); return; }

    if (!variable_instance_exists(ed, "dir_listing"))          ed.dir_listing = [];
    if (!variable_instance_exists(ed, "showing_dir_overlay"))  ed.showing_dir_overlay = false;

    var save_dir = get_save_directory();
    if (!is_string(save_dir) || string_length(save_dir) == 0) save_dir = working_directory;
    if (!directory_exists(save_dir)) directory_create(save_dir);

    // Persist save dir for actions
    ed.dir_save_dir = save_dir;

    // Build listing (.bas only)
    ed.dir_listing = [];
    var mask = save_dir + "*.bas";
    var fname = file_find_first(mask, 0); // IMPORTANT: 0 = no attribute filter
    var count = 0;
    while (fname != "") {
        array_push(ed.dir_listing, fname);
        count += 1;
        fname = file_find_next();
    }
    file_find_close();
    if (count == 0) array_push(ed.dir_listing, "No .bas files found.");

    // Initialize overlay state (ASCII UI)
    ed.dir_sel                 = 0;           // selected row (0-based in view)
    ed.dir_page                = 0;           // current page (0-based)
    ed.dir_page_size           = 1;           // will be recomputed in Draw each frame
    ed.dir_sorted_by           = "name";      // future use: "name"|"date"|"size"
    ed.dir_filter              = "";          // future filter text
    ed.dir_preview_on          = false;       // optional preview pane toggle
    ed.dir_confirm_active      = false;       // delete confirm modal
    ed.dir_confirm_index       = -1;          // which file index is pending delete
    ed.dir_mouse_hover_row     = -1;          // hover state (optional)
    ed.dir_mouse_hover_action  = "";          // ""|"load"|"del"

    ed.showing_dir_overlay = true;

    if (dbg_on(DBG_IO)) show_debug_message("[DIR] open path=" + save_dir + " files=" + string(count));
}

/// @script basic_cmd_else
/// @description Handle ELSE in a structured IF…ELSEIF…ELSE…ENDIF
function basic_cmd_else() {
    if (dbg_on(DBG_FLOW)) show_debug_message("ELSE START");

    // Guard: IF stack must exist and be non-empty
    if (!ds_exists(global.if_stack, ds_type_stack) || ds_stack_size(global.if_stack) == 0) {
        if (dbg_on(DBG_FLOW)) show_debug_message("?ELSE ERROR: ELSE without matching IF (empty IF stack)");
        return;
    }

    // Pull current IF frame (map id)
    var frame_id = ds_stack_top(global.if_stack);
    if (!ds_exists(frame_id, ds_type_map)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("?ELSE ERROR: IF frame missing/invalid map");
        return;
    }

    // Read state with safe defaults
    var taken   = ds_map_exists(frame_id, "takenBranch") ? (frame_id[? "takenBranch"]) : false;
    var endifIx = ds_map_exists(frame_id, "endifIndex")  ? (frame_id[? "endifIndex"])  : -1;

    var current_index = global.interpreter_current_line_index;

    if (taken) {
        // Already ran IF or an ELSEIF → skip ELSE body to ENDIF (if known)
        if (endifIx >= 0) {
            global.interpreter_next_line = endifIx;
            if (dbg_on(DBG_FLOW)) show_debug_message("ELSE skipping to ENDIF at index " + string(endifIx));
        } else {
            // Fallback: advance one line if ENDIF index unknown
            global.interpreter_next_line = current_index + 1;
            if (dbg_on(DBG_FLOW)) show_debug_message("ELSE: no ENDIF index; advancing to " + string(global.interpreter_next_line));
        }
    } else {
        // No branch taken yet → execute ELSE body
        ds_map_replace(frame_id, "takenBranch", true);
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW)) show_debug_message("ELSE entering branch at index " + string(global.interpreter_next_line));
    }
}

/// @event obj_mode1_grid/Create
//Create 40x25 grid for 32x32 character tiles
grid_cols = 40;
grid_rows = 25;
tile_width = 32;
tile_height = 32;

grid = array_create(grid_cols * grid_rows);

// Each grid cell will be a struct:
function make_tile_struct(char = 32, fg = c_white, bg = c_black) {
    return { char: char, fg: fg, bg: bg };
}

// Initialize all tiles
for (var i = 0; i < array_length(grid); i++) {
    grid[i] = make_tile_struct();
}

self.mode1_grid_fill = function(char, fg, bg) {
    if (dbg_on(DBG_FLOW))  show_debug_message(">> GRID FILL START: char=" + string(char) + ", fg=" + string(fg) + ", bg=" + string(bg));
    if (dbg_on(DBG_FLOW))  show_debug_message(">> Grid array length: " + string(array_length(grid)));
    
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char;
        grid[i].fg = fg;
        grid[i].bg = bg;
    }
    
    // Check first few tiles to verify they were set
    for (var i = 0; i < 3; i++) {
        if (dbg_on(DBG_FLOW))  show_debug_message(">> Tile[" + string(i) + "]: char=" + string(grid[i].char) + ", fg=" + string(grid[i].fg) + ", bg=" + string(grid[i].bg));
    }
    if (dbg_on(DBG_FLOW))  show_debug_message(">> GRID FILL END");
}

	drewfont = 0;//temp var

	// CHANGE: compute cols/rows from cell size

	grid_cols = floor(room_width  / global.mode1_cell_px); // 40 @ 32px in 1280 room
	grid_rows = floor(room_height / global.mode1_cell_px); // 25 @ 32px in 800 room


	grid = array_create(grid_cols * grid_rows);

	for (var i = 0; i < array_length(grid); i++) {
	    grid[i] = { char: 32, fg: c_white, bg: c_black };
	}

	// Ensure sprite active
	if (is_undefined(global.mode1_active_sprite)) {
	    global.mode1_active_sprite = global.font_sheets[? "DEFAULT_32"];
	}


function basic_system_message(_msg, _color) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message START ===");
    if (dbg_on(DBG_FLOW)) show_debug_message("Incoming message: " + string(_msg));
    if (dbg_on(DBG_FLOW)) show_debug_message("Incoming color arg: " + string(_color));

    // Do NOT create here — run_program owns creation.
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("basic_system_message: output buffers not initialized; SKIPPING write.");
        if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message END (skipped) ===");
        return;
    }

    var wrap_width = 40; // keep in sync with PRINT path
    var col = is_undefined(_color) ? global.current_draw_color : _color;
    if (dbg_on(DBG_FLOW)) show_debug_message("Using color: " + string(col));

    var text = string(_msg);
    if (dbg_on(DBG_FLOW)) show_debug_message("Wrapping text: " + text);

    while (string_length(text) > wrap_width) {
        var chunk = string_copy(text, 1, wrap_width);
        if (dbg_on(DBG_FLOW)) show_debug_message("Adding wrapped chunk: '" + chunk + "'");
        ds_list_add(global.output_lines, chunk);
        ds_list_add(global.output_colors, col);
        text = string_delete(text, 1, wrap_width);
    }

   if (dbg_on(DBG_FLOW))  show_debug_message("Adding final remainder: '" + text + "'");
    ds_list_add(global.output_lines, text);
    ds_list_add(global.output_colors, col);

    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message END ===");
}

// FILE: scripts/screen_editor_commit_row/screen_editor_commit_row.gml
/// @function screen_editor_commit_row(editor_inst, _row)
function screen_editor_commit_row(editor_inst, _row) {
    with (editor_inst) {
        var line_text = string_trim(screen_editor_get_row_text(id, _row));
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Committing row " + string(_row) + ": '" + line_text + "'");
        
        if (line_text == "") return;
        
        // Check for EXIT command
        if (string_upper(line_text) == "EXIT") {
            screen_editor_exit(id);
            return;
        }
        
        // Parse line number and code
        var space_pos = string_pos(" ", line_text);
        var line_num_str = "";
        var code = "";
        
        if (space_pos > 0) {
            line_num_str = string_copy(line_text, 1, space_pos - 1);
            code = string_trim(string_copy(line_text, space_pos + 1, string_length(line_text)));
        } else {
            line_num_str = line_text;
        }
        
        // Check if it's a valid line number
        var line_num = real(line_num_str);
        if (line_num_str != "" && is_real(line_num) && line_num > 0) {
            if (code == "") {
                // Delete line
                delete_program_line(line_num);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Deleted line " + string(line_num));
            } else {
                // Add/update line
                add_or_update_program_line(line_num, code);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Added/updated line " + string(line_num) + ": " + code);
            }
        }
    }
}
function editor_html_dir_prompt() {
    if (dbg_on(DBG_FLOW)) show_debug_message("[ENTER] editor_html_dir_prompt");

    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt (not browser)");
        return false;
    }

    // --- Re-entrancy guard: prevent duplicate dialogs for a single DIR dispatch
    if (!variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;
    if (global.__html_dir_opening) {
        if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] prompt suppressed (already opening)");
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt (guard)");
        return false;
    }
    global.__html_dir_opening = true;

    // --- Init extension (safe to call repeatedly)
    browser_file_tools_init();

    // --- Reset cached list (destroy old maps, clear list)
    editor_html_dir__reset();

    // --- Open dialog (multiselect = true). Accept .bas and text/plain
    browser_show_open_dialog(
        ".bas,text/plain",
        true,
        editor_html_dir__open_handler,   // persistent handler; will clear the guard
        editor_html_dir__open_filter
    );

    // Show the warning message about potential bugs using BASIC interpreter's message system
    basic_show_message("If Load fails, try again: bugs.");

    if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] open dialog shown");
    if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt");
    return true;
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 // Functions for input handling
 function handle_character_input() {
    var key_string = keyboard_string;
    
    // Robust keyboard handling with fallback
    if (key_string != last_keyboard_string) {
        var new_chars = string_copy(key_string, string_length(last_keyboard_string) + 1, 
                                   string_length(key_string) - string_length(last_keyboard_string));
        
        // Filter out control characters and validate input
        var filtered_chars = "";
        for (var i = 1; i <= string_length(new_chars); i++) {
            var char = string_char_at(new_chars, i);
            var char_code = ord(char);
            // Accept printable ASCII characters (32-126)
            if (char_code >= 32 && char_code <= 126) {
                filtered_chars += char;
            }
        }
        
        if (filtered_chars != "") {
            current_input = string_insert(filtered_chars, current_input, cursor_pos + 1);
            cursor_pos += string_length(filtered_chars);
        }
        
        last_keyboard_string = key_string;
    }
    
    // Fallback: Direct key detection for special cases
  //  if (keyboard_check_pressed(vk_space)) {
        // Ensure space is captured even if keyboard_string fails
  //      if (string_char_at(current_input, cursor_pos + 1) != " ") {
   //         current_input = string_insert(" ", current_input, cursor_pos + 1);
   //         cursor_pos++;
   //     }
   // }
 }

/// @script basic_cmd_gosub
function basic_cmd_gosub(arg) {
    var raw = string_trim(arg);
    var colonPos = string_pos(":", raw);
    if (colonPos > 0) raw = string_trim(string_copy(raw, 1, colonPos - 1));
    var target = real(raw);

    // Ensure gosub stack exists
    if (!ds_exists(global.gosub_stack, ds_type_stack)) {
        global.gosub_stack = ds_stack_create();
    }

    // === CHANGE: capture statement-level resume point on this same line ===
    var resume_stmt = 0;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        resume_stmt = global.interpreter_current_stmt_index + 1;  // next stmt on this line
    }
    var frame = {
        kind: "stmt",                 // mark as statement-level resume
        line_index: line_index,       // current line index
        stmt_index: resume_stmt       // next statement to run on return
    };
    ds_stack_push(global.gosub_stack, frame);

    // Jump to target line
    global.interpreter_next_line = -1;
    var listSize = ds_list_size(global.line_list);
    for (var i = 0; i < listSize; i++) {
        if (ds_list_find_value(global.line_list, i) == target) {
            global.interpreter_next_line = i;
            break;
        }
    }
    if (global.interpreter_next_line == -1) {
        basic_syntax_error("GOSUB target line not found: " + string(target),
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_TARGET");
        return;
    }
}

/// scripts/get_save_directory/get_save_directory.gml
function get_save_directory()
{
   // Check for HTML5/browser first - return empty string to skip file operations
   if (os_browser != browser_not_a_browser) {
       return ""; // HTML5 - no file system access
   }
   
   var base = "";
   
   // Handle desktop OS types
   if (os_type == os_windows) {
       var user = environment_get_variable("USERPROFILE");
       if (is_string(user) && string_length(user) > 0) {
           base = user + "\\Documents\\BasicInterpreter\\";
       }
   }
   else if (os_type == os_macosx || os_type == os_linux) {
       var home = environment_get_variable("HOME");
       if (is_string(home) && string_length(home) > 0) {
           base = home + "/Documents/BasicInterpreter/";
       }
   }
   else if (os_type == os_android) {
       base = "/storage/emulated/0/Documents/BasicInterpreter/";
   }
   else {
       // Unknown desktop OS - fallback to working directory
       base = working_directory;
   }
   
   // If env var resolution failed, fall back to working_directory
   if (!is_string(base) || string_length(base) == 0) {
       base = working_directory;
   }
   
   // Ensure trailing slash
   var last = string_copy(base, string_length(base), 1);
   if (last != "/" && last != "\\") {
       if (os_type == os_windows) base += "\\";
       else base += "/";
   }
   
   return base;
}
function editor_html_dir_show() {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("html_dir_files") || ds_list_size(global.html_dir_files) == 0) {
        basic_show_message("No files selected. Use DIR to choose files first.");
        return false;
    }

    var ed = instance_find(obj_editor, 0);
    if (ed == noone) return false;

    // Initialize directory variables
    ed.dir_listing = [];
    ed.showing_dir_overlay = false;
    ed.dir_save_dir = "";

    // Build listing from html_dir_files
    var n = ds_list_size(global.html_dir_files);
    for (var i = 0; i < n; i++) {
        var rec = global.html_dir_files[| i];
        var filename = ds_map_find_value(rec, "name");
        array_push(ed.dir_listing, filename);
    }
    
    if (n == 0) {
        array_push(ed.dir_listing, "No .bas files found.");
    }

    // Initialize overlay state
    ed.dir_sel = 0;
    ed.dir_page = 0;
    ed.dir_page_size = 1;
    ed.dir_sorted_by = "name";
    ed.dir_filter = "";
    ed.dir_preview_on = false;
    ed.dir_confirm_active = false;
    ed.dir_confirm_index = -1;
    ed.dir_mouse_hover_row = -1;
    ed.dir_mouse_hover_action = "";

    // Show the overlay
    ed.showing_dir_overlay = true;
    return true;
}
// =================================================================
// LOCATE command - set cursor position for next PRINT
// =================================================================
function basic_cmd_locate(arg) {
    if (global.current_mode < 1) {
        // In text mode, just ignore or show message
        if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE: Not implemented in text mode");
        return;
    }
    
    var args = basic_parse_csv_args(arg);
    if (array_length(args) < 2) {
        if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE requires 2 arguments: row, col");
        return;
    }
    
    var row = real(basic_evaluate_expression_v2(string_trim(args[0])));
    var col = real(basic_evaluate_expression_v2(string_trim(args[1])));
    
    // BASIC typically uses 1-based coordinates, convert to 0-based
    row = max(0, min(24, row - 1));
    col = max(0, min(39, col - 1));
    
    // Store cursor position in globals for PRINT to use
    global.mode1_cursor_x = col;
    global.mode1_cursor_y = row;
    
    if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE: Set cursor to (" + string(col) + "," + string(row) + ")");
}
show_debug_message("SCREEN_EDITOR: Create start");

// Sizing (keep your existing numbers if different)
char_width  = 16;
char_height = 24;
margin_x    = 8;
margin_y    = 8;

// Dynamic screen size
screen_cols = floor((room_width  - (margin_x * 2)) / char_width);
screen_rows = floor((room_height - (margin_y * 2) - 40) / char_height);

show_debug_message("SCREEN_EDITOR: Calculated screen size - " + string(screen_cols) + "x" + string(screen_rows) +
                   " (room: " + string(room_width) + "x" + string(room_height) + ")");

// Backing char buffer (your renderer already expects this)
screen_buffer = array_create(screen_cols * screen_rows, ord(" "));

// Cursor & scroll
cursor_x = 0;
cursor_y = 0;
horizontal_offset = 0;
scroll_margin = 5;
scroll_offset = 0;

// Caret blink
blink_timer = 0;
cursor_visible = true;

// NEW: live text buffer for the current row in this view
current_input = "";

// Pull program into buffer for display
screen_editor_load_program(id);

keyboard_string = ""; // start clean

show_debug_message("SCREEN_EDITOR: Create complete - " + string(screen_cols) + "x" + string(screen_rows) + " buffer");

/// @func basic_cmd_restore(arg)
/// @desc RESTORE [@stream]    — reset the read pointer to the start of the stream.
///       No arg resets the default stream "".
function basic_cmd_restore(arg) {
    var s = strip_basic_remark(string_trim(arg));
    var stream_name = "";
    // Optional @name or bare name
    if (s != "") {
        if (string_char_at(s, 1) == "@") {
            stream_name = string_trim(string_copy(s, 2, string_length(s) - 1)); // drop '@'
        } else {
            stream_name = s; // bare stream name
        }
    }
	if (!ds_exists(global.data_streams, ds_type_map) || !ds_map_exists(global.data_streams, stream_name)) {
	    basic_syntax_error("RESTORE stream not found: " + stream_name, 
	        global.current_line_number, global.interpreter_current_stmt_index, "DATA_STREAM");
	    return;
	}
    var st = ds_map_find_value(global.data_streams, stream_name);
    st.ptr = 0;
    if (dbg_on(DBG_FLOW)) {
        var cnt = ds_list_size(st.list);
        if (dbg_on(DBG_FLOW)) show_debug_message("RESTORE: stream='" + stream_name + "' ptr=0 (size=" + string(cnt) + ")");
    }
}
/// help_restore_program()
function help_restore_program() {
    if (!variable_global_exists("help_snapshot_lines")) return;

    // wipe current
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // restore
    var key = ds_map_find_first(global.help_snapshot_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.help_snapshot_lines, key);
        ds_map_add(global.program_lines, key, val);
        key = ds_map_find_next(global.help_snapshot_lines, key);
    }
    for (var i = 0; i < ds_list_size(global.help_snapshot_nums); i++) {
        ds_list_add(global.line_numbers, ds_list_find_value(global.help_snapshot_nums, i));
    }

    // clean snapshot
    ds_map_destroy(global.help_snapshot_lines);
    ds_list_destroy(global.help_snapshot_nums);
    global.help_snapshot_lines = undefined;
    global.help_snapshot_nums  = undefined;
}


/// @script basic_error_hint
/// Return an array of short hint lines (<= 3) for a given key.
function basic_error_hint(key) {
    var lines = [];
    switch (string_upper(string(key))) {
        case "INKEY_MISUSE":
            lines[0] = "INKEY$ must assign to a var.";
            lines[1] = "Use:  K$ = INKEY$";
            lines[2] = "Then PRINT K$ if desired.";
            break;

        case "IF_MISSING_THEN":
            lines[0] = "Use: IF cond THEN stmt";
            lines[1] = "Or multi-line IF...ENDIF";
            lines[2] = "Example: IF X=1 THEN PRINT X";
            break;

        case "FOR_MISMATCH":
            lines[0] = "FOR must have matching NEXT.";
            lines[1] = "Example: FOR I=1 TO 10 : ... : NEXT";
            break;

        case "WHILE_MISMATCH":
            lines[0] = "WHILE must end with WEND.";
            break;

        default:
            lines[0] = ""; lines[1] = ""; lines[2] = "";
            break;
    }
    return lines;
}

/// @event obj_globals/Async - HTTP
// This event only triggers when an HTTP request completes
// async_load is automatically valid here

var req_id = ds_map_find_value(async_load, "id");
if (!variable_global_exists("http_tags")) exit;
if (!ds_map_exists(global.http_tags, req_id)) exit;

var tag  = ds_map_find_value(global.http_tags, req_id);
var stat = ds_map_find_value(async_load, "status"); // 0 = OK
var body = ds_map_find_value(async_load, "result");

// Clean up the tag immediately
ds_map_delete(global.http_tags, req_id);

if (tag == ":LOADURL") {
    if (stat == 0 && is_string(body)) {
        var n = editor_import_text_to_program(body);
        show_error_message("Imported " + string(n) + " line(s) from URL.");
    } else {
        var sc = ds_map_find_value(async_load, "http_status");
        show_error_message("LOADURL failed (status=" + string(sc) + ").");
    }
}
// =================================================================
// MODE 1 Enhanced CLS - clear screen and reset cursor
// =================================================================
/// @function basic_cmd_cls_mode1()
/// @description MODE 1 version of CLS that clears the grid and resets cursor
function basic_cmd_cls_mode1() {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (instance_exists(grid_obj)) {
        with (grid_obj) {
            mode1_grid_fill(32, c_white, c_black); // Clear with spaces
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: Grid cleared");
    }
    
    // Reset cursor to top-left
    global.mode1_cursor_x = 0;
    global.mode1_cursor_y = 0;
    
    if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: Cursor reset to (0,0)");
}
// SCRIPT: basic_stop_execution
function basic_stop_execution() {
    if (dbg_on(DBG_FLOW)) show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    if (dbg_on(DBG_FLOW)) show_debug_message("BASIC_STOP_EXECUTION CALLED!");
    if (dbg_on(DBG_FLOW)) show_debug_message("Call Stack:");
    if (dbg_on(DBG_FLOW)) show_debug_message(debug_get_callstack()); // THIS IS THE KEY!
    if (dbg_on(DBG_FLOW)) show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

    global.interpreter_running = false;
    global.awaiting_input = false;
    global.program_has_ended = true;

    // Clear input buffer if input was pending
    if (global.input_buffer != undefined && ds_list_exists(global.input_buffer, ds_type_list)) {
        ds_list_clear(global.input_buffer);
    }
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function process_input_line(input_text) {
    // Trim whitespace
    input_text = string_trim(input_text);
    
    if (input_text == "") return;
    
    // Check if line starts with a number
    var first_space = string_pos(" ", input_text);
    var potential_line_num = "";
    
    if (first_space > 0) {
        potential_line_num = string_copy(input_text, 1, first_space - 1);
    } else {
        potential_line_num = input_text;
    }
    
    // Check if it's a valid line number
    if (is_line_number(potential_line_num)) {
        handle_program_line(input_text);
    } else {
        handle_command(input_text);
    }
 }
function safe_real_pop(stack) {
    if (array_length(stack) < 1) return 1;

    var raw = array_pop(stack);

    // Pass through real values
    if (is_real(raw)) return raw;

    // Try to convert string safely
    var str = string(raw);
    var tryval = real(str);

    if (is_nan(tryval)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("? safe_real_pop: Cannot convert '" + string(raw) + "' to number. Returning 0.");
        return 0;
    }

    // Handle invalid conversions like real("RND:")
    if (!is_numeric_string(str)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("? POSTFIX ERROR: Cannot convert to number: '" + str + "'");
        return 1; // or return 0 if you prefer a neutral fallback
    }

    return tryval;
}

/// help_launch()
function help_launch() {
    // Always build the help topics to ensure they're current
    help_build_topics();
    
    // Save current program state
    help_snapshot_program();
    
    // Build the help browser program
    help_build_program();
    
    // Set help active flag
    global.help_active = true;
    
    // Initialize BASIC variables if they don't exist
    if (!variable_global_exists("basic_variables")) {
        global.basic_variables = ds_map_create();
    }
    
    // Set the help done flag to false initially
    global.basic_variables[? "HELP_DONE"] = 0;
    
    // Launch the interpreter with the help program
    run_program();
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function list_program() {
    display_start_line = 0;
    update_display();
 }
 function list_program_range(range) {
    // Parse range like "10-50" or single number "10"
    var dash_pos = string_pos("-", range);
    if (dash_pos > 0) {
        var start_line = real(string_copy(range, 1, dash_pos - 1));
        var end_line = real(string_copy(range, dash_pos + 1, string_length(range)));
        list_between_lines(start_line, end_line);
    } else {
        var single_line = real(range);
        list_single_line(single_line);
    }
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function navigate_history_up() {
	
	if (global.justreturned == 1) return; // 🛑 Block history on return
	
    if (ds_list_size(global.input_history) > 0) {
        if (global.history_index == -1) {
            global.history_index = ds_list_size(global.input_history) - 1;
        } else {
            global.history_index = max(0, global.history_index - 1);
        }
        current_input = ds_list_find_value(global.input_history, global.history_index);
        cursor_pos = string_length(current_input);
    }
 }
/// basic_normvar(name) -> canonical variable key
function basic_normvar(_name) {
    return string_upper(string_trim(string(_name)));
}

/// basic_looks_numeric(s) -> bool  (no regex; robust enough for BASIC)
function basic_looks_numeric(_s) {
    var s = string_trim(string(_s));
    if (s == "") return false;
    var digits = 0;
    for (var i = 1; i <= string_length(s); i++) {
        var c = ord(string_char_at(s, i));
        if ((c >= 48 && c <= 57)) digits++;                     // 0..9
        else if (c == 46 || c == 45) { /* '.' or leading '-' */ }
        else return false;
    }
    return digits > 0;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function insert_line_number_ordered(new_line_num) {
    var size = ds_list_size(global.line_numbers);
    var inserted = false;
    
    for (var i = 0; i < size; i++) {
        if (ds_list_find_value(global.line_numbers, i) > new_line_num) {
            ds_list_insert(global.line_numbers, i, new_line_num);
            inserted = true;
            break;
      }
    }
    
    if (!inserted) {
        ds_list_add(global.line_numbers, new_line_num);
    }
 }
/// Remove single quote comments, unless inside double quotes
function strip_basic_remark(arg) {
    var len = string_length(arg);
    var inside_string = false;

    for (var i = 1; i <= len; i++) {
        var c = string_char_at(arg, i);

        if (c == "\"") {
            inside_string = !inside_string;
        }
        else if (c == "'" && !inside_string) {
            // Found unquoted remark start – strip everything after
            return string_trim(string_copy(arg, 1, i - 1));
        }
    }

    // No unquoted remark found – return original
    return arg;
}

function basic_cmd_cls() {
    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Called");
    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Current color before clear: " + string(global.current_draw_color));

    ds_list_clear(global.output_lines);
    ds_list_clear(global.output_colors);

    global.current_draw_color = global.basic_text_color;

    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Screen cleared");
    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Current color reset to default: " + string(global.current_draw_color));
}

// FILE: scripts/mode1_grid_clear.gml
// FUNCTION: mode1_grid_clear(char_index)
// CHANGE: Remove 15x18 constants; iterate over actual grid

/// @param char_index
function mode1_grid_clear(char_index) {
    var cols = grid_cols;
    var rows = grid_rows;

    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var i = row * cols + col;
            grid[i].char = char_index;
            grid[i].fg = c_white;
            grid[i].bg = c_black;
        }
    }
}

/// === BASIC_fn_INKEY$ : dequeue 1 char for INKEY$ ===
/// Returns "" if queue empty. Safe to call from evaluator/command handler.
function BASIC_fn_INKEY() {
    if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
        global.inkey_queue = ds_queue_create();
    }
    if (ds_queue_size(global.inkey_queue) > 0) {
        var _ch = ds_queue_dequeue(global.inkey_queue);
        if (is_real(_ch)) _ch = chr(_ch);
        return string(_ch);
    }
    return "";
}
/// @function mode1_get_color(col, row)
/// @description Get foreground color at grid position  
function mode1_get_color(col, row) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return c_white;
    
    var cols = 40;
    var rows = 25;
    
    if (col < 0 || col >= cols || row < 0 || row >= rows) {
        return c_white; // Return white for out of bounds
    }
    
    var i = col + row * cols;
    return grid_obj.grid[i].fg;
}
function screen_editor_exit(editor_inst) {
    with (editor_inst) {
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Exiting screen editor");
        global.screen_edit_mode = false;
        
        // CRITICAL: Clear keyboard_string to prevent leakage to obj_editor
        keyboard_string = "";
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cleared keyboard_string");
        
        instance_destroy();
    }
}
function dbg(cat, msg) {
    // Off fast-path
    if ((global.debug_mask & cat) == 0) return;

    // Per-frame quota (avoid tanking fps)
    if (global.dbg_frame_count >= global.dbg_frame_quota) {
        global.dbg_dropped_count++;
        return;
    }
    global.dbg_frame_count++;

    // ✅ Print unconditionally now that the category is enabled
   if (dbg_on(DBG_FLOW)) show_debug_message(msg);
}

function basic_cmd_pause() {
    if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: Execution paused. Waiting for user to press ENTER...");

	global.pause_in_effect = true;
    global.awaiting_input = true;
    global.input_target_var = ""; // No variable to store
    global.pause_mode = true;     // Optional flag if you want to treat it differently in draw
	global.input_expected = false;

}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function toggle_syntax_highlighting() {
    syntax_highlighting = !syntax_highlighting;
    basic_show_message("SYNTAX HIGHLIGHTING: " + (syntax_highlighting ? "ON" : "OFF"));
    update_display();
 }

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function new_program_without_undo() {
    ds_map_clear(global.program_lines);
    ds_list_clear(global.line_numbers);
    current_filename = "";
    display_start_line = 0;
 }

/// @param char_index
/// @param fg_color
/// @param bg_color
function mode1_grid_fill(char_index, fg_color, bg_color) {
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char_index;
        grid[i].fg = fg_color;
        grid[i].bg = bg_color;
    }
}

function resolve_basic_value(key) {
    var k = basic_normvar(key); // normalize before lookup
    return ds_map_exists(global.basic_variables, k)
        ? global.basic_variables[? k]
        : real(key);             // keep your original fallback
}

/// scripts/gm_receive_paste.gml
function gm_receive_paste(_text) {
    global.import_text  = is_string(_text) ? _text : "";
    global.import_ready = (global.import_text != "");
    show_error_message("Import received."); // visible confirmation
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function update_display() {
    // This will be called in the Draw event
 }
 
function is_quoted_string(str) {
    return (string_length(str) >= 2 &&
            string_char_at(str, 1) == "\"" &&
            string_char_at(str, string_length(str)) == "\"");
}

/// @event obj_mode1_grid/Step
// You can write your code in this editor
// No active logic yet, but this is where future interactions (like SCROLL or POKE) will go.

/// @event obj_basic_interpreter/Destroy
// You can write your code in this editor
ds_list_destroy(interpreter_current_program);
function dbg_on(cat) {
    return (global.debug_mask & cat) != 0;
}


function is_right_associative(op) {
    return (op == "^");
}
