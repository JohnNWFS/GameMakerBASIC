/// help_build_program() - CORRECTED VERSION
function help_build_program() {
    // clear current program and line numbers
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // Work out how many topics we're going to list
    var topic_count = ds_list_size(global.help_topics);

    // Seed the runtime variable store
    if (!is_undefined(global.basic_variables)) {
        global.basic_variables[? "TOPIC_COUNT"] = topic_count;
    }

    var add = function(n, s) {
        ds_map_add(global.program_lines, n, s);
        ds_list_add(global.line_numbers, n);
    };

    // ==== BASIC "HELP BROWSER" PROGRAM ====
add(10,"REM NW-BASIC HELP SYSTEM - Clean Version (ASCII-safe)");
add(15,"HDR$ = \"\"             : REM avoid undefined var on first header call");
add(20,"CLS: COLOR YELLOW: HDR$=\"NW-BASIC HELP\": GOSUB 7000");
add(30,"PRINT \"Select a topic by number. 0 returns to editor.\"");
add(35,"REM -- Arrays must exist BEFORE we READ into them");
add(36,"DIM TOPIC$(32), TOPIC_START(32), TOPIC_LEN(32)");
add(37,"DIM SUB$(128), SUBTOPIC_OF(128), SUB_START(128), SUB_LEN(128)");
add(38,"DIM IDX(32)");
add(40,"GOSUB 9500   : REM Load data");
add(50,"REM --- MAIN MENU LOOP ---");
add(60,"CLS: HDR$=\"TOPICS - Select a topic (0=Exit)\": GOSUB 7000");
add(65,"PRINT");
add(70,"FOR I=1 TO TOPIC_COUNT: PRINT I; \") \"; TOPIC$(I): NEXT");
add(80,"PRINT");
add(90,"INPUT \"Topic (0=Exit): \", T");
add(100,"IF T=0 THEN END");
add(110,"IF T<1 OR T>TOPIC_COUNT THEN PRINT \"Invalid.\": GOTO 80");
add(120,"REM --- SUBTOPIC MENU LOOP ---");
add(130,"CLS: HDR$=\"TOPIC: \" + TOPIC$(T) + \"  (0=Back)\": GOSUB 7000");
add(140,"C=0");
add(150,"FOR I=1 TO SUB_COUNT");
add(160,"  IF SUBTOPIC_OF(I)=T THEN C=C+1: PRINT C; \") \"; SUB$(I): IDX(C)=I");
add(170,"NEXT");
add(180,"IF C=0 THEN PRINT \"(No subtopics)\": INPUT \"[ENTER]\", X$: GOTO 50");
add(190,"PRINT");
add(200,"INPUT \"Subtopic (0=Back): \",K");
add(210,"IF K=0 THEN GOTO 50");
add(220,"IF K<1 OR K>C THEN GOTO 190");
add(230,"REM --- SHOW CONTENT ---");
add(240,"I = IDX(K): S = SUB_START(I): N = SUB_LEN(I)");
add(250,"GOSUB 8000");
add(260,"GOTO 120");
add(6999,"REM ---- helpers ----");
add(7000,"REM Print a decorated header (no LEN, no REPEAT$)");
add(7005,"D$=\"\": FOR J=1 TO 40: D$=D$ + \"-\": NEXT");
add(7010,"PRINT D$");
add(7015,"IF HDR$ <> \"\" THEN PRINT HDR$");
add(7020,"PRINT D$");
add(7030,"RETURN");
add(8000,"REM --- CONTENT DISPLAY: seek once to first page, then stream N pages ---");
add(8010,"REM We want pages S..S+N-1. Land on page S once, then read forward.");
add(8030,"RESTORE");
add(8040,"READ TC, SC, PC");
add(8050,"FOR SKT = 1 TO TC: READ TMP$, TMP1, TMP2: NEXT SKT");
add(8060,"FOR SKS = 1 TO SC: READ TMP2$, TMP3, TMP4, TMP5: NEXT SKS");
add(8080,"FOR SK = 1 TO S - 1");
add(8090,"  READ L: FOR R = 1 TO L: READ D$: NEXT R");
add(8100,"NEXT SK");
add(8120,"FOR PP = 1 TO N");
add(8130,"  CLS");
add(8140,"  PRINT \"HELP: \"; SUB$(I)");
add(8150,"  HDR$ = \"TOPIC: \" + TOPIC$( SUBTOPIC_OF(I) ) + \"  (0=Back)\": GOSUB 7000");
add(8160,"  PRINT \"Page \"; PP; \" of \"; N");
add(8170,"  PRINT");
add(8180,"  READ L");
add(8190,"  FOR R = 1 TO L");
add(8200,"    READ D$: PRINT D$");
add(8210,"  NEXT R");
add(8220,"  PRINT");
add(8230,"  INPUT \"[ENTER=Next/Back]\", X$");
add(8240,"NEXT PP");
add(8250,"RETURN");
add(9500,"REM -- Load all data --");
add(9510,"RESTORE");
add(9520,"READ TOPIC_COUNT, SUB_COUNT, PAGE_COUNT");
add(9530,"FOR I=1 TO TOPIC_COUNT: READ TOPIC$(I), TOPIC_START(I), TOPIC_LEN(I): NEXT");
add(9550,"FOR I=1 TO SUB_COUNT: READ SUB$(I), SUBTOPIC_OF(I), SUB_START(I), SUB_LEN(I): NEXT");
add(9560,"RETURN");
add(9900,"DATA 9, 27, 38");
add(9910,"REM Topic data: name, start_page, length");
add(9920,"DATA \"Program Structure\", 1, 2");
add(9921,"DATA \"Variables & Data Types\", 3, 3");
add(9922,"DATA \"Input/Output\", 6, 4");
add(9923,"DATA \"Program Control\", 10, 5");
add(9924,"DATA \"MODE / Graphics\", 15, 5");
add(9925,"DATA \"Math & Random\", 20, 4");
add(9926,"DATA \"Strings\", 24, 3");
add(9927,"DATA \"Data & Arrays\", 27, 5");
add(9928,"DATA \"Editor & Files\", 32, 7");
add(9930,"REM Subtopic data: name, parent_topic, start_page, length");
add(9931,"DATA \"Line Numbers\", 1, 1, 1");
add(9932,"DATA \"Multiple Statements\", 1, 2, 1");
add(9933,"DATA \"LET & Types\", 2, 3, 1");
add(9934,"DATA \"Arrays (DIM)\", 2, 4, 2");
add(9935,"DATA \"PRINT\", 3, 6, 2");
add(9936,"DATA \"INPUT\", 3, 8, 1");
add(9937,"DATA \"CLS/Color\", 3, 9, 1");
add(9938,"DATA \"IF / ELSE / ENDIF\", 4, 10, 2");
add(9939,"DATA \"FOR/NEXT\", 4, 12, 1");
add(9940,"DATA \"WHILE/WEND\", 4, 13, 1");
add(9941,"DATA \"GOTO/GOSUB/RETURN\", 4, 14, 1");
add(9942,"DATA \"MODE 1 & Fonts\", 5, 15, 2");
add(9943,"DATA \"PRINTAT/CHARAT\", 5, 17, 2");
add(9944,"DATA \"CLSCHAR/SCROLL\", 5, 19, 1");
add(9945,"DATA \"Math & Trig\", 6, 20, 2");
add(9946,"DATA \"RND\", 6, 22, 1");
add(9947,"DATA \"Operators\", 6, 23, 1");
add(9948,"DATA \"Substring & Len\", 7, 24, 1");
add(9949,"DATA \"CHR$/ASC\", 7, 25, 1");
add(9950,"DATA \"Concatenation\", 7, 26, 1");
add(9951,"DATA \"DATA/READ/RESTORE\", 8, 27, 2");
add(9952,"DATA \"Named Streams\", 8, 29, 1");
add(9953,"DATA \"Arrays\", 8, 30, 2");
add(9954,"DATA \"Editor Commands\", 9, 32, 3");
add(9955,"DATA \"DIR Overlay\", 9, 35, 1");
add(9956,"DATA \"SAVE/LOAD\", 9, 36, 1");
add(9957,"DATA \"Shortcuts\", 9, 37, 2");
add(10000,"REM === Page 1: Program Structure / Line Numbers ===");
add(10010,"DATA 9");
add(10011,"DATA \"PROGRAM STRUCTURE\"");
add(10012,"DATA \"What: Programs are a list of numbered lines.\"");
add(10013,"DATA \"Syntax: 10 STATEMENT  : 20 STATEMENT\"");
add(10014,"DATA \"Type: 10 PRINT \"\"Hello\"\"  : 20 END\"");
add(10015,"DATA \"Gotchas: Use gaps 10,20,30 so you can insert.\"");
add(10016,"DATA \"Gotchas: A repeated number overwrites that line.\"");
add(10017,"DATA \"See also: Multiple Statements, GOTO, GOSUB\"");
add(10018,"DATA \"SCREENEDIT or SE = full screen editor\"");
add(10019,"DATA \"Use REM or ' to start a comment to end of line\"");
add(10020,"REM === Page 2: Program Structure / Multiple Statements ===");
add(10030,"DATA 7");
add(10031,"DATA \"PROGRAM STRUCTURE\"");
add(10032,"DATA \"What: Put several statements on one line.\"");
add(10033,"DATA \"Syntax: STAT : STAT : STAT\"");
add(10034,"DATA \"Type: 10 A=1: B=2: PRINT A+B\"");
add(10035,"DATA \"Gotchas: Keep lines short for readability.\"");
add(10036,"DATA \"See also: LET & Types, IF, FOR/NEXT\"");
add(10037,"DATA \"\"");
add(10040,"REM === Page 3: Variables & Data Types / LET & Types ===");
add(10050,"DATA 9");
add(10051,"DATA \"VARIABLES & TYPES\"");
add(10052,"DATA \"What: Store numbers or text in named variables.\"");
add(10053,"DATA \"Syntax: A=5  or  LET A=5  ;  N$=\"\"Name\"\"\"");
add(10054,"DATA \"Type: A=3: B=4: PRINT A+B   :  N$=\"\"Joe\"\"\"");
add(10055,"DATA \"Type: PRINT \"\"Hello, \"\" + N$\"");
add(10056,"DATA \"Gotchas: Names ending in $ are strings only.\"");
add(10057,"DATA \"Gotchas: Others are numeric; default is 0.\"");
add(10058,"DATA \"See also: Strings, PRINT\"");
add(10059,"DATA \"\"");
add(10060,"REM === Page 4: Variables & Data Types / Arrays (DIM) p1 ===");
add(10070,"DATA 9");
add(10071,"DATA \"ARRAYS (DIM) - Part 1\"");
add(10072,"DATA \"What: Store many values under one name.\"");
add(10073,"DATA \"Syntax: DIM A(10)  ;  DIM N$(5)\"");
add(10074,"DATA \"Type: DIM A(3): A(1)=10: A(2)=20: PRINT A(1)+A(2)\"");
add(10075,"DATA \"Type: DIM N$(2): N$(1)=\"\"OK\"\": PRINT N$(1)\"");
add(10076,"DATA \"Gotchas: Indexing is 1-based in this build.\"");
add(10077,"DATA \"Gotchas: Out of range gives 0 or empty string.\"");
add(10078,"DATA \"See also: Arrays p2, Data & Arrays\"");
add(10079,"DATA \"\"");
add(10080,"REM === Page 5: Variables & Data Types / Arrays (DIM) p2 ===");
add(10090,"DATA 8");
add(10091,"DATA \"ARRAYS (DIM) - Part 2\"");
add(10092,"DATA \"What: Use expressions for the index.\"");
add(10093,"DATA \"Type: I=3: DIM A(5): A(I-1)=7: PRINT A(2)\"");
add(10094,"DATA \"Type: DIM N$(3): N$(1)=\"\"A\"\": PRINT N$(1)\"");
add(10095,"DATA \"Gotchas: Arrays and scalars are distinct names.\"");
add(10096,"DATA \"Gotchas: Re-DIM by defining before use.\"");
add(10097,"DATA \"See also: Substring & LEN, Data & Arrays\"");
add(10098,"DATA \"\"");
add(10100,"REM === Page 6: Input/Output / PRINT p1 ===");
add(10110,"DATA 9");
add(10111,"DATA \"PRINT - Part 1\"");
add(10112,"DATA \"What: Show text or values on the screen.\"");
add(10113,"DATA \"Syntax: PRINT expr   ;   PRINT A;B   ;   PRINT A,B\"");
add(10114,"DATA \"Type: PRINT \"\"Hello\"\"   :   PRINT 1,2,3\"");
add(10115,"DATA \"Type: A=3: B=4: PRINT \"\"Sum=\"\";A+B\"");
add(10116,"DATA \"Output: 1       2       3\"");
add(10117,"DATA \"Gotchas: A trailing ; keeps the cursor on the line.\"");
add(10118,"DATA \"See also: PRINT p2, INPUT\"");
add(10119,"DATA \"\"");
add(10120,"REM === Page 7: Input/Output / PRINT p2 ===");
add(10130,"DATA 8");
add(10131,"DATA \"PRINT - Part 2\"");
add(10132,"DATA \"What: Format with strings for labels.\"");
add(10133,"DATA \"Type: PRINT \"\"A=\"\"+STR$(5)\"");
add(10134,"DATA \"Type: PRINT \"\"First\"\";: PRINT \"\" line\"\"\"");
add(10135,"DATA \"Gotchas: , uses tab columns; ; no spacing.\"");
add(10136,"DATA \"Gotchas: Use CHR$(13)+CHR$(10) for custom breaks.\"");
add(10137,"DATA \"See also: Strings, CHR$/ASC\"");
add(10138,"DATA \"\"");
add(10140,"REM === Page 8: Input/Output / INPUT ===");
add(10150,"DATA 8");
add(10151,"DATA \"INPUT\"");
add(10152,"DATA \"What: Ask the user for a number or text.\"");
add(10153,"DATA \"Syntax: INPUT \"\"Prompt: \"\", X   or   INPUT \"\"Name: \"\", N$\"");
add(10154,"DATA \"Type: INPUT \"\"Name: \"\", N$: PRINT \"\"Hello, \"\";N$\"");
add(10155,"DATA \"INKEY$ returns one key from the queue; \"\"\"\" if none\"");
add(10156,"DATA \"Gotchas: Use $ names for text; others are numeric.\"");
add(10157,"DATA \"Gotchas: Entering nothing keeps current value.\"");
add(10158,"DATA \"See also: PRINT, IF, Shortcuts\"");
add(10160,"REM === Page 9: Input/Output / CLS & Color ===");
add(10170,"DATA 8");
add(10171,"DATA \"CLS & COLOR\"");
add(10172,"DATA \"What: Clear the screen and set text color.\"");
add(10173,"DATA \"Syntax: CLS    ;   COLOR YELLOW\"");
add(10174,"DATA \"Type: CLS: COLOR YELLOW: PRINT \"\"Ready\"\"\"");
add(10175,"DATA \"Gotchas: Use a small set of named colors.\"");
add(10176,"DATA \"Gotchas: Clear before drawing a new view.\"");
add(10177,"DATA \"See also: MODE 1, PRINTAT\"");
add(10178,"DATA \"\"");
add(10180,"REM === Page 10: Program Control / IF-ELSE-ENDIF p1 ===");
add(10190,"DATA 9");
add(10191,"DATA \"IF / ELSE / ENDIF - Part 1\"");
add(10192,"DATA \"What: Run code only when a test is true.\"");
add(10193,"DATA \"Syntax:\"");
add(10194,"DATA \"IF A>0 THEN\"");
add(10195,"DATA \"  PRINT \"\"POSITIVE\"\"\"");
add(10196,"DATA \"ELSE\"");
add(10197,"DATA \"  PRINT \"\"NON-POSITIVE\"\"\"");
add(10198,"DATA \"ENDIF\"");
add(10199,"DATA \"\"");
add(10200,"REM === Page 11: Program Control / IF-ELSE-ENDIF p2 ===");
add(10210,"DATA 7");
add(10211,"DATA \"IF / ELSE / ENDIF - Part 2\"");
add(10212,"DATA \"What: Single-line IF for short actions.\"");
add(10213,"DATA \"Type: IF A=0 THEN PRINT \"\"ZERO\"\"\"");
add(10214,"DATA \"Gotchas: Use parentheses to group tests.\"");
add(10215,"DATA \"Gotchas: Strings compare with = and <>.\"");
add(10216,"DATA \"See also: FOR/NEXT, WHILE/WEND\"");
add(10217,"DATA \"\"");
add(10220,"REM === Page 12: Program Control / FOR-NEXT ===");
add(10230,"DATA 8");
add(10231,"DATA \"FOR / NEXT\"");
add(10232,"DATA \"What: Repeat a block a set number of times.\"");
add(10233,"DATA \"Syntax: FOR I=start TO end [STEP s] ... NEXT\"");
add(10234,"DATA \"Type: FOR I=1 TO 5: PRINT I: NEXT\"");
add(10235,"DATA \"Type: FOR T=10 TO 0 STEP -2: PRINT T: NEXT\"");
add(10236,"DATA \"Gotchas: Do not change I inside the loop.\"");
add(10237,"DATA \"See also: WHILE/WEND, IF\"");
add(10238,"DATA \"\"");
add(10240,"REM === Page 13: Program Control / WHILE-WEND ===");
add(10250,"DATA 6");
add(10251,"DATA \"WHILE / WEND\"");
add(10252,"DATA \"What: Repeat while a condition is true.\"");
add(10253,"DATA \"Syntax: WHILE cond: ... : WEND\"");
add(10254,"DATA \"Type: A=3: WHILE A>0: PRINT A: A=A-1: WEND\"");
add(10255,"DATA \"Gotchas: Ensure progress to avoid an infinite loop.\"");
add(10256,"DATA \"\"");
add(10260,"REM === Page 14: Program Control / GOTO-GOSUB-RETURN ===");
add(10270,"DATA 8");
add(10271,"DATA \"GOTO / GOSUB / RETURN\"");
add(10272,"DATA \"What: Jump or call a subroutine by line number.\"");
add(10273,"DATA \"Type: 100 GOSUB 900 : PRINT \"\"Back\"\" : END\"");
add(10274,"DATA \"Type: 900 PRINT \"\"Hi\"\": RETURN\"");
add(10275,"DATA \"Gotchas: RETURN goes to the line after GOSUB.\"");
add(10276,"DATA \"Gotchas: Use small helpers; avoid deep nesting.\"");
add(10277,"DATA \"See also: Line Numbers, IF\"");
add(10278,"DATA \"\"");
add(10280,"REM === Page 15: MODE / Graphics / MODE1 & Fonts p1 ===");
add(10290,"DATA 8");
add(10291,"DATA \"MODE 1 & FONTS - Part 1\"");
add(10292,"DATA \"What: Character grid display with sprite fonts.\"");
add(10293,"DATA \"Syntax: FONT \"\"DEFAULT_16\"\"\"");
add(10294,"DATA \"Type: FONT \"\"DEFAULT_16\"\": PRINT \"\"Hello\"\"\"");
add(10295,"DATA \"Gotchas: Tile size sets columns and rows.\"");
add(10296,"DATA \"Gotchas: Keep a consistent font for readability.\"");
add(10297,"DATA \"See also: PRINTAT/CHARAT\"");
add(10298,"DATA \"\"");
add(10300,"REM === Page 16: MODE / Graphics / MODE1 & Fonts p2 ===");
add(10310,"DATA 7");
add(10311,"DATA \"MODE 1 & FONTS - Part 2\"");
add(10312,"DATA \"What: Pick a tile size for your layout.\"");
add(10313,"DATA \"Guide: 16x16 is readable; 8x8 fits more text.\"");
add(10314,"DATA \"Tip: Test on your target window size.\"");
add(10315,"DATA \"Tip: Use headers and spacing to reduce clutter.\"");
add(10316,"DATA \"See also: PRINTAT/CHARAT, CLSCHAR/SCROLL\"");
add(10317,"DATA \"\"");
add(10320,"REM === Page 17: MODE / Graphics / PRINTAT-CHARAT p1 ===");
add(10330,"DATA 8");
add(10331,"DATA \"PRINTAT / CHARAT - Part 1\"");
add(10332,"DATA \"What: Draw at a grid position.\"");
add(10333,"DATA \"Syntax: PRINTAT x,y,\"\"Text\"\"\"");
add(10334,"DATA \"Syntax: CHARAT x,y,code[,fg[,bg]]\"");
add(10335,"DATA \"Type: PRINTAT 1,1,\"\"TOP\"\"\"");
add(10336,"DATA \"Type: CHARAT 10,5,45  ' draw '-'\"");
add(10337,"DATA \"See also: MODE 1, CLSCHAR/SCROLL\"");
add(10338,"DATA \"\"");
add(10340,"REM === Page 18: MODE / Graphics / PRINTAT-CHARAT p2 ===");
add(10350,"DATA 7");
add(10351,"DATA \"PRINTAT / CHARAT - Part 2\"");
add(10352,"DATA \"Tip: To center: start=(cols-LEN)/2 (manual).\"");
add(10353,"DATA \"Tip: Redraw only the parts that change.\"");
add(10354,"DATA \"Tip: Keep a cursor state if you blink text.\"");
add(10355,"DATA \"Tip: Use constants for colors and codes.\"");
add(10356,"DATA \"See also: MODE 1, DIR Overlay\"");
add(10357,"DATA \"\"");
add(10360,"REM === Page 19: MODE / Graphics / CLSCHAR-SCROLL ===");
add(10370,"DATA 7");
add(10371,"DATA \"CLSCHAR / SCROLL\"");
add(10372,"DATA \"What: Fill the screen or move text rows.\"");
add(10373,"DATA \"Syntax: CLSCHAR code[,fg[,bg]]\"");
add(10374,"DATA \"Syntax: SCROLL dir[,rows]\"");
add(10375,"DATA \"Tip: Use SCROLL for pager effects.\"");
add(10376,"DATA \"See also: PRINTAT, Page Reader\"");
add(10377,"DATA \"\"");
add(10380,"REM === Page 20: Math & Random / Math & Trig p1 ===");
add(10390,"DATA 8");
add(10391,"DATA \"MATH & TRIG - Part 1\"");
add(10392,"DATA \"What: Common numeric functions.\"");
add(10393,"DATA \"Funcs: ABS, INT, SGN, EXP, LOG\"");
add(10394,"DATA \"Funcs: SIN, COS, TAN   (radians)\"");
add(10395,"DATA \"Type: PRINT ABS(-3), INT(3.9)\"");
add(10396,"DATA \"Tip: Use parentheses for clarity.\"");
add(10397,"DATA \"See also: Operators, RND\"");
add(10398,"DATA \"\"");
add(10400,"REM === Page 21: Math & Random / Math & Trig p2 ===");
add(10410,"DATA 7");
add(10411,"DATA \"MATH & TRIG - Part 2\"");
add(10412,"DATA \"What: More math helpers and tips.\"");
add(10413,"DATA \"Type: PRINT SGN(-5), EXP(1)\"");
add(10414,"DATA \"Tip: Compare floats with a small tolerance.\"");
add(10415,"DATA \"Tip: Use MOD for wrap-around indices.\"");
add(10416,"DATA \"See also: RND, Operators\"");
add(10417,"DATA \"\"");
add(10420,"REM === Page 22: Math & Random / RND ===");
add(10430,"DATA 7");
add(10431,"DATA \"RND\"");
add(10432,"DATA \"What: Random number generator.\"");
add(10433,"DATA \"Type: PRINT RND()         ' 0.0..1.0\"");
add(10434,"DATA \"Type: PRINT RND(6)       ' 1..6\"");
add(10435,"DATA \"Type: PRINT RND(2,5)     ' 2..5\"");
add(10436,"DATA \"See also: Math & Trig, Operators\"");
add(10437,"DATA \"\"");
add(10440,"REM === Page 23: Math & Random / Operators ===");
add(10450,"DATA 7");
add(10451,"DATA \"OPERATORS\"");
add(10452,"DATA \"What: + - * /  \\  MOD  ^  and comparisons.\"");
add(10453,"DATA \"Type: PRINT 3+4*2, 7 MOD 5, 5^2\"");
add(10454,"DATA \"Tip: '\\' is integer divide; trunc toward zero.\"");
add(10455,"DATA \"Tip: Use parentheses to control order.\"");
add(10456,"DATA \"See also: Math & Trig\"");
add(10457,"DATA \"\"");
add(10460,"REM === Page 24: Strings / Substring & LEN ===");
add(10470,"DATA 8");
add(10471,"DATA \"STRINGS - Substrings\"");
add(10472,"DATA \"What: Slice parts of a string.\"");
add(10473,"DATA \"Syntax: LEFT$(S$,N), RIGHT$(S$,N), MID$(S$,s,l)\"");
add(10474,"DATA \"Type: S$=\"\"HELLO\"\": PRINT LEFT$(S$,2)   ' HE\"");
add(10475,"DATA \"Type: PRINT MID$(S$,2,3)               ' ELL\"");
add(10476,"DATA \"Note: LEN is not provided in this build.\"");
add(10477,"DATA \"See also: CHR$/ASC, Concatenation, REPEAT$\"");
add(10478,"DATA \"\"");
add(10480,"REM === Page 25: Strings / CHR$ & ASC ===");
add(10490,"DATA 7");
add(10491,"DATA \"STRINGS - CHR$ & ASC\"");
add(10492,"DATA \"What: Convert between codes and characters.\"");
add(10493,"DATA \"Type: PRINT CHR$(65)      ' A\"");
add(10494,"DATA \"Type: PRINT ASC(\"\"A\"\")     ' 65\"");
add(10495,"DATA \"Tip: Useful for line chars or input parsing.\"");
add(10496,"DATA \"See also: Substrings, Concatenation\"");
add(10497,"DATA \"\"");
add(10500,"REM === Page 26: Strings / Concatenation ===");
add(10510,"DATA 8");
add(10511,"DATA \"STRINGS - Concatenation, semicolon or +\"");
add(10512,"DATA \"What: Join strings with +.\"");
add(10513,"DATA \"Type: NAME$=\"\"Ada\"\": PRINT \"\"Hi, \"\"+NAME$\"");
add(10514,"DATA \"Type: PRINT \"\"A=\"\" + STR$(3)\"");
add(10515,"DATA \"Type: PRINT REPEAT$(\"\"-\"\",5) ' -----\"");
add(10516,"DATA \"Semicolon = no line feed after string\"");
add(10517,"DATA \"Tip: Build long lines piece by piece.\"");
add(10518,"DATA \"See also: PRINT, Substrings, REPEAT$\"");
add(10520,"REM === Page 27: Data & Arrays / DATA-READ-RESTORE p1 ===");
add(10530,"DATA 8");
add(10531,"DATA \"DATA / READ / RESTORE - Part 1\"");
add(10532,"DATA \"What: Store constants in the code and read them.\"");
add(10533,"DATA \"Syntax: DATA ...  ;  READ A,B$  ;  RESTORE\"");
add(10534,"DATA \"Type: RESTORE: READ N$,X: PRINT N$,X\"");
add(10535,"DATA \"Type: DATA \"\"OK\"\", 42\"");
add(10536,"DATA \"Tip: Keep tables grouped at the end.\"");
add(10537,"DATA \"See also: Named Streams, Arrays\"");
add(10538,"DATA \"\"");
add(10540,"REM === Page 28: Data & Arrays / DATA-READ-RESTORE p2 ===");
add(10550,"DATA 8");
add(10551,"DATA \"DATA / READ / RESTORE - Part 2\"");
add(10552,"DATA \"What: Seek by rewinding then skipping blocks.\"");
add(10553,"DATA \"Step 1: RESTORE\"");
add(10554,"DATA \"Step 2: READ past headers and tables\"");
add(10555,"DATA \"Step 3: Skip pages by count to your target\"");
add(10556,"DATA \"This help program uses that exact pattern.\"");
add(10557,"DATA \"See also: Page Reader code path\"");
add(10558,"DATA \"\"");
add(10560,"REM === Page 29: Data & Arrays / Named Streams ===");
add(10570,"DATA 7");
add(10571,"DATA \"NAMED DATA STREAMS\"");
add(10572,"DATA \"What: Keep multiple logical DATA streams.\"");
add(10573,"DATA \"Syntax: RESTORE but no line #;   READ ...\"");
add(10574,"DATA \"\"");
add(10575,"DATA \"Use: Separate content tables by purpose.\"");
add(10576,"DATA \"See also: DATA/READ/RESTORE\"");
add(10577,"DATA \"\"");
add(10580,"REM === Page 30: Data & Arrays / Arrays topic p1 ===");
add(10590,"DATA 7");
add(10591,"DATA \"ARRAYS - Topic (Part 1)\"");
add(10592,"DATA \"What: Use arrays for menus and listings.\"");
add(10593,"DATA \"Type: DIM IDX(32): IDX(1)=7: PRINT IDX(1)\"");
add(10594,"DATA \"Tip: 1-based loops pair well with arrays.\"");
add(10595,"DATA \"Tip: Always check user input bounds.\"");
add(10596,"DATA \"See also: Arrays p2, INPUT\"");
add(10597,"DATA \"\"");
add(10600,"REM === Page 31: Data & Arrays / Arrays topic p2 ===");
add(10610,"DATA 7");
add(10611,"DATA \"ARRAYS - Topic (Part 2)\"");
add(10612,"DATA \"What: Store records in parallel arrays.\"");
add(10613,"DATA \"Type: DIM A(3),B$(3): A(1)=10: B$(1)=\"\"OK\"\"\"");
add(10614,"DATA \"\"");
add(10615,"DATA \"\"");
add(10616,"DATA \"See also: Data & Arrays\"");
add(10617,"DATA \"\"");
add(10620,"REM === Page 32: Editor & Files / Editor Commands p1 ===");
add(10630,"DATA 8");
add(10631,"DATA \"EDITOR COMMANDS - Part 1\"");
add(10632,"DATA \"What: Basic editor actions.\"");
add(10633,"DATA \"Type: LIST   : RUN   : NEW   : SAVE \"\"NAME\"\"\"");
add(10634,"DATA \"Use: COPY then :PASTE to move blocks of code\"");
add(10635,"DATA \"Use: DIR overlay to pick files\"");
add(10636,"DATA \"Tip: Keep frequent saves and backups.\"");
add(10637,"DATA \"See also: Shortcuts, DIR Overlay\"");
add(10638,"DATA \"\"");
add(10640,"REM === Page 33: Editor & Files / Editor Commands p2 ===");
add(10650,"DATA 7");
add(10651,"DATA \"EDITOR COMMANDS - Part 2\"");
add(10652,"DATA \"What: Edit by line number; retype to replace.\"");
add(10653,"DATA \"Use: LIST to view lines; NEW clears program\"");
add(10654,"DATA \"Use: RUN to execute; ESC to stop\"");
add(10655,"DATA \"Tip: Save often with SAVE \"\"NAME\"\"\"");
add(10656,"DATA \"SCREENEDIT or SE to load full screen editor.\"");
add(10657,"DATA \"See also: SAVE/LOAD\"");
add(10660,"REM === Page 34: Editor & Files / Editor Commands p3 ===");
add(10670,"DATA 7");
add(10671,"DATA \"EDITOR COMMANDS - Part 3\"");
add(10672,"DATA \"What: Debugging tips.\"");
add(10673,"DATA \"Use: Console logs for tracing (HTML)\"");
add(10674,"DATA \"Use: RUN to Run Program, ESC to stop\"");
add(10675,"DATA \"\"");
add(10676,"DATA \"See also: Shortcuts\"");
add(10677,"DATA \"\"");
add(10680,"REM === Page 35: Editor & Files / DIR Overlay ===");
add(10690,"DATA 7");
add(10691,"DATA \"DIR OVERLAY\"");
add(10692,"DATA \"What: Pick files from a directory overlay.\"");
add(10693,"DATA \"Keys: Arrows to move, ENTER select, ESC cancel\"");
add(10694,"DATA \"Tip: Pause editor input while overlay is open.\"");
add(10695,"DATA \"Tip: Validate names and paths.\"");
add(10696,"DATA \"See also: SAVE/LOAD\"");
add(10697,"DATA \"NOTE: Currently some oddities 9 Sept 2025\"");
add(10700,"REM === Page 36: Editor & Files / SAVE-LOAD ===");
add(10710,"DATA 8");
add(10711,"DATA \"SAVE / LOAD\"");
add(10712,"DATA \"What: Save a program and load it later.\"");
add(10713,"DATA \"Type: SAVE \"\"DEMO\"\"   :   LOAD \"\"DEMO\"\"\"");
add(10714,"DATA \"Tip: Avoid spaces or odd characters in \"");
add(10715,"DATA \"names.\"");
add(10716,"DATA \"Tip: Confirm overwrite; keep versions.\"");
add(10717,"DATA \"Tip: Consider auto-save on run or exit.\"");
add(10718,"DATA \"See also: Editor Commands, DIR Overlay\"");
add(10720,"REM === Page 37: Editor & Files / Shortcuts p1 ===");
add(10730,"DATA 7");
add(10731,"DATA \"SHORTCUTS - Part 1\"");
add(10732,"DATA \"F5 Dumps program to Console (HTML); ESC = STOP\"");
add(10733,"DATA \"Ctrl+C Copy   ;   Ctrl+V Paste (browser perms)\"");
add(10734,"DATA \"Command: HELP to open this help\"");
add(10735,"DATA \"Tip: Show hints in the status bar.\"");
add(10736,"DATA \"SE short for SCREENEDIT; Full screen editor\"");
add(10737,"DATA \"See also: Shortcuts p2\"");
add(10740,"REM === Page 38: Editor & Files / Shortcuts p2 ===");
add(10750,"DATA 7");
add(10751,"DATA \"SHORTCUTS - Part 2\"");
add(10752,"DATA \"Tips: Keep lines short; use gaps 10,20,30\"");
add(10753,"DATA \"Tips: Label output: PRINT \"\"A=\"\" ; A\"");
add(10754,"DATA \"Tips: Use comments with REM or '\"");
add(10755,"DATA \"Tips: Re-run often; save before big edits\"");
add(10756,"DATA \"See also: Editor Commands\"");
add(10757,"DATA \"\"");

}
/// @script infix_to_postfix
// === BEGIN: infix_to_postfix ===
function infix_to_postfix(tokens) {
    if (dbg_on(DBG_PARSE)) show_debug_message("Converting to postfix: " + string(tokens));

    var output = [];
    var stack  = [];

    var _TOKU = function(_t) { return string_upper(string(_t)); };

    var _push_all = function(_dst, _src) {
        for (var __i = 0; __i < array_length(_src); __i++) array_push(_dst, _src[__i]);
    };

    var _is_zero_arg_fn = function(_name) {
        var n = string_upper(_name);
        return (n == "TIMER" || n == "TIME$" || n == "DATE$" || n == "INKEY$");
    };

    var _is_STRING_fn = function(_name) {
        return string_upper(string(_name)) == "STRING$";
    };

    // pass tokens explicitly so we don't rely on closure capture
    var _read_paren_payload = function(_tokens, _start) {
        var _depth = 0, j = _start, inner = "", matched = false;
        while (j < array_length(_tokens)) {
            var tk = _tokens[j];
            if (tk == "(") {
                _depth++;
                if (_depth > 1) inner += tk;
            } else if (tk == ")") {
                _depth--;
                if (_depth == 0) { matched = true; break; }
                inner += tk;
            } else {
                inner += tk;
            }
            j++;
        }
        return [matched, inner, j];
    };

    for (var i = 0; i < array_length(tokens); i++) {
        var t  = tokens[i];

        if (t == ",") { if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Skipping comma token"); continue; }

        var tu = _TOKU(t);

        // 1) ARRAY READ COLLAPSE
        if (is_string(t)) {
            var first = string_char_at(t, 1);
            var can_be_name = is_letter(first);

            if (can_be_name && i + 1 < array_length(tokens) && tokens[i + 1] == "("
            && !(is_function(t) || _is_STRING_fn(t))) {
                if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Candidate for array collapse → '" + string(t) + "' followed by '('");
                var arr_info = _read_paren_payload(tokens, i + 1);
                var matched  = arr_info[0];
                var inner    = arr_info[1];
                var j        = arr_info[2];

                if (matched) {
                    var collapsed = string(t) + "(" + inner + ")";
                    array_push(output, collapsed);
                    if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Collapsed array read token → '" + collapsed + "' (consumed through index " + string(j) + ")");
                    i = j;
                    continue;
                } else {
                    if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: WARNING — unmatched '(' after '" + string(t) + "'. Not collapsing.");
                }
            }
        }

        // 2) NUMERIC LITERAL
        if (is_numeric_string(t)) { array_push(output, t); if (dbg_on(DBG_PARSE)) show_debug_message("Added number to output: " + string(t)); continue; }

        // 3) KNOWN VARIABLE
        if (ds_map_exists(global.basic_variables, tu)) { array_push(output, tu); if (dbg_on(DBG_PARSE)) show_debug_message("Added variable name to output: " + tu); continue; }

        // 4) OPEN PAREN
        if (t == "(") { array_push(stack, t); if (dbg_on(DBG_PARSE)) show_debug_message("Pushed '(' onto operator stack"); continue; }

        // 5) CLOSE PAREN
        if (t == ")") {
            while (array_length(stack) > 0 && stack[array_length(stack) - 1] != "(") {
                var popped_close = array_pop(stack);
                array_push(output, popped_close);
                if (dbg_on(DBG_PARSE)) show_debug_message("Popped '" + string(popped_close) + "' from stack to output (closing ')')");
            }
            if (array_length(stack) > 0 && stack[array_length(stack) - 1] == "(") {
                array_pop(stack);
                if (dbg_on(DBG_PARSE)) show_debug_message("Discarded matching '(' from stack");
            } else {
                if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: WARNING — stray ')' with no matching '('");
            }
            continue;
        }

        // 6) OPERATORS
        if (is_operator(t)) {
            if (dbg_on(DBG_PARSE)) show_debug_message("Found operator: " + string(t));
            while (array_length(stack) > 0) {
                var top = stack[array_length(stack) - 1];
                if (is_operator(top) && (get_precedence(top) > get_precedence(t)
                || (get_precedence(top) == get_precedence(t) && !is_right_associative(t)))) {
                    var popped_op = array_pop(stack);
                    array_push(output, popped_op);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Popped higher/equal precedence operator '" + string(popped_op) + "' to output");
                } else break;
            }
            array_push(stack, t);
            if (dbg_on(DBG_PARSE)) show_debug_message("Pushed operator '" + string(t) + "' onto stack");
            continue;
        }

        // 7) FUNCTIONS
        if (is_function(t) || _is_STRING_fn(t)) {
            var fn_name = tu;

            // Zero-arg functions emit directly
            if (_is_zero_arg_fn(fn_name)) {
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("Processed zero-arg function: " + fn_name);
                continue;
            }

            // Must be followed by '('
            if (!(i + 1 < array_length(tokens) && tokens[i + 1] == "(")) {
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("Function without '(': passing through → " + fn_name);
                continue;
            }

            // Read (...): pass tokens explicitly
            var f_info  = _read_paren_payload(tokens, i + 1);
            var f_ok    = f_info[0];
            var f_inner = f_info[1];
            var f_end   = f_info[2];

            if (!f_ok) {
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("WARNING: unmatched '(' for function " + fn_name + " — passing through");
                continue;
            }

            // ---------- SPECIAL: STRING$(x, n) ----------
            if (fn_name == "STRING$") {
                var lvl = 0, part = "", parts = [];
                for (var ci = 1; ci <= string_length(f_inner); ci++) {
                    var ch = string_char_at(f_inner, ci);
                    if (ch == "(") { lvl++; part += ch; }
                    else if (ch == ")") { lvl--; part += ch; }
                    else if (ch == "," && lvl == 0) { array_push(parts, string_trim(part)); part = ""; }
                    else { part += ch; }
                }
                array_push(parts, string_trim(part));

                if (array_length(parts) == 2) {
                    var t1 = basic_tokenize_expression_v2(parts[0]);
                    var t2 = basic_tokenize_expression_v2(parts[1]);
                    var p1 = infix_to_postfix(t1);
                    var p2 = infix_to_postfix(t2);
                    _push_all(output, p1);
                    _push_all(output, p2);
                    array_push(output, fn_name);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed STRING$(x,n): args = [" + parts[0] + "], [" + parts[1] + "]");
                    i = f_end;
                    continue;
                }
                // fall through to generic handling if malformed
            }

            // ---------- SPECIAL: LEFT$/RIGHT$/MID$ (multi-arg) ----------
            if (fn_name == "LEFT$" || fn_name == "RIGHT$" || fn_name == "MID$") {
                var lvl2 = 0, part2 = "", parts_lr = [];
                for (var ci2 = 1; ci2 <= string_length(f_inner); ci2++) {
                    var ch2 = string_char_at(f_inner, ci2);
                    if (ch2 == "(") { lvl2++; part2 += ch2; }
                    else if (ch2 == ")") { lvl2--; part2 += ch2; }
                    else if (ch2 == "," && lvl2 == 0) { array_push(parts_lr, string_trim(part2)); part2 = ""; }
                    else { part2 += ch2; }
                }
                array_push(parts_lr, string_trim(part2));

                // LEFT$/RIGHT$ expect exactly 2 args
                if ((fn_name == "LEFT$" || fn_name == "RIGHT$") && array_length(parts_lr) == 2) {
                    var tA1 = basic_tokenize_expression_v2(parts_lr[0]);
                    var tA2 = basic_tokenize_expression_v2(parts_lr[1]);
                    var pA1 = infix_to_postfix(tA1);
                    var pA2 = infix_to_postfix(tA2);
                    _push_all(output, pA1);
                    _push_all(output, pA2);
                    array_push(output, fn_name);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed " + fn_name + "(" + parts_lr[0] + "," + parts_lr[1] + ")");
                    i = f_end;
                    continue;
                }

                // MID$ supports 2 or 3 args
                if (fn_name == "MID$" && (array_length(parts_lr) == 2 || array_length(parts_lr) == 3)) {
                    for (var mi = 0; mi < array_length(parts_lr); mi++) {
                        var tMi = basic_tokenize_expression_v2(parts_lr[mi]);
                        var pMi = infix_to_postfix(tMi);
                        _push_all(output, pMi);
                    }
                    array_push(output, fn_name);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed MID$(" + string(parts_lr) + ")");
                    i = f_end;
                    continue;
                }
                // else fall through to generic one-arg below
            }

            // ---------- SPECIAL: RND (0/1/2-arg variants) ----------
            if (fn_name == "RND") {
                var inner_trim = string_trim(f_inner);

                // 0-arg: RND()
                if (string_length(inner_trim) == 0) {
                    array_push(output, "RND");
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed RND()");
                    i = f_end;
                    continue;
                }

                // Split on top-level commas
                var lvlR = 0, partR = "", partsR = [];
                for (var ri = 1; ri <= string_length(f_inner); ri++) {
                    var chR = string_char_at(f_inner, ri);
                    if (chR == "(") { lvlR++; partR += chR; }
                    else if (chR == ")") { lvlR--; partR += chR; }
                    else if (chR == "," && lvlR == 0) { array_push(partsR, string_trim(partR)); partR = ""; }
                    else { partR += chR; }
                }
                array_push(partsR, string_trim(partR));

                if (array_length(partsR) == 1) {
                    var tN = basic_tokenize_expression_v2(partsR[0]);
                    var pN = infix_to_postfix(tN);
                    _push_all(output, pN);
                    array_push(output, "RND1");
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed RND(" + partsR[0] + ") → RND1");
                    i = f_end;
                    continue;
                }

                if (array_length(partsR) == 2) {
                    var tA = basic_tokenize_expression_v2(partsR[0]);
                    var tB = basic_tokenize_expression_v2(partsR[1]);
                    var pA = infix_to_postfix(tA);
                    var pB = infix_to_postfix(tB);
                    _push_all(output, pA);
                    _push_all(output, pB);
                    array_push(output, "RND2");
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed RND(" + partsR[0] + "," + partsR[1] + ") → RND2");
                    i = f_end;
                    continue;
                }
                // malformed → fall through to generic
            }

            // Generic one-arg function: <inner> <FN>
            var inner_tokens  = basic_tokenize_expression_v2(f_inner);
            var inner_postfix = infix_to_postfix(inner_tokens);
            _push_all(output, inner_postfix);
            array_push(output, fn_name);
            if (dbg_on(DBG_PARSE)) show_debug_message("Processed 1-arg function " + fn_name + "(" + f_inner + ") → postfix emit <inner> " + fn_name);
            i = f_end;
            continue;
        }

        // 8) UNKNOWN TOKEN
        if (dbg_on(DBG_PARSE)) show_debug_message("Unknown token, adding to output: " + string(t));
        array_push(output, t);
    }

    // Drain operator stack
    while (array_length(stack) > 0) {
        var tail = array_pop(stack);
        array_push(output, tail);
        if (dbg_on(DBG_PARSE)) show_debug_message("Drained operator stack → appended '" + string(tail) + "'");
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("Final postfix: " + string(output));
    return output;
}
// === END: infix_to_postfix ===

function basic_tokenize_expression_v2(expr) { 
    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting expression: '" + expr + "'");

    var tokens  = [];
    var i       = 1;
    var len     = string_length(expr);
    var current = "";

    // Names that, when immediately followed by '(', should be treated as function calls
    var function_names = ["RND","ABS","EXP","LOG","LOG10","SGN","INT","SIN","COS","TAN","STR$","CHR$","REPEAT$","ASC","LEN"];

    while (i <= len) {
        var c = string_char_at(expr, i);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");

        // --------------------------------------------------------------------
        // STRING LITERALS: copy verbatim `"..."` including the closing quote.
        // --------------------------------------------------------------------
        if (c == "\"") {
            var str = "\"";
            i++;
            while (i <= len) {
                var ch = string_char_at(expr, i);
                str += ch;
                if (ch == "\"") break;   // NOTE: this keeps doubled quotes as-is; evaluator unescapes "" → "
                i++;
            }
            array_push(tokens, str);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added (quoted string): " + str);
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // WHITESPACE: finalize any pending token and skip the space.
        // --------------------------------------------------------------------
        if (c == " ") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token from space: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // RELATIONAL (two-char first): <=  >=  <>
        // We must emit these as single tokens so "ROLL<3" → ["ROLL","<","3"].
        // --------------------------------------------------------------------
        if (c == "<" || c == ">") {
            // finalize any pending identifier/number before the operator
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before relation: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            var two = (i < len) ? c + string_char_at(expr, i + 1) : "";
            if (two == "<=" || two == ">=" || two == "<>") {
                array_push(tokens, two);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Relation token added: " + two);
                i += 2;
                continue;
            } else {
                array_push(tokens, c);  // bare < or >
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Relation token added: " + c);
                i += 1;
                continue;
            }
        }

        // --------------------------------------------------------------------
        // EQUALITY: single '='
        // --------------------------------------------------------------------
        if (c == "=") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before '=': '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, "=");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: '=' token added");
            i += 1;
            continue;
        }

        // --------------------------------------------------------------------
        // ARITHMETIC / PARENS / POWER / INT-DIV: +  *  /  \  (  )  %  ^
        //  - If '(' follows a known function name token, we still just emit '(';
        //    the function-ness is used later by the parser, not the tokenizer.
        // --------------------------------------------------------------------
        if (c == "+" || c == "*" || c == "/" || c == "\\" || c == "(" || c == ")" || c == "%" || c == "^") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before operator: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            // We still push "(" literally. Detection of "NAME(" being a function call
            // is handled later by your infix/postfix logic (it looks at the NAME token).
            array_push(tokens, c);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);

            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // ARG SEPARATOR: comma
        // --------------------------------------------------------------------
        if (c == ",") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before comma: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, ",");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Comma token added");
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // MINUS: subtraction or start of a negative number token.
        // Heuristic: if '-' is at start, or follows another operator/paren/relation,
        // and is followed by a digit, we treat it as the start of a numeric literal.
        // --------------------------------------------------------------------
        if (c == "-") {
            // finalize any pending token first
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before minus: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            var is_negative = false;

            // only consider negative if a digit follows
            if (i < len) {
                var next_is_digit = (ord(string_char_at(expr, i + 1)) >= 48 && ord(string_char_at(expr, i + 1)) <= 57);
                if (next_is_digit) {
                    if (array_length(tokens) == 0) {
                        is_negative = true; // start of expression → negative
                    } else {
                        var last_token = tokens[array_length(tokens) - 1];
                        // If previous token is an operator/paren/relation, this '-' starts a number
                        if ( last_token == "+" || last_token == "-" || last_token == "*" 
                          || last_token == "/" || last_token == "(" || last_token == "%" 
                          || last_token == "^" || string_upper(last_token) == "MOD" 
                          || last_token == "=" || last_token == "<" || last_token == ">" 
                          || last_token == "<=" || last_token == ">=" || last_token == "<>" ) {
                            is_negative = true;
                        }
                    }
                }
            }

            if (is_negative) {
                current = "-"; // begin building a numeric literal like "-12"
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting negative number");
            } else {
                array_push(tokens, "-"); // subtraction operator
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Added subtraction operator");
            }

            i++;
            continue;
        }
        // ------------------------- END '-' handling -------------------------

        // --------------------------------------------------------------------
        // DEFAULT: accumulate chars for identifiers or number bodies.
        // --------------------------------------------------------------------
        current += c;
        i++;
    }

    // ------------------------------------------------------------------------
    // END: flush any leftover token.
    // ------------------------------------------------------------------------
    if (current != "") {
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing last token: '" + current + "'");
        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Final token list = " + string(tokens));
    return tokens;
}

/// @func build_data_streams()
/// @desc Pre-scan the loaded program for DATA statements and harvest values
///       into named streams: global.data_streams[stream_name] = { list, ptr }.
///       Default stream name is "" (empty). Named stream: DATA @name: v1, v2, ...
function build_data_streams() {
    // Ensure the container map exists; clear any prior contents safely
    // We rely on obj_globals to have created global.data_streams (a ds_map).
    // Here we only clear/recycle it between runs by destroying per-stream lists.
    if (!ds_exists(global.data_streams, ds_type_map)) {
        // Safety net (shouldn't happen if obj_globals set it up)
        global.data_streams = ds_map_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("DATA: safety-created global.data_streams (missing map)");
    }

    // Destroy any old lists then clear the map for a fresh build
    var _k = ds_map_find_first(global.data_streams);
    while (!is_undefined(_k)) {
        var _st = ds_map_find_value(global.data_streams, _k);
        if (is_struct(_st)) {
            if (ds_exists(_st.list, ds_type_list)) ds_list_destroy(_st.list);
        }
        _k = ds_map_find_next(global.data_streams, _k);
    }
    ds_map_clear(global.data_streams);

    var total_vals = 0, added_lines = 0;

    // Iterate by physical line order using your runtime copies
    // (run_program() already did ds_map_copy → basic_program and ds_list_copy → basic_line_numbers)
    for (var i = 0; i < ds_list_size(global.basic_line_numbers); i++) {
        var line_no = global.basic_line_numbers[| i];
        var raw     = ds_map_find_value(global.basic_program, line_no);
        if (is_undefined(raw)) continue;

        var parts = split_on_unquoted_colons(string_trim(raw));

        for (var p = 0; p < array_length(parts); p++) {
            // *** CHANGE: look at the raw colon slot first (before stripping remarks)
            var stmt_full = string_trim(parts[p]);
            if (stmt_full == "") continue;

            var sp0   = string_pos(" ", stmt_full);
            var verb0 = (sp0 > 0) ? string_upper(string_copy(stmt_full, 1, sp0 - 1)) : string_upper(stmt_full);

            // *** CHANGE: if this part is REM or starts with apostrophe, stop scanning the rest of THIS line
            if (verb0 == "REM" || string_char_at(stmt_full, 1) == "'") {
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA scan: REM/' stops line " + string(line_no) + " at part " + string(p));
                break; // stop processing parts[] for this physical line
            }

            // Now strip inline remarks (so code like: DATA 1,2 'comment keeps "DATA 1,2")
            var part_raw = strip_basic_remark(stmt_full);
            if (part_raw == "") continue;

            var sp   = string_pos(" ", part_raw);
            var verb = (sp > 0) ? string_upper(string_copy(part_raw, 1, sp - 1)) : string_upper(part_raw);
            var rest = (sp > 0) ? string_trim(string_copy(part_raw, sp + 1, string_length(part_raw))) : "";

            if (verb != "DATA") continue;

            // --- collapse the remainder of THIS physical line so ':' after @name doesn't split the DATA ---
            // *** CHANGE: also stop collapse if we hit a REM/' part later on the same line.
            var remainder = part_raw;
            for (var t = p + 1; t < array_length(parts); t++) {
                var tail_full = string_trim(parts[t]);
                if (tail_full == "") continue;

                var spT   = string_pos(" ", tail_full);
                var verbT = (spT > 0) ? string_upper(string_copy(tail_full, 1, spT - 1)) : string_upper(tail_full);

                // *** CHANGE: if a later colon slot is a whole-line comment, stop collapse here
                if (verbT == "REM" || string_char_at(tail_full, 1) == "'") {
                    if (dbg_on(DBG_FLOW)) show_debug_message("DATA collapse: hit REM/' at part " + string(t) + " on line " + string(line_no));
                    break;
                }

                var tail = strip_basic_remark(tail_full);
                if (tail != "") remainder += ":" + tail;
            }
            if (dbg_on(DBG_FLOW) && remainder != part_raw) show_debug_message("DATA: collapsed line parts → '" + remainder + "'");

            // Recompute 'rest' from the collapsed DATA statement
            var sp2  = string_pos(" ", remainder);
            rest     = (sp2 > 0) ? string_trim(string_copy(remainder, sp2 + 1, string_length(remainder))) : "";
            added_lines++;

            var stream_name = "";     // default stream
            var values_text = rest;   // may be rewritten if @name: is present

            // Optional named stream: DATA @name: v1, v2, ...
            if (string_length(rest) > 0 && string_char_at(rest, 1) == "@") {
                var _depth = 0, inq = false, cut = 0, L = string_length(rest);
                for (var j = 1; j <= L; j++) {
                    var ch = string_char_at(rest, j);
                    if (ch == "\"") {
                        var nxt = (j < L) ? string_char_at(rest, j + 1) : "";
                        if (inq && nxt == "\"") { j++; continue; }
                        inq = !inq; continue;
                    }
                    if (inq) continue;
                    if (ch == "(") { _depth++; continue; }
                    if (ch == ")") { _depth = max(0, _depth - 1); continue; }
                    if (ch == ":" && _depth == 0) { cut = j; break; }
                }
                if (cut == 0) {
                   if (dbg_on(DBG_FLOW)) show_debug_message("?DATA ERROR: expected ':' after @name — line " + string(line_no) + " text: '" + part_raw + "'");
                    continue;
                }
                stream_name = string_trim(string_copy(rest, 2, cut - 2)); // exclude '@'
                values_text = string_trim(string_copy(rest, cut + 1, L - cut));
            }

            var vals = split_on_unquoted_commas(values_text);

            if (!ds_map_exists(global.data_streams, stream_name)) {
                var stream = { list: ds_list_create(), ptr: 0 };
                ds_map_add(global.data_streams, stream_name, stream);
            }
            var sref = ds_map_find_value(global.data_streams, stream_name);

            for (var vi = 0; vi < array_length(vals); vi++) {
                var token = vals[vi];
                var v = parse_data_value(token);
                ds_list_add(sref.list, v);
                total_vals++;
                if (dbg_on(DBG_FLOW)) show_debug_message(
                    "DATA: +" + (is_string(v) ? ("\"" + string(v) + "\"") : string(v)) +
                    " -> stream='" + stream_name + "' (line " + string(line_no) + ")"
                );
            }

            // we consumed the collapsed remainder of this physical line for this DATA
            break;
        }
    }

    if (dbg_on(DBG_FLOW)) {
        var summary = "DATA SUMMARY — streams: ";
        var k2 = ds_map_find_first(global.data_streams);
        while (!is_undefined(k2)) {
            var st2 = ds_map_find_value(global.data_streams, k2);
            var cnt = ds_list_size(st2.list);
            summary += "'" + string(k2) + "'=" + string(cnt) + "  ";
            k2 = ds_map_find_next(global.data_streams, k2);
        }
       if (dbg_on(DBG_FLOW)) show_debug_message(summary + "| values=" + string(total_vals) + " | data_lines=" + string(added_lines));
    }

    // TEMP: verify default stream size
    if (ds_map_exists(global.data_streams, "")) {
        var _def = ds_map_find_value(global.data_streams, "");
       if (dbg_on(DBG_FLOW)) show_debug_message("DATA DEFAULT SIZE = " + string(ds_list_size(_def.list)));
    }
}

// === BEGIN: basic_cmd_print ===
function basic_cmd_print(arg, line_number) {

    if (!ds_exists(global.output_lines, ds_type_list))  global.output_lines  = ds_list_create();
    if (!ds_exists(global.output_colors, ds_type_list)) global.output_colors = ds_list_create();

    var suppress_newline = false;
    var tabw = max(1, is_undefined(global.print_zone) ? 14 : global.print_zone);
    var line_accum = "";
    var col = 0;

    // Trailing semicolon → no newline
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Trailing semicolon detected; suppressing newline");
    }

    arg = string_trim(arg);

    // 1) Split by unquoted semicolons (these do NOT tab)
    var semi_parts = split_on_unquoted_semicolons(arg);

    // 2) Flatten, preserving WHICH separator preceded each part
    //    sep[i] ∈ { "START", "SEMI", "COMMA" }
    var parts = [];
    var seps  = [];

    var have_any = false;
    for (var si = 0; si < array_length(semi_parts); si++) {
        var seg = string_trim(semi_parts[si]);
        if (seg == "") {
            // if there are consecutive semicolons, they just concatenate nothing
            continue;
        }

        var comma_parts = split_on_unquoted_commas(seg);
        if (array_length(comma_parts) <= 1) {
            parts[array_length(parts)] = seg;
            seps[array_length(seps)]   = (have_any ? "SEMI" : "START");
            have_any = true;
        } else {
            for (var cj = 0; cj < array_length(comma_parts); cj++) {
                var p = string_trim(comma_parts[cj]);
                if (p == "") continue;
                parts[array_length(parts)] = p;
                var sep_kind = "START";
                if (have_any) {
                    // first item of this segment is after a semicolon; others after commas
                    sep_kind = (cj == 0) ? "SEMI" : "COMMA";
                }
                seps[array_length(seps)] = sep_kind;
                have_any = true;
            }
        }
    }

    // Column-aware appender with "\t" expansion (inline, no local functions)
    var _append_string = 0; // dummy to allow block reuse via comments

    // 3) Evaluate/emit each part with separator behavior
    for (var i = 0; i < array_length(parts); i++) {

        // --- Insert padding if previous separator was a COMMA (tab to next zone)
		if (seps[i] == "COMMA") {
		    var pad_comm;
		    if (global.print_tab_mode == 1) {
		        // Fixed-width tab (equal every time)
		        pad_comm = tabw;
		    } else {
		        // Zone tab (classic BASIC)
		        var next_zone = ((col div tabw) + 1) * tabw;
		        pad_comm = max(1, next_zone - col);
		    }
		    line_accum += string_repeat(" ", pad_comm);
		    col += pad_comm;
		}

        // "SEMI" and "START" add nothing (plain concatenation)

        var part = parts[i];
        var treat_as_literal = false;

        if (is_quoted_string(part)) {
            var inner = string_copy(part, 2, string_length(part) - 2);
            if (!string_pos("+", inner) && !string_pos("-", inner) && !string_pos("*", inner) && !string_pos("/", inner)) {
                treat_as_literal = true;
            }
        }

        var text_piece = "";

        if (treat_as_literal) {
            text_piece = string_copy(part, 2, string_length(part) - 2);
            text_piece = string_replace_all(text_piece, "\"\"", "\""); // "" → "
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " literal → " + text_piece);
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " expr → " + part);
            var tokens  = basic_tokenize_expression_v2(part);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Tokens = " + string(tokens));
            var postfix = infix_to_postfix(tokens);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Postfix = " + string(postfix));
            var result  = evaluate_postfix(postfix);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Evaluated result = " + string(result));

            // INKEY$ modal sentinel — defer PRINT until resume
            if (is_string(result) && result == "<<INKEY_WAIT>>") {
                if (is_undefined(global.inkey_waiting))  global.inkey_waiting  = false;
                if (is_undefined(global.inkey_captured)) global.inkey_captured = "";
                global.inkey_waiting   = true;
                global.inkey_captured  = "";
                global.pause_in_effect = true;
                global.awaiting_input  = false;
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY_WAIT: Deferring PRINT until a key is captured.");
                return;
            }

            if (is_real(result)) {
                if (array_length(parts) > 1) {
                    text_piece = string(result); // compact for multi-arg print
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (compact) → '" + text_piece + "'");
                } else {
                    if (frac(result) == 0) text_piece = string(round(result));
                    else                   text_piece = string_format(result, 12, 8);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (padded) → '" + text_piece + "'");
                }
            } else {
                text_piece = string(result);
            }
        }

        // Treat CHR$(9) as a tab (optional, harmless)
        if (text_piece == chr(9)) text_piece = "\t";

        // Append with "\t" expansion and column tracking
        var s = string(text_piece);
        for (var k = 1; k <= string_length(s); k++) {
            var ch = string_char_at(s, k);
			if (ch == "\t") {
			    var pad = (global.print_tab_mode == 1)
			        ? tabw
			        : max(1, (((col div tabw) + 1) * tabw) - col);
			    line_accum += string_repeat(" ", pad);
			    col += pad;
			} else {
                line_accum += ch;
                col += 1;
            }
        }
    }

    // 4) Wrap + commit using your existing buffer
    var wrap_width = 40;
    var full_line  = global.print_line_buffer + line_accum;

    while (string_length(full_line) > wrap_width) {
        var line = string_copy(full_line, 1, wrap_width);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, global.current_draw_color);
        full_line = string_copy(full_line, wrap_width + 1, string_length(full_line) - wrap_width);
    }

    global.print_line_buffer = full_line;

    if (!suppress_newline) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Line committed → " + global.print_line_buffer);
        global.print_line_buffer = "";
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Output buffered without newline → " + global.print_line_buffer);
    }
}
// === END: basic_cmd_print ===

/// @event obj_editor/Draw
// Pause regular editor drawing when screen editor is active
if (global.screen_edit_mode) {
    //if (dbg_on(DBG_FLOW)) show_debug_message("EDITOR: Screen edit mode active, pausing regular editor draw");
    exit;
}


// Set font and calculate actual height
draw_set_font(fnt_basic);
var actual_font_height = string_height("A"); // Get real font height
draw_set_color(make_color_rgb(255, 191, 64));
draw_rectangle_color(0, 0, room_width, room_height, c_black, c_black, c_black, c_black, false);

if (showing_dir_overlay) {
    // Modal backdrop
    draw_set_color(c_black);
    draw_rectangle(0, 0, room_width, room_height, false);

	draw_set_font(fnt_basic_12); // smaller font for directory overlay
	draw_set_color(c_lime);


    var x_pad = 16;
    var y_pad = 16;

	// Split header across two lines for readability
	var header1 = "DIR: " + dir_save_dir;
	var header2 = "Files: " + string(array_length(dir_listing))
	    + " | Sel: " + string(dir_sel + 1) + "/" + string(max(1, array_length(dir_listing)))
	    + " | Keys: Arrows Move  Enter=>Load  D/X=>Delete  ESC Close";

	draw_text(x_pad, y_pad, header1);
	draw_text(x_pad, y_pad + string_height("A"), header2);


    // Compute rows/page (ASCII)
    var row_h       = string_height("A");
    var top_y       = y_pad + row_h * 3;
    var bottom_y    = room_height - y_pad - row_h * 2;
    var list_height = max(row_h, bottom_y - top_y);
    var rows_per_pg = max(1, floor(list_height / row_h));
    dir_page_size   = rows_per_pg; // expose for Step input

    // Clamp selection and compute page from sel
    var total = array_length(dir_listing);
    dir_sel = clamp(dir_sel, 0, max(0, total - 1));
    var first_index = (dir_sel div rows_per_pg) * rows_per_pg;
    var last_index  = min(total - 1, first_index + rows_per_pg - 1);

    // Borders (ASCII box)
    var left_x  = x_pad;
    var right_x = room_width - x_pad;
    // top border
    draw_text(left_x, top_y - row_h, "+-------------------------------------------+");
    // list rows
    var draw_y = top_y;
    for (var i = first_index; i <= last_index; i++) {
        var idx3 = string_format(string(i + 1), 3, 0); // 001, 002...
        var name = dir_listing[i];

        // Assemble row: index, filename (trim), actions
        var action_txt = "   >  X";
        var max_name_px = (right_x - left_x) - string_width(idx3 + " ") - string_width(action_txt) - 24;
        var name_trim = name;

        // crude pixel trimming to fit line
        while (string_width(name_trim) > max_name_px && string_length(name_trim) > 3) {
            name_trim = string_copy(name_trim, 1, string_length(name_trim) - 1);
        }
        if (name_trim != name) name_trim += "...";

        var row_text = idx3 + " " + name_trim;

        // Selected row highlight (inverse via black rect + lime text)
        if (i == dir_sel) {
            draw_set_color(c_dkgray);
            draw_rectangle(left_x - 6, draw_y - 2, right_x - 6, draw_y + row_h, false);
            draw_set_color(c_lime);
        }

        draw_text(left_x, draw_y, row_text);
        // draw actions at right
        var act_x = right_x - string_width(">  X") - 16;
        draw_text(act_x, draw_y, ">  X");

        draw_y += row_h;
    }
    // bottom border
    draw_text(left_x, draw_y, "+-------------------------------------------+");

    // Paging markers
    if (first_index > 0)      draw_text(right_x - 40, top_y - row_h, "^");
    if (last_index < total-1) draw_text(right_x - 40, draw_y, "v");

    // Confirm dialog (modal)
    if (dir_confirm_active) {
        var cx = room_width  div 2;
        var cy = room_height div 2;
        var w  = 520;
        var h  = row_h * 4;
        var l  = cx - w div 2;
        var t  = cy - h div 2;
        var r  = cx + w div 2;
        var b  = cy + h div 2;

        draw_set_color(c_black);
        draw_rectangle(l, t, r, b, false);
        draw_set_color(c_lime);

        var _nm = (dir_confirm_index >= 0 && dir_confirm_index < total) ? dir_listing[dir_confirm_index] : "";
        draw_text(l + 12, t + row_h, "Delete \"" + _nm + "\" ?");
        draw_text(l + 12, t + row_h * 2, "[Y]es  [N]o");

        // Note: modal—input handled in Step; draw only here
    }

    // Short help/footer
    draw_set_color(c_dkgray);
    draw_text(x_pad, room_height - row_h - y_pad, "(ASCII dir) Load: Enter/>   Delete: D/X (Desktop only)   Close: ESC");

    return; // overlay draws above everything
}


// Draw program lines with proper spacing
var y_pos = 32;
var lines_shown = 0;
var total_lines = ds_list_size(global.line_numbers);

// Calculate how many lines fit on screen
var available_height = room_height - 128; // Leave space for prompt and messages
var max_lines = floor(available_height / actual_font_height);

for (var i = display_start_line; i < total_lines && lines_shown < max_lines; i++) {
    var line_num = ds_list_find_value(global.line_numbers, i);
    var code = ds_map_find_value(global.program_lines, line_num);
    var display_text = string(line_num) + " " + code;
    
    draw_text(16, y_pos, display_text);
    y_pos += actual_font_height; // Use actual font height
    lines_shown++;
}

// Draw input prompt with proper spacing
draw_text(16, room_height - (actual_font_height * 2), "READY");
draw_text(16, room_height - actual_font_height, "> " + current_input);

// Draw cursor
var cursor_x = 16 + string_width("> " + string_copy(current_input, 1, cursor_pos));
if (current_time % 1000 < 500) { // Blinking cursor
    draw_text(cursor_x, room_height - actual_font_height, "_");
}

// Draw message with proper spacing
if (message_text != "") {
    draw_set_color(c_yellow);
    draw_text(16, room_height - (actual_font_height * 3), message_text);
    draw_set_color(make_color_rgb(255, 191, 64)); // Reset color
}
/// @function basic_cmd_beep(arg)
/// @desc Play one or more pitched “piezo” beeps in sequence, with rests and inline octave changes.
/// Syntax:
///   BEEP <spec> [<spec> ...]
/// spec := <NOTE><DUR> | O<oct>
/// NOTE: A..G (optional # or b) or R (rest)
/// DUR : beats; 1=quarter, 2=half, 4=whole, 0.5=eighth, 0=sixteenth (=0.25)
/// O<oct> applies to subsequent notes until changed (relative to C4 = middle C)
function basic_cmd_beep(arg)
{
	// --- persisted octave across BEEP calls (default 0 = C4) ---
var cur_oct = 0;
if (variable_global_exists("beep_current_oct") && is_real(global.beep_current_oct)) {
    cur_oct = clamp(round(global.beep_current_oct), -6, 6); // safety bounds
}


    var s = string_trim(arg);
    if (s == "") {
        basic_syntax_error("BEEP requires at least one note, e.g., BEEP C1",
            global.current_line_number, global.interpreter_current_stmt_index, "BEEP_BAD_ARGS");
        return;
    }

    // If a sequence is already running, ignore re-trigger safely
    if (global.beep_waiting || (variable_global_exists("beep_seq_active") && global.beep_seq_active)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("BEEP: already active; ignoring re-trigger");
        return;
    }

    // Simple whitespace tokenizer
    var toks = [];
    {
        var i = 1, L = string_length(s), start = 1;
        while (i <= L) {
            if (string_char_at(s, i) == " ") {
                if (i > start) array_push(toks, string_trim(string_copy(s, start, i - start)));
                start = i + 1;
            }
            i++;
        }
        if (start <= L) array_push(toks, string_trim(string_copy(s, start, L - start + 1)));
    }
    if (array_length(toks) <= 0) {
        basic_syntax_error("BEEP: nothing to play",
            global.current_line_number, global.interpreter_current_stmt_index, "BEEP_EMPTY");
        return;
    }

    // Ensure queue exists
    if (!variable_global_exists("beep_seq_queue") || !ds_exists(global.beep_seq_queue, ds_type_queue)) {
        global.beep_seq_queue = ds_queue_create();
    } else {
        ds_queue_clear(global.beep_seq_queue);
    }

    var cur_oct = 0; // relative to C4
    var added   = 0;

    // Parse each token: either O<oct> or <NOTE><DUR>
    for (var k = 0; k < array_length(toks); k++) {
        var t = string_upper(string_trim(toks[k]));
        if (t == "") continue;

        // Octave change
        if (string_copy(t, 1, 1) == "O") {
            var orest = string_copy(t, 2, string_length(t) - 1);
            if (string_length(orest) == 0 || !is_numeric_string(orest)) {
                basic_syntax_error("BEEP O<octave> expects integer, e.g., O-1 or O2",
                    global.current_line_number, global.interpreter_current_stmt_index, "BEEP_BAD_OCT");
                return;
            }
            cur_oct = real(orest);
			global.beep_current_oct = cur_oct;  // persist for subsequent BEEP calls

            continue;
        }

        // NOTE + optional accidental + duration
        var n0 = string_char_at(t, 1);
        if (!(n0 == "A" || n0 == "B" || n0 == "C" || n0 == "D" || n0 == "E" || n0 == "F" || n0 == "G" || n0 == "R")) {
            basic_syntax_error("BEEP token '"+t+"' must start with A..G or R (rest), or O<octave>",
                global.current_line_number, global.interpreter_current_stmt_index, "BEEP_BAD_TOKEN");
            return;
        }

        var pos = 2;
        var acc = 0;
        if (pos <= string_length(t)) {
            var ch = string_char_at(t, pos);
            if (ch == "#" || ch == "B") { acc = (ch == "#") ? 1 : -1; pos += 1; }
        }

        var dur_str = string_copy(t, pos, string_length(t) - (pos - 1));
        if (string_length(dur_str) == 0 || !is_numeric_string(dur_str)) {
            basic_syntax_error("BEEP note '"+t+"' requires numeric duration (e.g., C1, A#0.5, R1)",
                global.current_line_number, global.interpreter_current_stmt_index, "BEEP_BAD_DUR");
            return;
        }

        var beats = real(dur_str);
        if (beats == 0) beats = 0.25;
        if (beats < 0) {
            basic_syntax_error("BEEP duration must be non-negative",
                global.current_line_number, global.interpreter_current_stmt_index, "BEEP_BAD_DUR");
            return;
        }

        // Enqueue compact tuple [note, acc, beats, oct]
        var pack = array_create(4);
        pack[0] = n0;       // 'A'..'G' or 'R'
        pack[1] = acc;      // -1,0,+1
        pack[2] = beats;    // real
        pack[3] = cur_oct;  // integer
        ds_queue_enqueue(global.beep_seq_queue, pack);
        added += 1;
    }

    if (added <= 0) {
        basic_syntax_error("BEEP: no playable notes parsed",
            global.current_line_number, global.interpreter_current_stmt_index, "BEEP_EMPTY2");
        return;
    }

    // Mark sequence active and remember where to resume after all notes
    global.beep_seq_active   = true;
    global.beep_resume_line  = global.interpreter_current_line_index;
    global.beep_resume_stmt  = global.interpreter_current_stmt_index + 1;

    // Kick off the first note (do NOT schedule resume yet)
    _beep_seq_next(); // separate script

    // Hold interpreter until sequence completes
    global.pause_in_effect = true;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("BEEP: queued " + string(added) + " notes; pausing until sequence completes");
    }
}

/// @event obj_globals/Game_End
global.inkey_mode = false;
// ─────────────────────────────
// MAPS
// ─────────────────────────────
if (ds_exists(global.basic_variables, ds_type_map)) ds_map_destroy(global.basic_variables);
if (ds_exists(global.program_lines, ds_type_map)) ds_map_destroy(global.program_lines);
if (ds_exists(global.basic_program, ds_type_map)) ds_map_destroy(global.basic_program);
if (ds_exists(global.program_map, ds_type_map)) ds_map_destroy(global.program_map);
if (ds_exists(global.colors, ds_type_map)) ds_map_destroy(global.colors);
if (ds_exists(global.if_block_map, ds_type_map)) {
    var _key = ds_map_find_first(global.if_block_map);
    while (!is_undefined(_key)) {
        var _info = global.if_block_map[? _key];
        if (ds_exists(_info[? "elseifIndices"], ds_type_list)) ds_list_destroy(_info[? "elseifIndices"]);
        ds_map_destroy(_info);
        _key = ds_map_find_next(global.if_block_map, _key);
    }
    ds_map_destroy(global.if_block_map);
}
if (ds_exists(global.mode_rooms, ds_type_map)) ds_map_destroy(global.mode_rooms);
if (ds_exists(global.font_sheets, ds_type_map)) ds_map_destroy(global.font_sheets);
if (ds_exists(global.config, ds_type_map)) ds_map_destroy(global.config);
if (ds_exists(global.data_streams, ds_type_map)) {
    var _key = ds_map_find_first(global.data_streams);
    while (!is_undefined(_key)) {
        var _stream = global.data_streams[? _key];
        if (ds_exists(_stream.list, ds_type_list)) ds_list_destroy(_stream.list);
        _key = ds_map_find_next(global.data_streams, _key);
    }
    ds_map_destroy(global.data_streams);
}

// ─────────────────────────────
// ARRAYS
// ─────────────────────────────
if (ds_exists(global.basic_arrays, ds_type_map)) {
    // Destroy each backing list…
    var _key = ds_map_find_first(global.basic_arrays);
    while (!is_undefined(_key)) {
        var _lst = global.basic_arrays[? _key];
        ds_list_destroy(_lst);
        _key = ds_map_find_next(global.basic_arrays, _key);
    }
    // Then destroy the map itself
    ds_map_destroy(global.basic_arrays);
}

// ─────────────────────────────
// LISTS
// ─────────────────────────────
if (ds_exists(global.line_list, ds_type_list)) ds_list_destroy(global.line_list);
if (ds_exists(global.line_numbers, ds_type_list)) ds_list_destroy(global.line_numbers);
if (ds_exists(global.basic_line_numbers, ds_type_list)) {
    ds_list_destroy(global.basic_line_numbers);
}

if (ds_exists(global.undo_stack, ds_type_list)) {
    while (!ds_list_empty(global.undo_stack)) {
        var _snapshot = ds_list_find_value(global.undo_stack, 0);
        if (ds_exists(_snapshot[? "global.program_lines"], ds_type_map)) ds_map_destroy(_snapshot[? "global.program_lines"]);
        if (ds_exists(_snapshot[? "global.line_numbers"], ds_type_list)) ds_list_destroy(_snapshot[? "global.line_numbers"]);
        ds_map_destroy(_snapshot);
        ds_list_delete(global.undo_stack, 0);
    }
    ds_list_destroy(global.undo_stack);
}
if (ds_exists(global.output_lines, ds_type_list)) ds_list_destroy(global.output_lines);
if (ds_exists(global.output_colors, ds_type_list)) ds_list_destroy(global.output_colors);
if (ds_exists(global.input_history, ds_type_list)) ds_list_destroy(global.input_history);

// ─────────────────────────────
// STACKS
// ─────────────────────────────
if (ds_exists(global.gosub_stack, ds_type_stack)) ds_stack_destroy(global.gosub_stack);
if (ds_exists(global.for_stack, ds_type_stack)) ds_stack_destroy(global.for_stack);
if (ds_exists(global.while_stack, ds_type_stack)) ds_stack_destroy(global.while_stack);
if (ds_exists(global.if_stack, ds_type_stack)) ds_stack_destroy(global.if_stack);

// ─────────────────────────────
// TEMPORARY LIST (used in interpreter object)
// ─────────────────────────────
if (variable_global_exists("interpreter_current_program")) {
    if (ds_exists(interpreter_current_program, ds_type_list)) {
        ds_list_destroy(interpreter_current_program);
    }
}

// ─────────────────────────────
// Buffer & State Cleanup
// ─────────────────────────────
global.print_line_buffer = "";
global.editor_spawned = false;

if (ds_exists(global.__inkey_queue, ds_type_queue)) {
    ds_queue_destroy(global.__inkey_queue);
}

/// @function basic_cmd_next(arg)
/// @description Handles BASIC NEXT loop continuation (legacy-compatible; optional inline-colon support)
function basic_cmd_next(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Entering handler with arg: '" + string(arg) + "'");

    if (!ds_exists(global.for_stack, ds_type_stack) || ds_stack_empty(global.for_stack)) {
        basic_syntax_error("NEXT without matching FOR",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_MISMATCH");
        return;
    }

    var frame = ds_stack_top(global.for_stack);

    // Optional check: NEXT I
    var user_var = string_trim(string_upper(string(arg)));
    if (user_var != "" && is_struct(frame) && variable_struct_exists(frame, "varname")) {
        if (string_upper(frame.varname) != user_var && dbg_on(DBG_FLOW)) {
            show_debug_message("NEXT: WARNING — NEXT " + user_var + " does not match active FOR var " + string(frame.varname));
        }
    }

    var varname     = frame.varname;
    var to_val      = frame.to;
    var step_val    = frame.step;
    var return_line = frame.return_line;
    var loop_line   = (variable_struct_exists(frame, "loop_line")) ? frame.loop_line : -1;
    var loop_stmt   = (variable_struct_exists(frame, "loop_stmt")) ? frame.loop_stmt : -1;

    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }

    // Re-evaluate TO / STEP each iteration if they weren’t numeric
    if (!is_real(to_val)) {
        var to_expr_local = variable_struct_exists(frame, "to_raw") ? frame.to_raw : to_val;
        to_val = basic_evaluate_expression_v2(to_expr_local);
        if (is_string(to_val)) {
            var key_to = string_upper(string_trim(to_expr_local));
            if (!ds_map_exists(global.basic_variables, key_to)) {
                basic_syntax_error("FOR ... TO must be numeric",
                    global.current_line_number, global.interpreter_current_stmt_index, "FOR_TO_NONNUM");
                return;
            }
            to_val = global.basic_variables[? key_to];
        }
        frame.to = to_val;
    }
    if (!is_real(step_val)) {
        var step_expr_local = variable_struct_exists(frame, "step_raw") ? frame.step_raw : step_val;
        step_val = basic_evaluate_expression_v2(step_expr_local);
        if (is_string(step_val)) {
            var key_step = string_upper(string_trim(step_expr_local));
            if (!ds_map_exists(global.basic_variables, key_step)) {
                // default if someone did STEP with a non-numeric symbol
                step_val = 1;
            } else {
                step_val = global.basic_variables[? key_step];
            }
        }
        frame.step = step_val;
    }

    var current = global.basic_variables[? varname];

    if (step_val == 0) {
        var inferred = (to_val >= current) ? 1 : -1;
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: STEP=0; defaulting to " + string(inferred));
        step_val = inferred;
        frame.step = step_val;
    }

    current += step_val;
    global.basic_variables[? varname] = current;

    var continue_loop = (step_val > 0) ? (current <= to_val) : (current >= to_val);
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: to=" + string(to_val)
        + " step=" + string(step_val) + " current=" + string(current)
        + " → continue=" + string(continue_loop));

    if (continue_loop) {
        var have_stmt_jump =
            variable_global_exists("interpreter_target_line") &&
            variable_global_exists("interpreter_target_stmt");

        if (have_stmt_jump && loop_line >= 0 && loop_stmt >= 0) {
            global.interpreter_target_line = loop_line;
            global.interpreter_target_stmt = loop_stmt;
            if (variable_global_exists("interpreter_use_stmt_jump")) {
                global.interpreter_use_stmt_jump = true;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Inline jump → (" + string(loop_line) + "," + string(loop_stmt) + ")");
        } else {
            global.interpreter_next_line = return_line + 1; // legacy line jump
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Legacy jump → line index " + string(global.interpreter_next_line));
        }
    } else {
        ds_stack_pop(global.for_stack);
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Loop complete — popped FOR frame");
    }
}

function basic_cmd_while(arg) {
    // Keep your original behavior & logging
    var condition = string_upper(string_trim(arg));
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Raw condition string: '" + condition + "'");

    var value = basic_evaluate_condition(condition);
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Evaluated result of '" + condition + "' → " + string(value));

    // ---- Lazy-init tiny metadata store for WHILE frames (no global file edits required)
    if (!variable_global_exists("while_meta") || !ds_exists(global.while_meta, ds_type_map)) {
        global.while_meta = ds_map_create();
    }

    if (!value) {
        // === FIX 1: robust skip ahead that inspects colon-separated statements, not only first token ===
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Condition is FALSE — skipping ahead to matching WEND");
        var _depth = 1;

        var li_max = ds_list_size(global.line_list);
        var li     = global.interpreter_current_line_index;         // current physical line index
        var stmt   = global.interpreter_current_stmt_index + 1;     // start after the WHILE header

        while (li < li_max) {
            var _ln   = ds_list_find_value(global.line_list, li);
            var code  = ds_map_find_value(global.program_map, _ln);
            var parts = split_on_unquoted_colons(string_trim(code));

            for (var p = stmt; p < array_length(parts); p++) {
                var raw  = string_trim(parts[p]);
                if (raw == "") continue;

                raw = strip_basic_remark(raw);
                var sp  = string_pos(" ", raw);
                var cmd = (sp > 0) ? string_upper(string_copy(raw, 1, sp - 1)) : string_upper(raw);

                if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: scan line " + string(_ln) + " part " + string(p) + " → " + cmd);

                if (cmd == "WHILE") {
                    _depth += 1; // nested while inside the false body we’re skipping
                } else if (cmd == "WEND") {
                    _depth -= 1;
                    if (_depth == 0) {
                        if (dbg_on(DBG_FLOW)) show_debug_message(
                            "WHILE: Found matching WEND at line index " + string(li) + ", line " + string(_ln) + ", part " + string(p)
                        );
                        // Land just AFTER this WEND colon slot
                        global.interpreter_use_stmt_jump = true;
                        global.interpreter_target_line   = li;
                        global.interpreter_target_stmt   = p + 1;
                        global.interpreter_next_line     = -1;
                        return;
                    }
                }
            }

            li   += 1;
            stmt  = 0; // from next physical line, start at first colon slot
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("?WHILE ERROR: No matching WEND found — control flow may break");
        return;
    }

    // === Condition TRUE → record minimal metadata and push loop frame as you already do ===
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Condition is TRUE — evaluating stack push logic");

    // Ensure stack exists
    if (!ds_exists(global.while_stack, ds_type_stack)) {
        global.while_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Created new while_stack");
    }

    // Only push if not already at top (preserve your logic)
    if (ds_stack_empty(global.while_stack) || ds_stack_top(global.while_stack) != line_index) {
        ds_stack_push(global.while_stack, line_index);
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Pushed line_index " + string(line_index) + " onto while_stack");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Stack already contains this line_index at top — skipping push");
    }

    // Save exact condition and the colon slot to resume the loop body after WHILE’s header
    var key = string(line_index); // key by the WHILE's physical line index
    var meta = ds_map_create();
    meta[? "cond_str"]   = string_trim(arg); // store as written on the line (not uppercased)
    meta[? "stmt_after"] = global.interpreter_current_stmt_index + 1;
    ds_map_replace(global.while_meta, key, meta);

    // Continue normally
    global.interpreter_next_line = -1;
}

/// @script basic_cmd_if
/// @description Block‐structured IF…THEN…ELSEIF…ELSE…ENDIF initializer
function basic_cmd_if(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("IF START — Raw arg: '" + arg + "'");

    // 1) Compute the current line‐list index (we assume global.interpreter_next_line was pre-incremented)
    var current_index = global.interpreter_current_line_index;

// DEBUG: Show what's in the IF block map
    if (dbg_on(DBG_FLOW))  show_debug_message("DEBUG: current_index = " + string(current_index));
    var keys = ds_map_keys_to_array(global.if_block_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (dbg_on(DBG_FLOW))  show_debug_message("DEBUG: IF block map key[" + string(i) + "] = " + string(keys[i]));
    }



    // ── Legacy inline IF?  If no block metadata exists, invoke old handler ──
    if (!ds_map_exists(global.if_block_map, current_index)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("No block metadata for line " + string(current_index) + 
                           " — falling back to INLINE IF");
        basic_cmd_if_inline(arg);
        return;
    }

    // 2) Strip off the trailing THEN and isolate the condition
    var raw     = string_trim(arg);
    var upper   = string_upper(raw);
    var then_pos = string_pos("THEN", upper);
    if (then_pos <= 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var condition_text = string_trim(string_copy(raw, 1, then_pos - 1));
    if (dbg_on(DBG_FLOW))  show_debug_message("Parsed condition: '" + condition_text + "'");

    // 3) Evaluate the condition (supporting simple AND/OR)
    var result    = false;
    var logic_op  = "";
    var upcond    = string_upper(condition_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";

    if (logic_op != "") {
        var parts = string_split(condition_text, logic_op);
        if (array_length(parts) != 2) {
            if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: Malformed " + logic_op + " condition: '" + condition_text + "'");
            return;
        }
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        if (dbg_on(DBG_FLOW))  show_debug_message("Combined condition (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(condition_text);
        if (dbg_on(DBG_FLOW))  show_debug_message("Single condition result: " + string(result));
    }

    // 4) Fetch the precomputed block‐metadata for this IF
    if (!ds_map_exists(global.if_block_map, current_index)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: No IF block metadata for line index " + string(current_index));
        return;
    }
    var blockInfo    = global.if_block_map[? current_index];
    var firstBranch  = blockInfo[? "firstBranchIndex"];

    // 5) Push a new frame onto the IF‐stack
    var frame = ds_map_create();
    ds_map_add(frame, "startIndex",      current_index);
    ds_map_add(frame, "takenBranch",     result);
    ds_map_add(frame, "firstBranchIndex", firstBranch);
    ds_map_add(frame, "endifIndex",      blockInfo[? "endifIndex"]);
    ds_map_add(frame, "elseifIndices",   blockInfo[? "elseifIndices"]);  // a ds_list of indices
    ds_map_add(frame, "elseIndex",       blockInfo[? "elseIndex"]);      // –1 if none
    ds_stack_push(global.if_stack, frame);

    // 6) Jump into THEN‐block or skip to the first ELSEIF/ELSE/ENDIF
    if (result) {
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("IF TRUE: entering THEN at index " + string(global.interpreter_next_line));
    } else {
        global.interpreter_next_line = firstBranch;
        if (dbg_on(DBG_FLOW))  show_debug_message("IF FALSE: skipping to index " + string(global.interpreter_next_line));
    }
}

// @function basic_cmd_print_mode1(arg)
/// @description MODE 1 version of PRINT that writes to the grid using cursor position
function basic_cmd_print_mode1(arg) {
    // Initialize cursor if not set
    if (!variable_global_exists("mode1_cursor_x")) global.mode1_cursor_x = 0;
    if (!variable_global_exists("mode1_cursor_y")) global.mode1_cursor_y = 0;
    
    var suppress_newline = false;
    
    // Check for trailing semicolon
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Semicolon detected, suppressing newline");
    }
    
    arg = string_trim(arg);
    if (arg == "") {
        if (!suppress_newline) {
            // Move cursor to next line
            global.mode1_cursor_x = 0;
            global.mode1_cursor_y = min(24, global.mode1_cursor_y + 1);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Empty line, cursor now at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
        }
        return;
    }
    
    var output_text = "";
    
    // Handle simple quoted strings directly
    if (string_length(arg) >= 2 && string_char_at(arg, 1) == "\"" && string_char_at(arg, string_length(arg)) == "\"") {
        output_text = string_copy(arg, 2, string_length(arg) - 2);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Simple quoted string: '" + output_text + "'");
    } else {
        // Evaluate as expression for variables, numbers, etc.
        try {
            var tokens = basic_tokenize_expression_v2(arg);
            var postfix = infix_to_postfix(tokens);
            var result = evaluate_postfix(postfix);
            output_text = string(result);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Evaluated expression '" + arg + "' to: '" + output_text + "'");
        } catch (e) {
            // If evaluation fails, treat as literal string
            output_text = arg;
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Expression failed, using literal: '" + output_text + "'");
        }
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Starting at cursor (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
    
    // Print each character at cursor position using mode1_grid_set
    for (var i = 0; i < string_length(output_text); i++) {
        var ch = ord(string_char_at(output_text, i + 1));
        
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Setting char '" + string_char_at(output_text, i + 1) + "' (code " + string(ch) + ") at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
        
        // Use mode1_grid_set to place character
        mode1_grid_set(global.mode1_cursor_x, global.mode1_cursor_y, ch, c_white, c_black);
        
        // Advance cursor
        global.mode1_cursor_x++;
        if (global.mode1_cursor_x >= 40) {
            global.mode1_cursor_x = 0;
            global.mode1_cursor_y = min(24, global.mode1_cursor_y + 1);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Wrapped to next line, cursor now at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
        }
    }
    
    if (!suppress_newline) {
        global.mode1_cursor_x = 0;
        global.mode1_cursor_y = min(24, global.mode1_cursor_y + 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Newline, cursor now at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Finished printing '" + output_text + "', cursor at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
}
/// @function mode1_scroll_grid(grid_obj, direction, amount)
/// @description Scroll the grid contents in specified direction
function mode1_scroll_grid(grid_obj, direction, amount) {
    if (!instance_exists(grid_obj)) return;
    
    var cols = 40;
    var rows = 25;
    amount = clamp(amount, 1, rows);
    
    if (dbg_on(DBG_FLOW)) show_debug_message("GRID SCROLL: " + direction + " by " + string(amount));
    
    with (grid_obj) {
        switch (string_upper(direction)) {
            case "UP":
                // Move all rows up, fill bottom with spaces
                for (var row = 0; row < rows - amount; row++) {
                    for (var col = 0; col < cols; col++) {
                        var src_i = col + (row + amount) * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                }
                // Clear bottom rows
                for (var row = rows - amount; row < rows; row++) {
                    for (var col = 0; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "DOWN":
                // Move all rows down, fill top with spaces
                for (var row = rows - 1; row >= amount; row--) {
                    for (var col = 0; col < cols; col++) {
                        var src_i = col + (row - amount) * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                }
                // Clear top rows
                for (var row = 0; row < amount; row++) {
                    for (var col = 0; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "LEFT":
                // Move all columns left, fill right with spaces
                for (var row = 0; row < rows; row++) {
                    for (var col = 0; col < cols - amount; col++) {
                        var src_i = (col + amount) + row * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                    // Clear right columns
                    for (var col = cols - amount; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "RIGHT":
                // Move all columns right, fill left with spaces
                for (var row = 0; row < rows; row++) {
                    for (var col = cols - 1; col >= amount; col--) {
                        var src_i = (col - amount) + row * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                    // Clear left columns
                    for (var col = 0; col < amount; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            default:
                if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: Unknown direction: " + direction);
                break;
        }
    }
}
/// @event obj_mode1_grid/Draw
//draw_sprite(spr_charactersheet,10,10,10);
var tile_w    = global.mode1_cell_px; // 32 (default), 16, or 8
var tile_h    = global.mode1_cell_px;
var cols      = floor(room_width  / tile_w);
var rows      = floor(room_height / tile_h);
var max_chars = sprite_get_number(global.active_font_sprite);



if (global.grid_refresh_needed) {
    global.grid_refresh_needed = false;
    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var i = col + row * cols;
            if (i < array_length(grid)) {
                grid[i].char = global.grid_refresh_char;
            }
        }
    }
}

for (var _y = 0; _y < rows; _y++) {
    for (var _x = 0; _x < cols; _x++) {
        var i = _x + _y * cols;
        if (i < array_length(grid)) {
            var tile = grid[i];
            // Draw background
            draw_set_color(tile.bg);
            draw_rectangle(
                _x * tile_w, _y * tile_h,
                (_x + 1) * tile_w, (_y + 1) * tile_h,
                false
            );
            // Draw foreground (sprite tint)
            draw_set_color(tile.fg);
            // Force proper blending
            gpu_set_blendmode(bm_normal);
            draw_set_alpha(1.0);
            var subimg = clamp(tile.char, 0, max_chars - 1);
            // Draw character sprite
            draw_sprite_ext(
                global.active_font_sprite,
                subimg,
                _x * tile_w,
                _y * tile_h,
                1, 1, 0,
                tile.fg,
                1.0
            );
            // Debug helpers (commented out)
            //if (drewfont < 5000) { show_debug_message(global.active_font_sprite); drewfont++; }
            //draw_text(_x * tile_w, _y * tile_h + tile_h - 12, string(tile.char));
        }
    }
}

//    draw_set_color(c_white);
//	draw_text(4, room_height - 40, "FONT=" + global.active_font_name + "  spr=" + string(global.active_font_sprite) + "  num=" + string(sprite_get_number(global.active_font_sprite)));
	
// Reset draw state after the loop
draw_set_color(c_white);
gpu_set_blendmode(bm_normal);

// === END MESSAGE (MODE 1 style) === //
if (global.program_has_ended) {
    // Find a good position for the message - bottom of screen, centered
    var msg = "Program ended - ESC or ENTER to return";
    var msg_chars = string_length(msg);
    var start_col = max(0, floor((cols - msg_chars) / 2)); // Center horizontally
    var msg_row = rows - 2; // Two rows from bottom
    
    // Draw message character by character using the current font sprite
    for (var i = 0; i < msg_chars; i++) {
        var char_code = ord(string_char_at(msg, i + 1));
        var char_x = (start_col + i) * tile_w;
        var char_y = msg_row * tile_h;
        
        // Draw a background highlight for better visibility
        draw_set_color(c_black);
        draw_rectangle(char_x, char_y, char_x + tile_w, char_y + tile_h, false);
        
        // Draw the character in lime color to match MODE 0
        var subimg = clamp(char_code, 0, max_chars - 1);
        draw_sprite_ext(
            global.active_font_sprite,
            subimg,
            char_x, char_y,
            1, 1, 0,
            c_lime,
            1.0
        );
    }
    
    // Reset draw state
	
}

//draw_text(10, 24, "Font: " + global.active_font_name);


// =================================================================
// MODE 1 Enhanced CLS - clear screen and reset cursor (auto 8/16/32)
// =================================================================
/// @function basic_cmd_cls_mode1()
/// @description Clears MODE 1 grid using current cell size (8/16/32) and
///              the active MODE 1 background color. Falls back to safe defaults.
///              Lazily creates the grid if missing, then resets the MODE 1 cursor.
function basic_cmd_cls_mode1() {
    // Ensure the grid exists (right after MODE 1 it might not yet)
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: No grid; creating");
        instance_create_layer(0, 0, "Instances", obj_mode1_grid);
        grid_obj = instance_find(obj_mode1_grid, 0);
        if (!instance_exists(grid_obj)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: grid creation failed; abort");
            return;
        }
    }

    // --- Determine cell size variant (8 / 16 / 32) ---
    var cell_size = 16; // safe default
    if (variable_global_exists("mode1_cell_size") && is_real(global.mode1_cell_size)) {
        cell_size = global.mode1_cell_size;
    } else {
        // Try to read from the grid instance if it stores it
        with (grid_obj) {
            if (variable_instance_exists(id, "cell_size")) {
                cell_size = cell_size; // instance var
            } else if (variable_instance_exists(id, "mode1_cell_size")) {
                cell_size = mode1_cell_size; // alternate naming
            }
        }
    }
    if (cell_size != 8 && cell_size != 16 && cell_size != 32) cell_size = 16;

    // --- Determine colors: prefer current MODE 1 bg; fallback to black ---
    var bg_col = c_black;
    var fg_col = global.basic_text_color; // keep current text default for next draw

    if (variable_global_exists("mode1_bg_color") && is_real(global.mode1_bg_color)) {
        bg_col = global.mode1_bg_color;
    } else {
        // Try to read from the grid if it tracks a bg_color
        with (grid_obj) {
            if (variable_instance_exists(id, "bg_color")) {
                bg_col = bg_color;
            }
        }
    }

    if (variable_global_exists("mode1_fg_color") && is_real(global.mode1_fg_color)) {
        fg_col = global.mode1_fg_color;
    }

    // --- Choose fill char by mode; default SPACE (32) works for all ---
    // You can customize per-size if you prefer (e.g., 0 for 8px glyph planes).
    var fill_char = 32; // SPACE

    // Apply clear to the grid
    with (grid_obj) {
        // If your grid tracks bg_color internally, refresh it first (optional)
        if (variable_instance_exists(id, "bg_color")) bg_color = bg_col;

        mode1_grid_fill(fill_char, fg_col, bg_col);
    }

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("CLS MODE1: Grid cleared (cell_size=" + string(cell_size)
            + ", fill=" + string(fill_char) + ", fg=" + string(fg_col) + ", bg=" + string(bg_col) + ")");
    }

    // Reset cursor to top-left for MODE 1
    global.mode1_cursor_x = 0;
    global.mode1_cursor_y = 0;
    if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: Cursor reset to (0,0)");
}

/// @func basic_cmd_read(arg)
/// @desc READ [@stream,] var1[, var2 ...]
///       Pulls values from pre-scanned DATA streams into variables (incl. arrays).
function basic_cmd_read(arg) {
    var s = strip_basic_remark(string_trim(arg));
    if (s == "") { 
    basic_syntax_error("READ requires variable names", 
        global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
    return; 
	}	
    // Optional @stream prefix: READ @name, A, B$
    var stream_name = "";
    var dest_text   = s;
    if (string_char_at(s, 1) == "@") {
        var _depth = 0, inq = false, cut = 0, L = string_length(s);
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") {
                var nxt = (i < L) ? string_char_at(s, i + 1) : "";
                if (inq && nxt == "\"") { i++; continue; }
                inq = !inq; continue;
            }
            if (inq) continue;
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (ch == ",") { cut = i; break; }
        }
        if (cut <= 0) { 
            basic_syntax_error("READ expected ',' after @name in '" + s + "'", 
                global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
            return; 
        }
        stream_name = string_trim(string_copy(s, 2, cut - 2)); // exclude '@'
        dest_text   = string_trim(string_copy(s, cut + 1, L - cut));
    }
    if (!ds_exists(global.data_streams, ds_type_map) || !ds_map_exists(global.data_streams, stream_name)) {
        basic_syntax_error("READ stream not found: '" + stream_name + "'", 
            global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
        return;
    }
    var stream = ds_map_find_value(global.data_streams, stream_name);
    var lst    = stream.list;
    var dests = split_on_unquoted_commas(dest_text);
    for (var di = 0; di < array_length(dests); di++) {
        if (stream.ptr >= ds_list_size(lst)) {
            var msg = "?READ ERROR: Out of DATA on stream '" + stream_name + "'";
            if (dbg_on(DBG_FLOW))  show_debug_message(msg);
            // Graceful stop: reuse your END command
            handle_basic_command("END", "");
            return;
        }
        var v = lst[| stream.ptr];
        stream.ptr++;
        var dest = string_trim(dests[di]);
        
        // NEW: Validate variable name
        if (dest == "" || !is_letter(string_char_at(dest, 1))) {
            basic_syntax_error("Invalid variable name in READ: " + dest, 
                global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
            return;
        }
        
        var rhs;
        if (is_string(v)) {
            var escaped = string_replace_all(v, "\"", "\"\"");
            rhs = "\"" + escaped + "\"";
        } else {
            rhs = string(v);
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("READ: stream='" + stream_name + "' → " + dest + "=" + rhs);
        // Route through the existing LET path so arrays etc. work
        basic_cmd_let(dest + "=" + rhs);
    }
}
/// @script basic_cmd_color
/// @description Change text color (and optional background): COLOR fg[, bg]
function basic_cmd_color(arg) {
    // Split into up to two parts: foreground and optional background
    ///
	// Split on commas, but not inside parentheses
		var parts = [];
		var current = "";
		var paren_depth = 0;
		var trimmed_arg = string_trim(arg);

		for (var i = 1; i <= string_length(trimmed_arg); i++) {
		    var ch = string_char_at(trimmed_arg, i);
		    if (ch == "(") {
		        paren_depth++;
		        current += ch;
		    } else if (ch == ")") {
		        paren_depth--;
		        current += ch;
		    } else if (ch == "," && paren_depth == 0) {
		        array_push(parts, string_trim(current));
		        current = "";
		    } else {
		        current += ch;
		    }
		}
		if (string_trim(current) != "") {
		    array_push(parts, string_trim(current));
		}
	
	///
    var fgStr = string_upper(string_trim(parts[0]));
    var bgStr = (array_length(parts) > 1)
                ? string_upper(string_trim(parts[1]))
                : "";

    // Helper: parse a single color spec (named or RGB), returns -1 on error
    var parse_color = function(colSpec) {
        // RGB(r,g,b) form?
        if (string_copy(colSpec, 1, 4) == "RGB("
            && string_char_at(colSpec, string_length(colSpec)) == ")")
        {
            var inner = string_copy(colSpec, 5, string_length(colSpec) - 5);
            var comps = string_split(inner, ",");
            if (array_length(comps) == 3) {
                var r = clamp(real(string_trim(comps[0])), 0, 255);
                var g = clamp(real(string_trim(comps[1])), 0, 255);
                var b = clamp(real(string_trim(comps[2])), 0, 255);
                return make_color_rgb(r, g, b);
            } else {
                return -1;
            }
        }
        // Named color lookup
        if (ds_map_exists(global.colors, colSpec)) {
            return global.colors[? colSpec];
        }
        return -1;
    };

    // Parse and apply foreground
    var fgCol = parse_color(fgStr);
    if (fgCol >= 0) {
        global.basic_text_color   = fgCol;
        global.current_draw_color = fgCol;
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("?COLOR ERROR: Unknown foreground color '" + fgStr + "'");
    }

    // Parse and apply background (if provided)
    if (bgStr != "") {
        var bgCol = parse_color(bgStr);
        if (bgCol >= 0) {
            global.background_draw_color   = bgCol;
            global.background_draw_enabled = true;
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("?COLOR ERROR: Unknown background color '" + bgStr + "'");
        }
    }
}

/// @function editor_handle_paste_command
// === BEGIN: editor_handle_paste_command ===
function editor_handle_paste_command() {
	
	// Prevent HTML5 from touching the clipboard API
	if (os_browser != browser_not_a_browser) {
	    show_error_message("Use :PASTE to open paste box in browser.");
	    return;
	}

	
	
    var raw_clip = clipboard_get_text();
    if (string_length(raw_clip) <= 0) {
        show_message("Clipboard is empty.");
        return;
    }

    var lines = string_split(raw_clip, "\n");
    if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: captured " + string(array_length(lines)) + " raw lines");

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);
        if (string_length(line) == 0) continue;

        // Expect: <number><space><code>
        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var line_num_str = string_copy(line, 1, space_pos - 1);
            var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            // Windows CRLF: trim trailing '\r' if present
            if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
                code_str = string_copy(code_str, 1, string_length(code_str) - 1);
            }

            if (string_digits(line_num_str) == line_num_str) {
                var line_num = real(line_num_str);

                if (line_num > 0 && string_length(code_str) > 0) {
                    // INSERT or REPLACE program text
                    ds_map_set(global.program_lines, line_num, code_str);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");

                    // Maintain ordered line number list — add only if not present
                    var idx = ds_list_find_index(global.line_numbers, line_num);
                    if (idx == -1) {
                        ds_list_add(global.line_numbers, line_num);
                        ds_list_sort(global.line_numbers, true);
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
                    } else if (dbg_on(DBG_FLOW)) {
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
                    }
                }
            }
        }
    }

    basic_show_message("Program pasted successfully.");
}
// === END: editor_handle_paste_command ===

function load_program_from(filename)
{
    // Normalize input
    filename = string_trim(filename);
    if (string_length(filename) == 0) {
        basic_show_error_message("NO FILENAME PROVIDED");
        return;
    }
    // Strip quotes if present
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename) - 2);
    }
    // Add .bas if missing
    var ext = string_lower(string_copy(filename, string_length(filename) - 3, 4));
    if (ext != ".bas") {
        filename += ".bas";
    }

    // Build full path from the same directory used by SAVE
    var file_path = get_save_directory() + filename;

    if (!file_exists(file_path)) {
        basic_show_error_message("FILE NOT FOUND: " + filename);
        return;
    }

    // Clear current program (your function should reset global.program_lines etc.)
    new_program();

    var file = file_text_open_read(file_path);
    if (file == -1) {
        basic_show_error_message("COULD NOT OPEN FILE: " + filename);
        return;
    }

    // Read file line-by-line
    while (!file_text_eof(file)) {
        var line = file_text_read_string(file);
        file_text_readln(file); // consume newline
        line = string_trim(line);

        if (string_length(line) == 0) {
            continue; // skip empties
        }

        // Split on first space to detect a numeric line number
        var sp = string_pos(" ", line);
        if (sp <= 0) {
            // No space → treat as free text; assign a synthetic line number by asking your helper,
            // or just skip if you strictly require numeric lines. Here we skip to keep behavior predictable.
            continue;
        }

        var line_num_str = string_copy(line, 1, sp - 1);
        var code_content = string_copy(line, sp + 1, string_length(line) - sp);
        var line_num = real(line_num_str);

        // Use your existing validation helpers
        if (is_line_number(line_num_str) && is_valid_line_number(line_num)) {
            // Store into your canonical container and order list
            ds_map_set(global.program_lines, line_num, code_content);
            insert_line_number_ordered(line_num);
        }
    }

    file_text_close(file);
    current_filename = filename;
    basic_show_message("LOADED: " + filename);
    update_display();
}

if (showing_dir_overlay) {
    // Basic style
    var W = display_get_gui_width();
    var H = display_get_gui_height();
    var pad = 16;
    var box_w = min(720, W - pad * 2);
    var box_h = min(520, H - pad * 2);
    var bx = (W - box_w) * 0.5;
    var by = (H - box_h) * 0.5;

    // Backdrop
    draw_set_alpha(0.60);
    draw_set_color(c_black);
    draw_rectangle(0, 0, W, H, false);

    // Panel
    draw_set_alpha(1);
    draw_set_color(make_color_rgb(24,24,24));
    draw_roundrect(bx, by, bx + box_w, by + box_h, false);
    draw_set_color(c_white);

    // Title
    var title = "FILES (↑/↓ select, Enter open, Esc close)";
    draw_text(bx + pad, by + pad, title);

    // List - use dir_listing array
    if (variable_instance_exists(id, "dir_listing") && is_array(dir_listing)) {
        var n = array_length(dir_listing);
        var row_h = 22;
        var max_rows = floor((box_h - pad*3) / row_h);
        var start = clamp(dir_sel - floor(max_rows/2), 0, max(0, n - max_rows));
        var _y = by + pad*2;

        for (var i = 0; i < max_rows && (start + i) < n; i++) {
            var idx = start + i;
            var filename = dir_listing[idx];
            
            // For HTML files, get size from global.html_dir_files
            var file_size = "? bytes";
            if (variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > idx) {
                var rec = global.html_dir_files[| idx];
                if (ds_exists(rec, ds_type_map)) {
                    file_size = string(ds_map_find_value(rec, "size")) + " bytes";
                }
            }

            // highlight selected row
            if (idx == dir_sel) {
                draw_set_color(make_color_rgb(48,96,160));
                draw_rectangle(bx + pad - 6, _y - 2, bx + box_w - pad, _y + row_h - 4, false);
                draw_set_color(c_white);
            }

            draw_text(bx + pad, _y, string(idx + 1) + ". " + string(filename) + "  (" + file_size + ")");
            _y += row_h;
        }
    }
}
/// scripts/list_saved_programs/list_saved_programs.gml
function list_saved_programs()
{
    var ed = instance_find(obj_editor, 0);
    if (ed == noone) { if (dbg_on(DBG_IO)) show_debug_message("[DIR] no obj_editor instance"); return; }

    if (!variable_instance_exists(ed, "dir_listing"))          ed.dir_listing = [];
    if (!variable_instance_exists(ed, "showing_dir_overlay"))  ed.showing_dir_overlay = false;

    var save_dir = get_save_directory();
    if (!is_string(save_dir) || string_length(save_dir) == 0) save_dir = working_directory;
    if (!directory_exists(save_dir)) directory_create(save_dir);

    // Persist save dir for actions
    ed.dir_save_dir = save_dir;

    // Build listing (.bas only)
    ed.dir_listing = [];
    var mask = save_dir + "*.bas";
    var fname = file_find_first(mask, 0); // IMPORTANT: 0 = no attribute filter
    var count = 0;
    while (fname != "") {
        array_push(ed.dir_listing, fname);
        count += 1;
        fname = file_find_next();
    }
    file_find_close();
    if (count == 0) array_push(ed.dir_listing, "No .bas files found.");

    // Initialize overlay state (ASCII UI)
    ed.dir_sel                 = 0;           // selected row (0-based in view)
    ed.dir_page                = 0;           // current page (0-based)
    ed.dir_page_size           = 1;           // will be recomputed in Draw each frame
    ed.dir_sorted_by           = "name";      // future use: "name"|"date"|"size"
    ed.dir_filter              = "";          // future filter text
    ed.dir_preview_on          = false;       // optional preview pane toggle
    ed.dir_confirm_active      = false;       // delete confirm modal
    ed.dir_confirm_index       = -1;          // which file index is pending delete
    ed.dir_mouse_hover_row     = -1;          // hover state (optional)
    ed.dir_mouse_hover_action  = "";          // ""|"load"|"del"

    ed.showing_dir_overlay = true;

    if (dbg_on(DBG_IO)) show_debug_message("[DIR] open path=" + save_dir + " files=" + string(count));
}

/// @script basic_cmd_else
/// @description Handle ELSE in a structured IF…ELSEIF…ELSE…ENDIF
function basic_cmd_else() {
    if (dbg_on(DBG_FLOW)) show_debug_message("ELSE START");

    // Guard: IF stack must exist and be non-empty
    if (!ds_exists(global.if_stack, ds_type_stack) || ds_stack_size(global.if_stack) == 0) {
        if (dbg_on(DBG_FLOW)) show_debug_message("?ELSE ERROR: ELSE without matching IF (empty IF stack)");
        return;
    }

    // Pull current IF frame (map id)
    var frame_id = ds_stack_top(global.if_stack);
    if (!ds_exists(frame_id, ds_type_map)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("?ELSE ERROR: IF frame missing/invalid map");
        return;
    }

    // Read state with safe defaults
    var taken   = ds_map_exists(frame_id, "takenBranch") ? (frame_id[? "takenBranch"]) : false;
    var endifIx = ds_map_exists(frame_id, "endifIndex")  ? (frame_id[? "endifIndex"])  : -1;

    var current_index = global.interpreter_current_line_index;

    if (taken) {
        // Already ran IF or an ELSEIF → skip ELSE body to ENDIF (if known)
        if (endifIx >= 0) {
            global.interpreter_next_line = endifIx;
            if (dbg_on(DBG_FLOW)) show_debug_message("ELSE skipping to ENDIF at index " + string(endifIx));
        } else {
            // Fallback: advance one line if ENDIF index unknown
            global.interpreter_next_line = current_index + 1;
            if (dbg_on(DBG_FLOW)) show_debug_message("ELSE: no ENDIF index; advancing to " + string(global.interpreter_next_line));
        }
    } else {
        // No branch taken yet → execute ELSE body
        ds_map_replace(frame_id, "takenBranch", true);
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW)) show_debug_message("ELSE entering branch at index " + string(global.interpreter_next_line));
    }
}

/// @event obj_mode1_grid/Create
//Create 40x25 grid for 32x32 character tiles
grid_cols = 40;
grid_rows = 25;
tile_width = 32;
tile_height = 32;

grid = array_create(grid_cols * grid_rows);

// Each grid cell will be a struct:
function make_tile_struct(char = 32, fg = c_white, bg = c_black) {
    return { char: char, fg: fg, bg: bg };
}

// Initialize all tiles
for (var i = 0; i < array_length(grid); i++) {
    grid[i] = make_tile_struct();
}

self.mode1_grid_fill = function(char, fg, bg) {
    if (dbg_on(DBG_FLOW))  show_debug_message(">> GRID FILL START: char=" + string(char) + ", fg=" + string(fg) + ", bg=" + string(bg));
    if (dbg_on(DBG_FLOW))  show_debug_message(">> Grid array length: " + string(array_length(grid)));
    
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char;
        grid[i].fg = fg;
        grid[i].bg = bg;
    }
    
    // Check first few tiles to verify they were set
    for (var i = 0; i < 3; i++) {
        if (dbg_on(DBG_FLOW))  show_debug_message(">> Tile[" + string(i) + "]: char=" + string(grid[i].char) + ", fg=" + string(grid[i].fg) + ", bg=" + string(grid[i].bg));
    }
    if (dbg_on(DBG_FLOW))  show_debug_message(">> GRID FILL END");
}

	drewfont = 0;//temp var

	// CHANGE: compute cols/rows from cell size

	grid_cols = floor(room_width  / global.mode1_cell_px); // 40 @ 32px in 1280 room
	grid_rows = floor(room_height / global.mode1_cell_px); // 25 @ 32px in 800 room


	grid = array_create(grid_cols * grid_rows);

	for (var i = 0; i < array_length(grid); i++) {
	    grid[i] = { char: 32, fg: c_white, bg: c_black };
	}

	// Ensure sprite active
	if (is_undefined(global.mode1_active_sprite)) {
	    global.mode1_active_sprite = global.font_sheets[? "DEFAULT_32"];
	}


	function basic_system_message(_msg, _color) {
	    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message START ===");
	    if (dbg_on(DBG_FLOW)) show_debug_message("Incoming message: " + string(_msg));
	    if (dbg_on(DBG_FLOW)) show_debug_message("Incoming color arg: " + string(_color));

	    // Do NOT create here — run_program owns creation.
	    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
	    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
	        if (dbg_on(DBG_FLOW)) show_debug_message("basic_system_message: output buffers not initialized; SKIPPING write.");
	        if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message END (skipped) ===");
	        return;
	    }

	    var wrap_width = 40; // keep in sync with PRINT path
	    var col = is_undefined(_color) ? global.current_draw_color : _color;
	    if (dbg_on(DBG_FLOW)) show_debug_message("Using color: " + string(col));

	    var text = string(_msg);
	    if (dbg_on(DBG_FLOW)) show_debug_message("Wrapping text: " + text);

	    while (string_length(text) > wrap_width) {
	        var chunk = string_copy(text, 1, wrap_width);
	        if (dbg_on(DBG_FLOW)) show_debug_message("Adding wrapped chunk: '" + chunk + "'");
	        ds_list_add(global.output_lines, chunk);
	        ds_list_add(global.output_colors, col);
	        text = string_delete(text, 1, wrap_width);
	    }

	   if (dbg_on(DBG_FLOW))  show_debug_message("Adding final remainder: '" + text + "'");
	    ds_list_add(global.output_lines, text);
	    ds_list_add(global.output_colors, col);

	    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message END ===");
	}

// FILE: scripts/screen_editor_commit_row/screen_editor_commit_row.gml
/// @function screen_editor_commit_row(editor_inst, _row)
function screen_editor_commit_row(editor_inst, _row) {
    with (editor_inst) {
        var line_text = string_trim(screen_editor_get_row_text(id, _row));
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Committing row " + string(_row) + ": '" + line_text + "'");
        
        if (line_text == "") return;
        
        // Check for EXIT command
        if (string_upper(line_text) == "EXIT") {
            screen_editor_exit(id);
            return;
        }
        
        // Parse line number and code
        var space_pos = string_pos(" ", line_text);
        var line_num_str = "";
        var code = "";
        
        if (space_pos > 0) {
            line_num_str = string_copy(line_text, 1, space_pos - 1);
            code = string_trim(string_copy(line_text, space_pos + 1, string_length(line_text)));
        } else {
            line_num_str = line_text;
        }
        
        // Check if it's a valid line number
        var line_num = real(line_num_str);
        if (line_num_str != "" && is_real(line_num) && line_num > 0) {
            if (code == "") {
                // Delete line
                delete_program_line(line_num);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Deleted line " + string(line_num));
            } else {
                // Add/update line
                add_or_update_program_line(line_num, code);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Added/updated line " + string(line_num) + ": " + code);
            }
        }
    }
}
function editor_html_save_program_as(filename) {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML save is only available in browser builds.");
        return false;
    }

    // Initialize the extension (safe to call each time; no-op if already inited)
    browser_file_tools_init();

    // --- Normalize filename (parity with desktop)
    filename = string_trim(filename);
    if (string_length(filename) == 0) { show_error_message("NO FILENAME PROVIDED"); return false; }
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename) - 2);
    }
    filename = string_replace_all(filename, "/",  "_");
    filename = string_replace_all(filename, "\\", "_");
    filename = string_replace_all(filename, "..", "_");
    filename = string_replace_all(filename, ".bas", "");
    filename = filename + ".bas";

    // --- Build program text
    var text = editor_html_build_program_text();
    if (string_length(text) == 0) {
        show_error_message("NOTHING TO SAVE — no program lines found");
        return false;
    }

    // --- Create byte buffer (CRLF preserved)
    var n = string_length(text);
    var buf = buffer_create(n, buffer_fixed, 1);
    for (var i = 1; i <= n; i++) {
        buffer_write(buf, buffer_u8, ord(string_char_at(text, i)));
    }
    buffer_seek(buf, buffer_seek_start, 0);

    // --- Call the YAL wrapper directly (wrapper is present in your build)
    browser_show_save_dialog(buf, filename, "text/plain; charset=utf-8", n);

    buffer_delete(buf);
    return true;
}

function editor_html_dir_prompt() {
    if (dbg_on(DBG_FLOW)) show_debug_message("[ENTER] editor_html_dir_prompt");

    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt (not browser)");
        return false;
    }

    // --- Re-entrancy guard: prevent duplicate dialogs for a single DIR dispatch
    if (!variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;
    if (global.__html_dir_opening) {
        if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] prompt suppressed (already opening)");
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt (guard)");
        return false;
    }
    global.__html_dir_opening = true;

    // --- Init extension (safe to call repeatedly)
    browser_file_tools_init();

    // --- Reset cached list (destroy old maps, clear list)
    editor_html_dir__reset();

    // --- Open dialog (multiselect = true). Accept .bas and text/plain
    browser_show_open_dialog(
        ".bas,text/plain",
        true,
        editor_html_dir__open_handler,   // persistent handler; will clear the guard
        editor_html_dir__open_filter
    );

    // Show the warning message about potential bugs using BASIC interpreter's message system
    basic_show_message("If Load fails, try again: bugs.");

    if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] open dialog shown");
    if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt");
    return true;
}
/// @func parse_data_value(raw)
/// @desc Convert a DATA token to a GML value:
///       - Quoted -> string with "" -> " unescaped
///       - Else   -> real(number) if numeric, otherwise keep as string (tolerant)
function parse_data_value(raw) {
    var s = string_trim(raw);
    var L = string_length(s);

    // Quoted string
    if (L >= 2 && string_char_at(s, 1) == "\"" && string_char_at(s, L) == "\"") {
        var inner = string_copy(s, 2, L - 2);
        inner = string_replace_all(inner, "\"\"", "\""); // unescape doubled quotes
        if (dbg_on(DBG_FLOW)) show_debug_message("parse_data_value: STRING → \"" + inner + "\" from " + s);
        return inner;
    }

    // Try numeric
    var n = real(s);
    if (string(n) == s || is_real(n)) {
        // Note: GML will give us 0 for non-numeric too; we try a tighter check:
        // If s contains any alpha (not e/E for exponent), treat as string.
        var _has_alpha = false;
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if ( (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z") ) {
                if (ch != "E" && ch != "e") { _has_alpha = true; break; }
            }
        }
        if (!_has_alpha) {
            if (dbg_on(DBG_FLOW)) show_debug_message("parse_data_value: NUMBER → " + string(n) + " from " + s);
            return n;
        }
    }

    // Fallback: keep as literal string (lets users store symbolic tokens)
    if (dbg_on(DBG_FLOW)) show_debug_message("parse_data_value: FALLBACK STRING → \"" + s + "\"");
    return s;
}

/// @script basic_cmd_gosub
function basic_cmd_gosub(arg) {
    var raw = string_trim(arg);
    var colonPos = string_pos(":", raw);
    if (colonPos > 0) raw = string_trim(string_copy(raw, 1, colonPos - 1));
    var target = real(raw);

    // Ensure gosub stack exists
    if (!ds_exists(global.gosub_stack, ds_type_stack)) {
        global.gosub_stack = ds_stack_create();
    }

    // === CHANGE: capture statement-level resume point on this same line ===
    var resume_stmt = 0;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        resume_stmt = global.interpreter_current_stmt_index + 1;  // next stmt on this line
    }
    var frame = {
        kind: "stmt",                 // mark as statement-level resume
        line_index: line_index,       // current line index
        stmt_index: resume_stmt       // next statement to run on return
    };
    ds_stack_push(global.gosub_stack, frame);

    // Jump to target line
    global.interpreter_next_line = -1;
    var listSize = ds_list_size(global.line_list);
    for (var i = 0; i < listSize; i++) {
        if (ds_list_find_value(global.line_list, i) == target) {
            global.interpreter_next_line = i;
            break;
        }
    }
    if (global.interpreter_next_line == -1) {
        basic_syntax_error("GOSUB target line not found: " + string(target),
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_TARGET");
        return;
    }
}

/// scripts/get_save_directory/get_save_directory.gml
function get_save_directory()
{
   // Check for HTML5/browser first - return empty string to skip file operations
   if (os_browser != browser_not_a_browser) {
       return ""; // HTML5 - no file system access
   }
   
   var base = "";
   
   // Handle desktop OS types
   if (os_type == os_windows) {
       var user = environment_get_variable("USERPROFILE");
       if (is_string(user) && string_length(user) > 0) {
           base = user + "\\Documents\\BasicInterpreter\\";
       }
   }
   else if (os_type == os_macosx || os_type == os_linux) {
       var home = environment_get_variable("HOME");
       if (is_string(home) && string_length(home) > 0) {
           base = home + "/Documents/BasicInterpreter/";
       }
   }
   else if (os_type == os_android) {
       base = "/storage/emulated/0/Documents/BasicInterpreter/";
   }
   else {
       // Unknown desktop OS - fallback to working directory
       base = working_directory;
   }
   
   // If env var resolution failed, fall back to working_directory
   if (!is_string(base) || string_length(base) == 0) {
       base = working_directory;
   }
   
   // Ensure trailing slash
   var last = string_copy(base, string_length(base), 1);
   if (last != "/" && last != "\\") {
       if (os_type == os_windows) base += "\\";
       else base += "/";
   }
   
   return base;
}
/// @function basic_cmd_fontset(arg)
/// @description FONTSET "<registry-key>"
function basic_cmd_fontset(arg) {
    if (global.current_mode < 1) {
        basic_print_system_message("FONTSET not implemented in MODE " + string(global.current_mode));
        return;
    }

    var key = string_upper(string_trim(arg));

    // Strip quotes if present
    if (string_length(key) >= 2) {
        var first = string_char_at(key, 1);
        var last  = string_char_at(key, string_length(key));
        if ((first == "\"" || first == "'") && first == last) {
            key = string_copy(key, 2, string_length(key) - 2);
        }
    }

    if (!ds_map_exists(global.font_sheets, key)) {
        basic_cmd_print("FONTSET: " + key + " not found", false);
        return;
    }

    // Lock the font so MODE/room init won't overwrite it
    global.active_font_name   = key;
    global.active_font_sprite = global.font_sheets[? key];
    global.font_locked        = true;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("FONTSET -> " + key
            + "  sprite=" + string(global.active_font_sprite)
            + "  subimages=" + string(sprite_get_number(global.active_font_sprite)));
    }

    // Reblank using current sheet's blank char, if you do that
    global.grid_refresh_needed = true;
}

function basic_cmd_cls() {
    if (dbg_on(DBG_FLOW)) show_debug_message("CLS: Called");
    if (dbg_on(DBG_FLOW)) show_debug_message("CLS: Current color before clear: " + string(global.current_draw_color));

    // Are we in MODE 1? Prefer explicit mode flag; fall back to grid presence.
    var in_mode1 = (variable_global_exists("current_mode") && global.current_mode == 1)
                   || instance_exists(obj_mode1_grid);

    if (in_mode1) {
        // Route to MODE 1 version (auto-detects 8/16/32 and bg color)
        basic_cmd_cls_mode1();
        if (dbg_on(DBG_FLOW)) show_debug_message("CLS: Routed to MODE 1 clear");
        return;
    }

    // --- MODE 0 (text console) clear ---
    if (ds_exists(global.output_lines, ds_type_list))  ds_list_clear(global.output_lines);
    if (ds_exists(global.output_colors, ds_type_list)) ds_list_clear(global.output_colors);

    // Reset draw color to default BASIC text color
    global.current_draw_color = global.basic_text_color;

    if (dbg_on(DBG_FLOW)) show_debug_message("CLS: Screen cleared (MODE 0)");
    if (dbg_on(DBG_FLOW)) show_debug_message("CLS: Current color reset to default: " + string(global.current_draw_color));
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function load_program_json(filename) {
    var file_path = working_directory + filename + ".json";
    
    if (!file_exists(file_path)) {
        show_error_message("JSON FILE NOT FOUND");
        return;
    }
    
    try {
        var file = file_text_open_read(file_path);
        var json_string = file_text_read_string(file);
        file_text_close(file);
        
        var loaded_map = json_decode(json_string);
        
        new_program();
        ds_map_copy(global.program_lines, loaded_map);
        
        // Rebuild line numbers list
        var key = ds_map_find_first(global.program_lines);
        while (!is_undefined(key)) {
            insert_line_number_ordered(real(key));
            key = ds_map_find_next(global.program_lines, key);
        }
        
        ds_map_destroy(loaded_map);
        basic_show_message("LOADED JSON: " + filename);
        update_display();
    } catch (e) {
        show_error_message("JSON LOAD ERROR");
    }
 }
/// @func basic_cmd_restore(arg)
/// @desc RESTORE [@stream]    — reset the read pointer to the start of the stream.
///       No arg resets the default stream "".
function basic_cmd_restore(arg) {
    var s = strip_basic_remark(string_trim(arg));
    var stream_name = "";
    // Optional @name or bare name
    if (s != "") {
        if (string_char_at(s, 1) == "@") {
            stream_name = string_trim(string_copy(s, 2, string_length(s) - 1)); // drop '@'
        } else {
            stream_name = s; // bare stream name
        }
    }
	if (!ds_exists(global.data_streams, ds_type_map) || !ds_map_exists(global.data_streams, stream_name)) {
	    basic_syntax_error("RESTORE stream not found: " + stream_name, 
	        global.current_line_number, global.interpreter_current_stmt_index, "DATA_STREAM");
	    return;
	}
    var st = ds_map_find_value(global.data_streams, stream_name);
    st.ptr = 0;
    if (dbg_on(DBG_FLOW)) {
        var cnt = ds_list_size(st.list);
        if (dbg_on(DBG_FLOW)) show_debug_message("RESTORE: stream='" + stream_name + "' ptr=0 (size=" + string(cnt) + ")");
    }
}
/// help_snapshot_program()
function help_snapshot_program() {
    // destroy any old snapshot
    if (variable_global_exists("help_snapshot_lines") && ds_exists(global.help_snapshot_lines, ds_type_map)) {
        ds_map_destroy(global.help_snapshot_lines);
    }
    if (variable_global_exists("help_snapshot_nums") && ds_exists(global.help_snapshot_nums, ds_type_list)) {
        ds_list_destroy(global.help_snapshot_nums);
    }

    // deep copy maps/lists you mutate during load/run
    global.help_snapshot_lines = ds_map_create();
    var key = ds_map_find_first(global.program_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.program_lines, key);
        ds_map_add(global.help_snapshot_lines, key, val);
        key = ds_map_find_next(global.program_lines, key);
    }

    global.help_snapshot_nums = ds_list_create();
    for (var i = 0; i < ds_list_size(global.line_numbers); i++) {
        ds_list_add(global.help_snapshot_nums, ds_list_find_value(global.line_numbers, i));
    }
}


// ===============================================
// FILE: scripts/set_full_line_text/set_full_line_text.gml  
// NEW: Helper function to store complete line text
// ===============================================

/// @function set_full_line_text(editor_inst, row, text)
function set_full_line_text(editor_inst, row, text) {
    with (editor_inst) {
        if (string_length(text) > screen_cols) {
            extended_lines[? row] = text;
           if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Stored extended line " + string(row) + ": '" + text + "'");
        } else {
            // Remove from extended storage if line is now short
            if (ds_map_exists(extended_lines, row)) {
                ds_map_delete(extended_lines, row);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Removed extended line " + string(row) + " (now fits on screen)");
            }
        }
    }
}
function reset_interpreter_state() {
    global.interpreter_running = false;
    global.program_has_ended = false;
    global.awaiting_input = false;
    global.pause_in_effect = false;
    global.pause_mode = false;
    global.input_expected = false;
    global.interpreter_input = "";
    global.interpreter_cursor_pos = 0;
    global.last_interpreter_string = "";
    
    // Reset mode if needed
    if (global.current_mode != 0) {
        global.current_mode = 0;
        room_goto(rm_basic_interpreter);
    }
    
    // Clear any program execution state
    ds_stack_clear(global.gosub_stack);
    ds_stack_clear(global.for_stack);
    ds_stack_clear(global.while_stack);
	// Clear INKEY$ queue
    if (ds_exists(global.__inkey_queue, ds_type_queue)) {
    ds_queue_clear(global.__inkey_queue);
    if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ RESET: Cleared global.__inkey_queue");
   }
}
/// @script is_function
// === BEGIN: is_function ===
function is_function(t) {
    var fn = string_upper(string_trim(t));
    return  fn == "RND"    // your original BASIC call
         || fn == "RND1"   // internal 1-arg postfix token
         || fn == "RND2"   // internal 2-arg postfix token
         || fn == "STR$"
         || fn == "CHR$"
         || fn == "LEFT$"
         || fn == "RIGHT$"
         || fn == "MID$"
         || fn == "ABS"
         || fn == "INT"
         || fn == "EXP"
         || fn == "LOG"
         || fn == "LOG10"
         || fn == "SGN"
         || fn == "SIN"
         || fn == "COS"
         || fn == "TAN"
         || fn == "REPEAT$"
         || fn == "TIMER"
         || fn == "TIME$"
         || fn == "DATE$"
         || fn == "INKEY$"
         || fn == "ASC"
		 || fn == "LEN";   // <-- added
}
// === END: is_function ===

function basic_cmd_pause() {
    if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: Execution paused. Waiting for user to press ENTER...");

    // Arm pause and reuse the INPUT pathway in Step (pause branch)
    global.pause_in_effect  = true;
    global.awaiting_input   = true;   // enables the Step's INPUT/pause branch
    global.pause_mode       = true;   // tells Draw/Step we're in PAUSE, not normal INPUT
    global.input_expected   = false;  // no variable to store
    global.input_target_var = "";     // ensure empty

    // IMPORTANT: Do NOT schedule interpreter_use_stmt_jump here.
    // The Step event (pause branch) will set interpreter_resume_stmt_index = stmt+1
    // when the user presses ENTER/ESC, which resumes at the next colon segment.
    return;
}

// FILE: scripts/start_screen_editor/start_screen_editor.gml
/// @function start_screen_editor()
/// @description Launch the full-screen C64-style editor

function start_screen_editor() {
   if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: start_screen_editor called");
    
    if (global.screen_edit_mode) {
       if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: Screen editor already active");
        basic_show_message("Screen editor already active");
        return;
    }
    
   if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: Setting screen_edit_mode = true and creating obj_screen_editor");
    global.screen_edit_mode = true;
    instance_create_layer(0, 0, "Instances", obj_screen_editor);
    
    basic_show_message("Entering screen edit mode...");
}
/// @script basic_cmd_endif
/// @description Handle ENDIF—pop IF-stack and continue
function basic_cmd_endif() {
  if (dbg_on(DBG_FLOW))  show_debug_message("ENDIF START");
    // ← GUARD: must have an open IF
    if (ds_stack_empty(global.if_stack)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ENDIF ERROR: ENDIF without matching IF");
        return;
    }
    var frame = ds_stack_pop(global.if_stack);

    var current_index = global.interpreter_current_line_index;
    // Pop and destroy the frame

    ds_map_destroy(frame);

    // Continue immediately after ENDIF
    global.interpreter_next_line = current_index + 1;
    if (dbg_on(DBG_FLOW))  show_debug_message("ENDIF done, next index " + string(global.interpreter_next_line));
}

/// @function _beep_arm_pause(ms)
/// @desc Arm a timed pause and schedule resume at the next colon segment.
function _beep_arm_pause(ms) {
    global.beep_waiting       = true;
    global.beep_release_time  = current_time + ms;

    // Pause interpreter and schedule stmt-level resume (p+1 on this line)
    global.pause_in_effect          = true;
    global.interpreter_use_stmt_jump = true;
    global.interpreter_target_line   = global.interpreter_current_line_index;
    global.interpreter_target_stmt   = global.interpreter_current_stmt_index + 1;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("BEEP: armed wait " + string(ms) + "ms; resume at stmt " + string(global.interpreter_target_stmt));
    }
}

/// help_launch()
function help_launch() {
    // Always build the help topics to ensure they're current
    help_build_topics();
    
    // Save current program state
    help_snapshot_program();
    
    // Build the help browser program
    help_build_program();
    
    // Set help active flag
    global.help_active = true;
    
    // Initialize BASIC variables if they don't exist
    if (!variable_global_exists("basic_variables")) {
        global.basic_variables = ds_map_create();
    }
    
    // Set the help done flag to false initially
    global.basic_variables[? "HELP_DONE"] = 0;
    
    // Launch the interpreter with the help program
    run_program();
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function list_program() {
    display_start_line = 0;
    update_display();
 }
 function list_program_range(range) {
    // Parse range like "10-50" or single number "10"
    var dash_pos = string_pos("-", range);
    if (dash_pos > 0) {
        var start_line = real(string_copy(range, 1, dash_pos - 1));
        var end_line = real(string_copy(range, dash_pos + 1, string_length(range)));
        list_between_lines(start_line, end_line);
    } else {
        var single_line = real(range);
        list_single_line(single_line);
    }
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function navigate_history_up() {
	
	if (global.justreturned == 1) return; // 🛑 Block history on return
	
    if (ds_list_size(global.input_history) > 0) {
        if (global.history_index == -1) {
            global.history_index = ds_list_size(global.input_history) - 1;
        } else {
            global.history_index = max(0, global.history_index - 1);
        }
        current_input = ds_list_find_value(global.input_history, global.history_index);
        cursor_pos = string_length(current_input);
    }
 }
function is_numeric_string(str) {
    if (string_length(str) == 0) return false;

    // Allow negative sign
    if (string_char_at(str, 1) == "-") {
        str = string_copy(str, 2, string_length(str));
        if (string_length(str) == 0) return false; // <- Add this
    }

    var dot_count = 0;
    for (var i = 1; i <= string_length(str); i++) {
        var c = string_char_at(str, i);
        if (c == ".") {
            dot_count++;
            if (dot_count > 1) return false;
        }
        else if (ord(c) < ord("0") || ord(c) > ord("9")) {
            return false;
        }
    }

    return true;
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function handle_program_line(input_text) {
    var space_pos = string_pos(" ", input_text);
    var line_num = real(string_copy(input_text, 1, space_pos - 1));
    var code_content = string_copy(input_text, space_pos + 1, string_length(input_text));
    
    // If no code content, delete the line
    if (string_trim(code_content) == "") {
        delete_program_line(line_num);
    } else {
        add_or_update_program_line(line_num, code_content);
    }
    
    update_display();
 }
/// @function editor_html_save_program
/// @desc HTML-only wrapper mirroring save_program()
/// Uses global current_filename (parity with desktop)
function editor_html_save_program() {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML save is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("current_filename") || string_length(current_filename) == 0) {
        show_error_message("NO FILENAME");
        return false;
    }
    return editor_html_save_program_as(current_filename);
}

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function add_to_history(input_text) {
    if (input_text != "" && (ds_list_size(global.input_history) == 0 || 
        ds_list_find_value(global.input_history, ds_list_size(global.input_history) - 1) != input_text)) {
        ds_list_add(global.input_history, input_text);
        // Limit history size
        while (ds_list_size(global.input_history) > 50) {
            ds_list_delete(global.input_history, 0);
        }
	}
 }
// ===============================================
// FILE: scripts/get_full_line_text/get_full_line_text.gml
// NEW: Helper function to get complete line text
// ===============================================

/// @function get_full_line_text(editor_inst, row)
function get_full_line_text(editor_inst, row) {
    with (editor_inst) {
        if (ds_map_exists(extended_lines, row)) {
            return extended_lines[? row];
        }
        return screen_editor_get_row_text(id, row);
    }
}
/// === BASIC_fn_INKEY$ : dequeue 1 char for INKEY$ ===
/// Returns "" if queue empty. Safe to call from evaluator/command handler.
function BASIC_fn_INKEY() {
    if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
        global.inkey_queue = ds_queue_create();
    }
    if (ds_queue_size(global.inkey_queue) > 0) {
        var _ch = ds_queue_dequeue(global.inkey_queue);
        if (is_real(_ch)) _ch = chr(_ch);
        return string(_ch);
    }
    return "";
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function add_or_update_program_line(line_num, code) {
    ds_map_set(global.program_lines, line_num, code);
    
    // Update ordered line numbers list
    var pos = ds_list_find_index(global.line_numbers, line_num);
    if (pos == -1) {
        // Insert in correct order
        insert_line_number_ordered(line_num);
    }
 }
function screen_editor_exit(editor_inst) {
    with (editor_inst) {
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Exiting screen editor");
        global.screen_edit_mode = false;
        
        // CRITICAL: Clear keyboard_string to prevent leakage to obj_editor
        keyboard_string = "";
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cleared keyboard_string");
        
        instance_destroy();
    }
}
/// @script basic_current_line_no
function basic_current_line_no() {
    if (ds_exists(global.line_list, ds_type_list)) {
        var idx = global.interpreter_current_line_index;
        if (is_real(idx) && idx >= 0 && idx < ds_list_size(global.line_list)) {
            return global.line_list[| idx];
        }
    }
    return is_undefined(global.current_line_number) ? -1 : global.current_line_number;
}
/// @description obj_inkeyfeeder/create.gml
// You can write your code in this editor
// Make sure queue exists even if we entered a different room first
if (!variable_global_exists("inkey_queue")) {
    global.__inkey_queue = ds_queue_create();
}
// Optional: if you want it to survive room switches
persistent = true;

 _CAP = 128;
/// @function paste_line(index, text)
/// @description Called by JavaScript for each line of pasted text
function paste_line(index, text) {
    ds_list_add(paste_buffer, string(text));
   if (dbg_on(DBG_FLOW)) show_debug_message("PASTE_MANAGER: Received line " + string(index) + ": " + string_copy(string(text), 1, 50) + "...");
}
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function save_program() {
    if (current_filename == "") {
        show_error_message("NO FILENAME");
        return;
    }
    save_program_as(current_filename);
 }
/// Helper function to check if a variable name is an array reference
function basic_is_array_reference(varName) {
    var open_paren = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
    return (open_paren > 0 && close_paren > open_paren);
}


// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_stat_message(msg) {
    message_text = msg;
    message_timer = 120; // Show for 2 seconds at 60 FPS
 }
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function update_display() {
    // This will be called in the Draw event
 }
 
// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_error_message(error) {
    basic_show_message("?" + error);
 }
/// @event obj_mode1_grid/Step
// You can write your code in this editor
// No active logic yet, but this is where future interactions (like SCROLL or POKE) will go.

/// @event obj_basic_interpreter/Destroy
// You can write your code in this editor
ds_list_destroy(interpreter_current_program);
/// @function inkey_enqueue_ext(sc, cap)
function inkey_enqueue_ext(sc, cap) {
    inkey_enq(chr(0) + chr(sc), cap);
}
function is_letter_or_digit(ch) {
    return is_letter(ch) || (ord(ch) >= 48 && ord(ch) <= 57);
}
/// @event obj_editor/Game End