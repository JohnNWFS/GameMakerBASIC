✅ Already Implemented (for reference)
PRINT, LET, GOTO, INPUT, IF, CLS, END, REM, FOR/NEXT, WHILE/WEND, GOSUB/RETURN, BGCOLOR, PAUSE

🔹 Easy / Low Complexity
These are standalone or single-line commands.

DATA / READ / RESTORE

DATA: Defines values in program lines.

READ: Reads values sequentially from DATA.

RESTORE: Resets the read pointer.

Would require a global.data_list, global.data_pointer, and a pass to collect DATA lines at program start.

DIM

Declares arrays. Could store in global.basic_variables as arrays (e.g., ARR(3) → ARR = [val0, val1, val2, val3]).

RANDOMIZE

Seeds the RNG, useful before calling RND.

STOP

Like END but optionally allows resuming later.

🔸 Medium Complexity
Require changes to the interpreter’s program flow or memory model.

ON GOTO / ON GOSUB

Uses a numeric expression to jump to one of several destinations.

ON X GOTO 100, 200, 300

DEF FN

Custom functions. BASIC syntax like DEF FNX(Y) = Y^2 + 1.

Likely overkill right now but doable with string parsing and token capture.

🔺 Higher Complexity
Require runtime memory allocation and indexable data access.

String functions (LEFT$, RIGHT$, MID$, LEN, CHR$, ASC)

Would require extending expression evaluator to support these.

Array math and slicing

A(1) = A(2) + A(3)

Requires robust variable parsing to differentiate between scalar and indexed access.

MODES:
Your MODE-based architecture is a **sound and extensible approach** that mirrors classic computer systems like the VIC-20, Commodore 64, and early IBM PCs. You're capturing the essence of those machines: separate modes for text vs graphics, with dedicated logic and renderers. Here's an evaluation of your plan, along with recommendations.

---

## ✅ Summary of Your Plan

### 1. **`MODE 0` (Text Mode – Current)**

* Already implemented in `rm_basic_interpreter` using `obj_basic_interpreter` and text rendering with line buffers.
* Uses string output, colors, and scrollable text.

### 2. **`MODE 1` (Tile Graphics Mode)**

* A new room or overlay object will handle graphics:

  * A **tilemap-like grid**, e.g. 40×25 of 32×32 sprites.
  * Sprites represent characters or graphical elements (frame-based sprite strip, indexed by value 0–255).
  * Controlled via new BASIC commands like `PLOT`, `DRAW`, or `CHARAT`.

### 3. **`MODE 2` (Pixel Mode)**

* True pixel access (e.g. `PSET`, `LINE`, `CIRCLE`).
* Would require surface drawing or pixel arrays.
* Ideal for dynamic pixel manipulation.

---

## 🧠 Analysis & Recommendations

### ✔ Why Your Plan Is Solid

* **Matches Retro Hardware Metaphors**: Commodore used mode switching between text (PETSCII) and bitmap. Your MODE command echoes this.
* **Modularity**: Each MODE having its own interpreter/renderer object is clean. Objects can specialize without bloating `obj_basic_interpreter`.
* **Flexible Expansion**: You could implement Mode 3, Mode 4, etc. in the future (e.g., sprite overlay, waveform audio visualization).
* **Room-based Switching**: Keeps memory and logic scoped per mode, preventing conflicts between text and graphics pipelines.

---

## 🔧 Implementation Tips

### A. MODE Command

Have `basic_cmd_mode(arg)`:

```gml
switch (real(arg)) {
    case 0: room_goto(rm_basic_interpreter); break;
    case 1: room_goto(rm_graphic_tiles); break;
    case 2: room_goto(rm_graphic_pixels); break;
}
```

Each room would include a variant of `obj_basic_interpreter` AND the appropriate drawing controller (`obj_graphics_tilemode`, `obj_graphics_pixmode`, etc.).

---

### B. MODE 1 – Tile-Based Graphics

**Setup:**

* Global 2D array or 1D ds\_grid: `global.char_grid[columns, rows]`
* Sprite: 256-frame sheet, 32×32 or 16×16 tiles
* Draw using:

```gml
draw_sprite(spr_chars, value, x * 32, y * 32);
```

**New BASIC Commands:**

* `PLOT x, y, code` – sets grid position
* `CLEAR code` – fills with a value
* `COLOR index` – sets current tile color (optional)
* `DRAWSTR x, y, "HELLO"` – auto-places characters

---

### C. MODE 2 – Pixel Graphics

**Options:**

* Use `draw_pixel`, `draw_line`, or draw on a surface
* Surface buffer for `PSET x, y, c`, `LINE x1, y1, x2, y2`, `CIRCLE x, y, r`
* Needs full coordinate access and color handling

---

### D. Object Architecture (Best Practice)

| Object                  | Role                                             |
| ----------------------- | ------------------------------------------------ |
| `obj_basic_interpreter` | Handles parsing + logic, shared across all modes |
| `obj_text_renderer`     | Present in MODE 0 room only                      |
| `obj_graphics_tilemode` | Present in MODE 1, interprets PLOT/CLEAR/CHARAT  |
| `obj_graphics_pixmode`  | Present in MODE 2, handles PSET/LINE/etc.        |

Decouple display logic from `obj_basic_interpreter`. You’ll gain more control and cleaner specialization.

---

## 📈 Suggested Command Rollout by Mode

| Command               | Mode  | Description                      |
| --------------------- | ----- | -------------------------------- |
| `MODE`                | 0,1,2 | Switch between text and graphics |
| `PLOT x, y, c`        | 1     | Set tile code at position        |
| `CHARAT x, y`         | 1     | Return tile value                |
| `PSET x, y, color`    | 2     | Set pixel                        |
| `LINE x1,y1,x2,y2`    | 2     | Draw line                        |
| `CIRCLE x, y, r`      | 2     | Draw circle                      |
| `CLEAR`               | 1,2   | Reset display                    |
| `DRAWSTR x, y, "TXT"` | 1     | Fast text in tile mode           |

---

## 📎 Optional Enhancements

* Add `GETMODE()` function (returns current mode)
* Maintain variables like `CURX`, `CURY` for drawing state
* Add `SPRITE` command in higher modes for displaying custom art

---

## 🚦 Final Verdict

**Your approach is excellent.** It's grounded in retro computing principles but adapts well to modern GameMaker workflows. Going with:

* Room-based separation
* Interpreter reuse
* Specialized render/controller objects per mode
  ...gives you a **scalable, organized framework**.

If you'd like, I can scaffold the `basic_cmd_mode()` function and a starting `obj_graphics_tilemode` with grid drawing logic and a `PLOT` command.

errors to fix:
E GM1041 The type 'String' appears where the type 'Id.DsMap' is expected. add_or_update_program_line 4:16
E GM1041 The type 'String' appears where the type 'Id.DsList' is expected. basic_cmd_cls 5:19
E GM1041 The type 'String' appears where the type 'Id.DsList' is expected. basic_cmd_print 50:21
E GM1041 The type 'Constant.Color' appears where the type 'Id.DsList' is expected. basic_cmd_print 51:21
E GM1041 The type 'String' appears where the type 'Id.DsMap' is expected. basic_run_to_console 19:38
E GM1041 The type 'String' appears where the type 'Id.DsMap' is expected. editor_handle_paste_command 26:36
W GM1062 Malformed type 'boolean' in jsdoc. is_function_token 5:35
E GM1041 The type 'String' appears where the type 'Id.DsMap' is expected. load_program_from 30:32
E GM1041 The type 'String' appears where the type 'Id.DsMap' is expected. new_program 9:18
E GM1041 The type 'String' appears where the type 'Id.DsList' is expected. obj_basic_interpreter : Step 14:40
E GM1041 The type 'String' appears where the type 'Id.DsList' is expected. obj_basic_interpreter : Step 102:36



 Immediate Options to Pick Up Again:
Here are some natural next steps from where we left off:

✔ Add next string function: LEFT$, RIGHT$, MID$

Easy to implement using string slicing.

Great test of multi-arg string functions like REPEAT$.

✔ Add VAL() or ASC()

Bridges string/number domains and useful in many BASIC programs.

✔ Resume work on PRINTAT or CLSCHAR

Finish making your grid support act like a real text console.

✔ Enhance tokenizer to safely handle comments (')

Allows inline remarks without breaking expression parsing.

✔ Improve error handling/debug trace during program run

Optional debug toggle that shows line numbers and stack state at crash.

10 PRINT "RND(1,20): " + RND(1,20)


Great question. Here’s a clean, **non-graphics** backlog for an 80s-style BASIC, grouped and prioritized. I’m only listing what’s missing vs. what you already have (PRINT/INPUT/LET/IF/WHILE/FOR/NEXT/GOTO/GOSUB/RETURN/DIM/END/PAUSE/CLS/… plus DATA/READ/RESTORE).

# Phase 1 — Low-risk, high-utility (do these next)

* **RANDOMIZE \[n] / RANDOMIZE TIMER**
  Seed `RND`. Tiny change: add `global.rand_seed` + seed GM’s RNG.
  Tests: `RANDOMIZE 1 : PRINT RND(1,10) : RANDOMIZE 1 : PRINT RND(1,10)  ' same`
* **TIMER / TIME\$ / DATE\$** (functions)
  `TIMER` returns seconds since start; `TIME$` = `"HH:MM:SS"`, `DATE$` = `"YYYY-MM-DD"`.
* **INKEY\$** (non-blocking keystroke)
  Returns `""` if none; otherwise single char. Doesn’t pause like INPUT.
* **String basics (functions)**

  * `LEN(s$)`, `INSTR(s$, sub$ [,start])`, `ASC(s$)`, `VAL(s$)`, `CHR$(n)`
  * `STRING$(n, ch$|n)`, `SPACE$(n)`, `UCASE$(s$)`, `LCASE$(s$)`, `LTRIM$(s$)`, `RTRIM$(s$)`
* **Math additions**
  `SQR(x)`, `ATN(x)` (you have SIN/COS/TAN/INT/ABS/EXP/LOG10).
* **TAB(n) / SPC(n)** for PRINT layout (no formatting engine; just emit spaces).
  (You already have `PRINTAT`—TAB/SPC makes porting easier.)

# Phase 2 — Control-flow conveniences

* **ON expr GOTO l1, l2, l3…**
  If expr=2 → GOTO l2. (1-based; out-of-range → no jump.)
* **ON expr GOSUB l1, l2, l3…**
  Same dispatch, but push return; respects your existing GOSUB stack.
* **SELECT CASE expr … CASE v / CASE ELSE … END SELECT** *(optional, QBasic-era)*
  If you want to stay strictly GW-BASIC, skip; otherwise very nice for readability.
* **STOP** (soft halt to editor)
  Equivalent to your graceful END + return to editor room.

# Phase 3 — Text file I/O (very useful for level/data files)

* **OPEN "name" FOR INPUT|OUTPUT|APPEND AS #n**
  Minimal: map `#n` → an open file handle (ds\_map).
* **LINE INPUT #n, var\$** (read a whole line)
  **INPUT #n, v1\[,v2…]** (comma-delimited fields; numbers auto-parse)
  **PRINT #n, expr \[;|, expr…]** (write line; semicolon = no newline)
* **EOF(#n)** (returns 1/0)
* **CLOSE #n**
  (We can add `FREEFILE` later; for now require `#1..#8`.)

# Phase 4 — Arrays & memory niceties

* **ERASE A \[,B…]** (release arrays)
* **OPTION BASE 0|1** *(optional; only if you want compatibility)*
  Your interpreter currently treats indices as 0-based in user code; if your array helper is 1-based internally, keep it hidden or add `OPTION BASE` later with care.
* **REDIM** *(skip for now; that’s VB-era)*

# Phase 5 — Formatting & quality-of-life (later)

* **PRINT USING** (formatted print) — powerful but non-trivial; postpone.
* **ENV\$ / COMMAND\$ / SYSTEM** — environment/exit; optional.

---

## Implementation plan (minimal ripples)

**Core dispatch:** add these keywords to `handle_basic_command`:

* `RANDOMIZE`, `ON`, `OPEN`, `LINE`, `INPUT#`, `PRINT#`, `EOF`, `CLOSE`, `STOP`, `ERASE`, `OPTION`.
  Also add `READ/RESTORE/DATA` you already whitelisted to `basic_cmd_if_inline` (you did).

**Functions (expression layer):** extend your `is_function()` and evaluator with:

* `LEN, INSTR, ASC, VAL, CHR$, STRING$, SPACE$, UCASE$, LCASE$, LTRIM$, RTRIM$, SQR, ATN, TIMER, TIME$, DATE$`.
* Keep each to a single small `case` in `evaluate_postfix`. We already showed pattern for string funcs.

**Helpers you’ll need (new tiny scripts):**

* `basic_randomize(seed_or_timer)` → seeds RNG; debug log seed.
* `basic_time_now$()` / `basic_date_now$()` / `basic_timer()`
* `basic_file_open(path, mode, chan)` / `basic_file_close(chan)`
  `basic_file_readline$(chan)` / `basic_file_eof(chan)` / `basic_file_print(chan, text)`
  Store handles in `global.file_channels` map keyed by channel int; include debug.

**Parser/flow touches (already in shape):**

* Your inline IF handler already executes THEN/ELSE segments and jumps to `stmt+1`. `ON GOTO/GOSUB` uses the same “legacy line jump” you have; zero changes to resume logic.

---

## Sanity test set for Phase 1 (no file I/O)

```
10 RANDOMIZE 1
20 PRINT "R1=";RND(1,10)
30 RANDOMIZE 1: PRINT "R2=";RND(1,10)   ' expect R1=R2

40 PRINT "LEN/INSTR=";LEN("ABC");",";INSTR("ABCABC","BC",3)   ' 3,5
50 PRINT "ASC/CHR$=";ASC("A");",";CHR$(66)                    ' 65,B
60 PRINT "VAL=";VAL("123");",";VAL("12A")                     ' 123,12 (or 12/0 per your choice)
70 PRINT "CASE=";UCASE$("aB");",";LCASE$("Xy")                ' AB,xy
80 PRINT "TRIM=";"[";LTRIM$("  X ");"][";RTRIM$("  X ");"]"   ' [X ][  X]
90 PRINT "STRING/SPACE=";"[";STRING$(3,"*");SPACE$(2);"]"     ' [***  ]

100 PRINT "SQR/ATN=";SQR(9);",";INT(ATN(1)*4)                 ' 3,3
110 PRINT "TIME/DATE=";TIME$();",";DATE$()
120 PRINT "INKEY$ test: press a key";: FOR I=1 TO 120 : K$=INKEY$ : IF K$<>"" THEN PRINT " [";K$;"]" : I=120 : ENDIF : NEXT I
130 END
```

If you want, I’ll start with **RANDOMIZE + TIMER/TIME\$/DATE\$ + INKEY\$ + LEN/INSTR/ASC/VAL/CHR\$/UCASE\$/LCASE\$/LTRIM\$/RTRIM\$/STRING\$/SPACE\$/SQR/ATN** in one pass.
Per our workflow: send me the three scripts you want patched (`handle_basic_command`, `evaluate_postfix`, and your function registry `is_function`) and I’ll return **surgical diffs with debug lines** for just those additions.

