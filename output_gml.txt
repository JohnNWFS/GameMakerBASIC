/// @file extensions/browser_file_tools/browser_file_tools.gml

#define browser_file_tools_init
global.__browser_file_tools_paste_handler = -1;
global.__browser_file_tools_paste_filter = -1;
global.__browser_file_tools_drop_handler = -1;
global.__browser_file_tools_drop_filter = -1;
global.__browser_file_tools_open_handler = -1;
global.__browser_file_tools_open_filter = -1;

#define browser_file_tools_callback_get_name
var _script = argument0;
if (_script != undefined && script_exists(_script)) {
	var _name = script_get_name(_script);
	if (string_pos("gmcallback_", _name) != 1) {
		show_error("Callback script names must start with `gmcallback_` in GMS1", 1);
		return undefined;
	}
	return _name;
} else return undefined;

#define browser_file_tools_callback_is_valid
var _func = argument0;
if (_func == undefined) return false;
// GMS >= 2.3:
if (is_method(_func)) return true;
//*/
return script_exists(_func);

#define browser_file_tools_callback_invoke3
// GMS >= 2.3:
if (is_method(argument0)) {
	var _func = argument0;
	return _func(argument1, argument2, argument3);
}
//*/
return script_execute(argument0, argument1, argument2, argument3);

#define browser_file_tools_cb_invoke
var _script = argument0;

#define gmcallback_browser_file_tools_paste_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_paste_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_paste_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_paste_filter, _data, _name, _type);

#define browser_paste_bind
/// (?handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _handler = argument_count > 0 ? argument[0] : undefined;
var _filter = argument_count > 1 ? argument[1] : undefined;
// GMS >= 2:
global.__browser_file_tools_paste_handler = _handler;
global.__browser_file_tools_paste_filter = _filter;
return browser_paste_bind_raw(
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_paste_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_paste_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_paste_bind_raw(
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define gmcallback_browser_file_tools_drop_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_drop_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_drop_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_drop_filter, _data, _name, _type);

#define browser_drop_bind
/// (?handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _handler = argument_count > 0 ? argument[0] : undefined;
var _filter = argument_count > 1 ? argument[1] : undefined;
// GMS >= 2:
global.__browser_file_tools_drop_handler = _handler;
global.__browser_file_tools_drop_filter = _filter;
return browser_drop_bind_raw(
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_drop_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_drop_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_drop_bind_raw(
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define gmcallback_browser_file_tools_open_handler
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_open_handler, _data, _name, _type);

#define gmcallback_browser_file_tools_open_filter
var _data = argument0, _name = argument1, _type = argument2;
return browser_file_tools_callback_invoke3(global.__browser_file_tools_open_filter, _data, _name, _type);

#define browser_show_open_dialog
/// (accept:string, multiselect:bool, handler_script:function<data:string;name:string;type:string;void>, ?filter_script:function<type:string;bool>)
var _accept = argument[0], _multiselect = argument[1], _handler = argument[2];
var _filter = argument_count > 3 ? argument[3] : undefined;
// GML >= 2:
global.__browser_file_tools_open_handler = _handler;
global.__browser_file_tools_open_filter = _filter;
return browser_show_open_dialog_raw(_accept, _multiselect,
	browser_file_tools_callback_is_valid(_handler) ? "gmcallback_browser_file_tools_open_handler" : undefined,
	browser_file_tools_callback_is_valid(_filter) ? "gmcallback_browser_file_tools_open_filter" : undefined,
	argument[-2], argument[-1],
);
/*/
_handler = browser_file_tools_callback_get_name(_handler);
_filter = browser_file_tools_callback_get_name(_filter);
return browser_show_open_dialog_raw(_accept,
	browser_file_tools_callback_get_name(_handler),
	browser_file_tools_callback_get_name(_filter),
	argument[-2], argument[-1],
);
//*/

#define browser_show_save_dialog
/// (buffer, name, ?type, ?size)
var _buffer = argument[0], _name = argument[1];
var _type = argument_count > 2 ? argument[2] : undefined;
var _size = argument_count > 3 ? argument[3] : buffer_get_size(_buffer);
if (_type == undefined) _type = "application/octet-stream";
return browser_show_save_dialog_raw(buffer_get_address(_buffer), _name, _type, _size);

================================================================================

/// @file objects/obj_basic_interpreter/Create_0.gml

/// @event obj_basic_interpreter/Create

    global.debug_mask        = DBG_ALL;//0;//DBG_ALL;   // start verbose; you can trim later
    global.dbg_frame_quota   = 0;      // 1200 is ~20 logs per ms at 60fps is ok; tune as needed
    global.dbg_frame_count   = 0;
    global.dbg_dropped_count = 0;

// Set the current draw color
global.current_draw_color = global.basic_text_color;

// Use the shared global data structures
global.program_map  = global.basic_program; // optional if you're not modifying
global.line_list    = global.basic_line_numbers;

// Interpreter control variables
line_index = 0;                         // current line being executed
font_height = 16;

current_input = "";
cursor_pos = 0;
last_keyboard_string = "";

global.interpreter_current_line_index = 0;
global.interpreter_next_line = -1;

// Local list to hold current run if needed
interpreter_current_program = ds_list_create(); // OK to keep local

basic_run_to_console_flag = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
    global.help_topics = ds_list_create();
} else {
    ds_list_clear(global.help_topics);
}

================================================================================

/// @file objects/obj_basic_interpreter/Destroy_0.gml

/// @event obj_basic_interpreter/Destroy
// You can write your code in this editor
ds_list_destroy(interpreter_current_program);

================================================================================

/// @file objects/obj_basic_interpreter/Draw_0.gml

/// @event obj_basic_interpreter/Draw
draw_set_font(fnt_basic);

    //draw_set_color(c_white);
	//draw_text(4, room_height - 60, "FONT=" + global.active_font_name + "  spr=" + string(global.active_font_sprite) + "  num=" + string(sprite_get_number(global.active_font_sprite)));


// === BACKGROUND === //
if (global.background_draw_enabled) {
    draw_set_color(global.background_draw_color);
    draw_rectangle(0, 0, room_width, room_height, false);
}

var font_height = string_height("A");
var visible_lines = floor(room_height / font_height) - 2;
var total_lines = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);

// === SCROLL MANAGEMENT === //
if (!global.scroll_lock && global.interpreter_running && !global.awaiting_input && !global.program_has_ended) {
    global.scroll_offset = max(0, total_lines - visible_lines);
}
global.scroll_offset = clamp(global.scroll_offset, 0, max(0, total_lines - visible_lines));

// === OUTPUT TEXT === //
var y1 = 0;
for (var i = global.scroll_offset; i < ds_list_size(global.output_lines); i++) {
    var col = (i < ds_list_size(global.output_colors)) ? global.output_colors[| i] : global.basic_text_color;
    draw_set_color(col);
    draw_text(16, y1, global.output_lines[| i]);
    y1 += font_height;
}

// === INPUT LINE OR PAUSE === //
if (global.awaiting_input) {
    draw_set_color(global.basic_text_color);
    var input_str = "";

    if (global.input_expected) {
        // We're in INPUT mode
        input_str = "? " + global.interpreter_input;
    } else {
        // We're in PAUSE mode
        input_str = global.interpreter_input;

        var curr_color = draw_get_color();
        var txt = "PAUSED...";
        var xx = room_width div 2;
        var yy = room_height div 2;

        draw_set_color(c_black);
        draw_text(xx - 1, yy - 1, txt);
        draw_text(xx + 1, yy - 1, txt);
        draw_text(xx - 1, yy + 1, txt);
        draw_text(xx + 1, yy + 1, txt);

        draw_set_color(c_yellow);
        draw_text(xx, yy, txt);

        draw_set_color(curr_color);
    }

    if (current_time mod 1000 < 500) input_str += "|";
    draw_text(16, y1, input_str);
    y1 += font_height;
}

// === END MESSAGE === //
if (global.program_has_ended) {
    draw_set_color(c_lime);
    draw_text(16, y1 + 16, "Program has ended - ESC or ENTER to return");
}


================================================================================

/// @file objects/obj_basic_interpreter/Step_0.gml

/// @event obj_basic_interpreter/Step
// ==============================
// obj_basic_interpreter → Step Event
// ==============================

// (Optional debug tap)
// if (keyboard_check_pressed(vk_enter)) {
//     show_debug_message("ENTER pressed - pause_in_effect: " + string(global.pause_in_effect) +
//                        ", awaiting_input: " + string(global.awaiting_input) +
//                        ", pause_mode: " + string(global.pause_mode));
// }

// ---------- Feed INKEY$ queue once per frame ----------
// (The function itself arbitrates INPUT vs. INKEY modal wait.)
inkey_capture_keys();

global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    if (dbg_on(DBG_PERF)) show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}

// ==============================
// Sort program lines in ascending order
// ==============================
if (ds_exists(global.line_list, ds_type_list)) {
    ds_list_sort(global.line_list, true);
}

// ==============================
// === Program Ended: Wait for user action ===
// ==============================
if (global.program_has_ended) {
    if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
    if (keyboard_check_pressed(vk_pagedown)) {
        var font_height = string_height("A");
        var visible_lines = floor(room_height / font_height) - 2;
        var total_lines = ds_list_size(global.output_lines);
        global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines - visible_lines));
    }

    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {

        // ==== INSERTED HELP RESTORE HOOK ====
        if (variable_global_exists("help_active") && global.help_active) {
            help_restore_program();   // puts the user's code back
            global.help_active = false;
        }
        // ==== END INSERT ====

        global.program_has_ended = false;
        global.current_mode = 0;

        var _ret = variable_global_exists("editor_return_room")
               ? global.editor_return_room
               : room_first; // fallback if something goes weird

        room_goto(_ret);
    }
    return;
}


// ==============================
// INPUT mode (line editor) routing — keep your working flow
// ==============================
if (global.awaiting_input) {
    if (global.pause_mode) {
        if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: ENTER/ESC detected, resuming...");
            global.awaiting_input   = false;
            global.pause_mode       = false;
            global.pause_in_effect  = false;
            global.input_target_var = "";
            global.interpreter_input = "";
            global.interpreter_resume_stmt_index = global.interpreter_current_stmt_index + 1;
        }
    } else {
        for (var _k = 32; _k <= 126; _k++) if (keyboard_check_pressed(_k)) handle_interpreter_character_input(_k);
        if (keyboard_check_pressed(vk_enter))     handle_interpreter_character_input(vk_enter);
        if (keyboard_check_pressed(vk_backspace)) handle_interpreter_character_input(vk_backspace);
    }
    return;
}

// ==============================
// INKEY$ modal wait handler (blocking GET-style)
// Armed by LET when RHS is pure INKEY$ (your basic_cmd_let should set:
//   global.inkey_waiting = true; global.pause_in_effect = true;)
// This handler captures ONE key, stashes it, and lets the same LET re-run next frame.
// ==============================
if (global.inkey_waiting) {
    // If we ALREADY have a captured char, DO NOT pause or return here.
    // Let the interpreter proceed so LET ... = INKEY$ can commit and clear flags.
    if (string_length(global.inkey_captured) > 0) {
        global.pause_in_effect = false; // allow interpreter to advance
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: resume for commit (cached='" + global.inkey_captured + "')");
        // NOTE: NO 'return' here — fall through to the interpreter loop
    } else {
        // Try to obtain exactly one key this frame
        var _ch = "";

        // Prefer queued key captured by inkey_capture_keys()
        if (ds_exists(global.__inkey_queue, ds_type_queue) && ds_queue_size(global.__inkey_queue) > 0) {
            _ch = ds_queue_dequeue(global.__inkey_queue);
            if (is_real(_ch)) _ch = chr(_ch);
        }

        // Fallback: direct pressed-edge scan this frame
        if (_ch == "") {
            for (var _kc = 32; _kc <= 126; _kc++) {
                if (keyboard_check_pressed(_kc)) { _ch = chr(_kc); break; }
            }
        }

        if (_ch != "") {
            // Stash and allow interpreter to proceed THIS frame to re-run LET
            global.inkey_captured  = string(_ch);
            global.pause_in_effect = false;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: captured '" + global.inkey_captured + "', resuming for commit");
            // NOTE: NO 'return' here — fall through to the interpreter loop
        } else {
            // Nothing yet: keep interpreter paused and try again next frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: still waiting for key");
            return; // only return when we truly don't have a key this frame
        }
    }
}

// ==============================
// Synchronize for structured IF…ELSE handling
// ==============================
global.interpreter_current_line_index = line_index;

// ==============================
// Handle Jumps (prefer legacy line jump)
// ==============================
if (global.interpreter_next_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: legacy line jump wins → line=" + string(global.interpreter_next_line));
    line_index = global.interpreter_next_line;
    global.interpreter_current_line_index = global.interpreter_next_line;
    global.interpreter_resume_stmt_index = 0;

    // Clear any stale statement-level jump
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line   = -1;
    global.interpreter_target_stmt   = 0;

    global.interpreter_next_line = -1;
} else if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: using statement-level jump → line=" + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt));
    line_index = global.interpreter_target_line;
    global.interpreter_current_line_index = global.interpreter_target_line;
    global.interpreter_resume_stmt_index = max(0, global.interpreter_target_stmt);
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line = -1;
    global.interpreter_target_stmt = 0;
    global.interpreter_next_line = -1;
}

// ==============================
// End of Program Check
// ==============================
if (line_index >= ds_list_size(global.line_list)) {
    global.interpreter_running = false;
}

// ==============================
// Execute BASIC Line
// ==============================
if (line_index < ds_list_size(global.line_list)) {
    var line_number = ds_list_find_value(global.line_list, line_index);
    var code        = ds_map_find_value(global.program_map, line_number);

    var trimmed = string_trim(code);
    var parts   = split_on_unquoted_colons(trimmed);

    global.current_line_number = line_number;
    if (dbg_on(DBG_FLOW)) show_debug_message("Running line " + string(line_number));

    var _start_stmt = 0;
    if (global.interpreter_resume_stmt_index > 0) {
        _start_stmt = global.interpreter_resume_stmt_index;
        if (dbg_on(DBG_FLOW)) show_debug_message("Resuming at statement index " + string(_start_stmt)
            + " on line " + string(line_number));
        global.interpreter_resume_stmt_index = 0;
    }

    for (var p = _start_stmt; p < array_length(parts); p++) {
        var stmt = string_trim(parts[p]);
        if (stmt == "") continue;

        var sp2  = string_pos(" ", stmt);
        var cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        var arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        // REM / apostrophe: stop the physical line
        if (cmd2 == "REM" || string_char_at(stmt, 1) == "'") {
            if (dbg_on(DBG_FLOW)) {
                show_debug_message("REM/' : stop parsing remainder of line "
                    + string(line_number) + " at part " + string(p) + "/"
                    + string(array_length(parts) - 1));
            }
            break;
        }

        // Strip inline remark then recompute verb/arg
        stmt = strip_basic_remark(stmt);
        sp2  = string_pos(" ", stmt);
        cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        global.interpreter_current_stmt_index = p;

        if (dbg_on(DBG_FLOW)) show_debug_message("Command: " + cmd2 + " | Arg: " + arg2);
        handle_basic_command(cmd2, arg2);

        // If a pause was armed (e.g., modal INKEY$), stop RIGHT HERE
        if (global.pause_in_effect) {
            global.interpreter_resume_stmt_index = p; // retry this colon slot next frame
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: engaged during statement; will retry stmt index " + string(p) + " next frame");
            break;
        }

        // Prefer legacy line jump; clear stale stmt-level flags
        if (global.interpreter_next_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for LEGACY LINE jump");
            global.interpreter_use_stmt_jump = false;
            global.interpreter_target_line   = -1;
            global.interpreter_target_stmt   = 0;
            break;
        }
        if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for STATEMENT-LEVEL jump request");
            break;
        }
    }

    // If no jump requested and NOT paused, advance to next line
    if (!(global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0)
     && !(global.interpreter_next_line >= 0)
     && !global.pause_in_effect) {
        line_index++;
    }
} else {
    global.interpreter_running = false;
}

// ==============================
// Escape Returns to Editor
// ==============================
if (keyboard_check_pressed(vk_escape)) {
    global.current_mode = 0;
    room_goto(global.editor_return_room);
}

// ==============================
// F5 Dumps BASIC to Console
// ==============================
if (keyboard_check_released(vk_f5) && basic_run_to_console_flag == false) {
    basic_run_to_console_flag = true;
    basic_run_to_console();
}

// ==============================
// Manual Scroll (Always Available)
// ==============================
if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
if (keyboard_check_pressed(vk_pagedown)) {
    var font_height2 = string_height("A");
    var visible_lines2 = floor(room_height / font_height2) - 2;
    var total_lines2 = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);
    global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines2 - visible_lines2));
}

// (Legacy path retained; harmless with new flow)
if (global.pause_in_effect && global.inkey_mode) {
    handle_inkey_input();
}
// === END: obj_basic_interpreter.Step ===


================================================================================

/// @file objects/obj_editor/Create_0.gml

/// @event obj_editor/Create
// You can write your code in this editor
 // Program storage


 // Input handling
 current_input = "";               // Current line being typed
 cursor_pos = 0;                  // Text cursor position


 input_buffer = "";               // Buffer for key repeat handling
 // Display variables
 display_start_line = 0;          // For scrolling through program
 lines_per_screen = 20;           // How many lines to show
 font_height = 16;                // Adjust based on your font
 screen_width = room_width;
 screen_height = room_height;
 // Syntax highlighting settings
 syntax_highlighting = true;      // Toggle for syntax highlighting
 keyword_color = c_blue;          // Color for BASIC keywords
 text_color = c_green;            // Default text color
 number_color = c_yellow;         // Color for line numbers
 // State management
 editor_mode = "READY";           // States: "READY", "INPUT", "RUNNING"
 current_filename = "";           // For save/load operations
 // Keyboard handling
 last_keyboard_string = "";       // Track keyboard_string changes
 key_repeat_timer = 0;            // For handling key repeat timing
 // Undo system

 max_undo_levels = 20;            // Limit undo history
 // Message system
 message_text = "";
 message_timer = 0;
 
 drag_enabled = true;
 //show_debug_message("Working directory: " + working_directory);
keyboard_string = "";

//for directory listings
showing_dir_overlay = false;
dir_listing = [];

// Overlay for HTML DIR listing
show_dir_overlay = false;   // draw toggle
dir_cursor       = 0;       // selected row (0-based)


================================================================================

/// @file objects/obj_editor/Draw_0.gml

/// @event obj_editor/Draw
// Pause regular editor drawing when screen editor is active
if (global.screen_edit_mode) {
    //if (dbg_on(DBG_FLOW)) show_debug_message("EDITOR: Screen edit mode active, pausing regular editor draw");
    exit;
}


// Set font and calculate actual height
draw_set_font(fnt_basic);
var actual_font_height = string_height("A"); // Get real font height
draw_set_color(make_color_rgb(255, 191, 64));
draw_rectangle_color(0, 0, room_width, room_height, c_black, c_black, c_black, c_black, false);

if (showing_dir_overlay) {
    // Modal backdrop
    draw_set_color(c_black);
    draw_rectangle(0, 0, room_width, room_height, false);

	draw_set_font(fnt_basic_12); // smaller font for directory overlay
	draw_set_color(c_lime);


    var x_pad = 16;
    var y_pad = 16;

	// Split header across two lines for readability
	var header1 = "DIR: " + dir_save_dir;
	var header2 = "Files: " + string(array_length(dir_listing))
	    + " | Sel: " + string(dir_sel + 1) + "/" + string(max(1, array_length(dir_listing)))
	    + " | Keys: Arrows Move  Enter=>Load  D/X=>Delete  ESC Close";

	draw_text(x_pad, y_pad, header1);
	draw_text(x_pad, y_pad + string_height("A"), header2);


    // Compute rows/page (ASCII)
    var row_h       = string_height("A");
    var top_y       = y_pad + row_h * 3;
    var bottom_y    = room_height - y_pad - row_h * 2;
    var list_height = max(row_h, bottom_y - top_y);
    var rows_per_pg = max(1, floor(list_height / row_h));
    dir_page_size   = rows_per_pg; // expose for Step input

    // Clamp selection and compute page from sel
    var total = array_length(dir_listing);
    dir_sel = clamp(dir_sel, 0, max(0, total - 1));
    var first_index = (dir_sel div rows_per_pg) * rows_per_pg;
    var last_index  = min(total - 1, first_index + rows_per_pg - 1);

    // Borders (ASCII box)
    var left_x  = x_pad;
    var right_x = room_width - x_pad;
    // top border
    draw_text(left_x, top_y - row_h, "+-------------------------------------------+");
    // list rows
    var draw_y = top_y;
    for (var i = first_index; i <= last_index; i++) {
        var idx3 = string_format(string(i + 1), 3, 0); // 001, 002...
        var name = dir_listing[i];

        // Assemble row: index, filename (trim), actions
        var action_txt = "   >  X";
        var max_name_px = (right_x - left_x) - string_width(idx3 + " ") - string_width(action_txt) - 24;
        var name_trim = name;

        // crude pixel trimming to fit line
        while (string_width(name_trim) > max_name_px && string_length(name_trim) > 3) {
            name_trim = string_copy(name_trim, 1, string_length(name_trim) - 1);
        }
        if (name_trim != name) name_trim += "...";

        var row_text = idx3 + " " + name_trim;

        // Selected row highlight (inverse via black rect + lime text)
        if (i == dir_sel) {
            draw_set_color(c_dkgray);
            draw_rectangle(left_x - 6, draw_y - 2, right_x - 6, draw_y + row_h, false);
            draw_set_color(c_lime);
        }

        draw_text(left_x, draw_y, row_text);
        // draw actions at right
        var act_x = right_x - string_width(">  X") - 16;
        draw_text(act_x, draw_y, ">  X");

        draw_y += row_h;
    }
    // bottom border
    draw_text(left_x, draw_y, "+-------------------------------------------+");

    // Paging markers
    if (first_index > 0)      draw_text(right_x - 40, top_y - row_h, "^");
    if (last_index < total-1) draw_text(right_x - 40, draw_y, "v");

    // Confirm dialog (modal)
    if (dir_confirm_active) {
        var cx = room_width  div 2;
        var cy = room_height div 2;
        var w  = 520;
        var h  = row_h * 4;
        var l  = cx - w div 2;
        var t  = cy - h div 2;
        var r  = cx + w div 2;
        var b  = cy + h div 2;

        draw_set_color(c_black);
        draw_rectangle(l, t, r, b, false);
        draw_set_color(c_lime);

        var _nm = (dir_confirm_index >= 0 && dir_confirm_index < total) ? dir_listing[dir_confirm_index] : "";
        draw_text(l + 12, t + row_h, "Delete \"" + _nm + "\" ?");
        draw_text(l + 12, t + row_h * 2, "[Y]es  [N]o");

        // Note: modal—input handled in Step; draw only here
    }

    // Short help/footer
    draw_set_color(c_dkgray);
    draw_text(x_pad, room_height - row_h - y_pad, "(ASCII dir) Load: Enter/>   Delete: D/X (Desktop only)   Close: ESC");

    return; // overlay draws above everything
}


// Draw program lines with proper spacing
var y_pos = 32;
var lines_shown = 0;
var total_lines = ds_list_size(global.line_numbers);

// Calculate how many lines fit on screen
var available_height = room_height - 128; // Leave space for prompt and messages
var max_lines = floor(available_height / actual_font_height);

for (var i = display_start_line; i < total_lines && lines_shown < max_lines; i++) {
    var line_num = ds_list_find_value(global.line_numbers, i);
    var code = ds_map_find_value(global.program_lines, line_num);
    var display_text = string(line_num) + " " + code;
    
    draw_text(16, y_pos, display_text);
    y_pos += actual_font_height; // Use actual font height
    lines_shown++;
}

// Draw input prompt with proper spacing
draw_text(16, room_height - (actual_font_height * 2), "READY");
draw_text(16, room_height - actual_font_height, "> " + current_input);

// Draw cursor
var cursor_x = 16 + string_width("> " + string_copy(current_input, 1, cursor_pos));
if (current_time % 1000 < 500) { // Blinking cursor
    draw_text(cursor_x, room_height - actual_font_height, "_");
}

// Draw message with proper spacing
if (message_text != "") {
    draw_set_color(c_yellow);
    draw_text(16, room_height - (actual_font_height * 3), message_text);
    draw_set_color(make_color_rgb(255, 191, 64)); // Reset color
}

================================================================================

/// @file objects/obj_editor/Draw_64.gml

if (showing_dir_overlay) {
    // Basic style
    var W = display_get_gui_width();
    var H = display_get_gui_height();
    var pad = 16;
    var box_w = min(720, W - pad * 2);
    var box_h = min(520, H - pad * 2);
    var bx = (W - box_w) * 0.5;
    var by = (H - box_h) * 0.5;

    // Backdrop
    draw_set_alpha(0.60);
    draw_set_color(c_black);
    draw_rectangle(0, 0, W, H, false);

    // Panel
    draw_set_alpha(1);
    draw_set_color(make_color_rgb(24,24,24));
    draw_roundrect(bx, by, bx + box_w, by + box_h, false);
    draw_set_color(c_white);

    // Title
    var title = "FILES (↑/↓ select, Enter open, Esc close)";
    draw_text(bx + pad, by + pad, title);

    // List - use dir_listing array
    if (variable_instance_exists(id, "dir_listing") && is_array(dir_listing)) {
        var n = array_length(dir_listing);
        var row_h = 22;
        var max_rows = floor((box_h - pad*3) / row_h);
        var start = clamp(dir_sel - floor(max_rows/2), 0, max(0, n - max_rows));
        var _y = by + pad*2;

        for (var i = 0; i < max_rows && (start + i) < n; i++) {
            var idx = start + i;
            var filename = dir_listing[idx];
            
            // For HTML files, get size from global.html_dir_files
            var file_size = "? bytes";
            if (variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > idx) {
                var rec = global.html_dir_files[| idx];
                if (ds_exists(rec, ds_type_map)) {
                    file_size = string(ds_map_find_value(rec, "size")) + " bytes";
                }
            }

            // highlight selected row
            if (idx == dir_sel) {
                draw_set_color(make_color_rgb(48,96,160));
                draw_rectangle(bx + pad - 6, _y - 2, bx + box_w - pad, _y + row_h - 4, false);
                draw_set_color(c_white);
            }

            draw_text(bx + pad, _y, string(idx + 1) + ". " + string(filename) + "  (" + file_size + ")");
            _y += row_h;
        }
    }
}

================================================================================

/// @file objects/obj_editor/Other_3.gml

/// @event obj_editor/Game End

================================================================================

/// @file objects/obj_editor/Step_0.gml

/// @event obj_editor/Step
// Pause regular editor when screen editor is active
if (global.screen_edit_mode) {
    //if (dbg_on(DBG_FLOW)) show_debug_message("EDITOR: Screen edit mode active, pausing regular editor");
    exit;
}

if (global.justreturned == 1) {
    current_input = "";
    cursor_pos = 0;
    keyboard_string = "";
    global.justreturned = 0;
    exit; // skip the rest of this Step event
}

// === DIRECTORY OVERLAY INPUT (ASCII) ===
if (showing_dir_overlay) {

    // Close overlay on ESC (unless confirm is up)
    if (!dir_confirm_active && keyboard_check_pressed(vk_escape)) {
        showing_dir_overlay = false;
        dir_listing = [];
        if (dbg_on(DBG_FLOW)) show_debug_message("[DIR] close overlay (ESC)");
        exit;
    }

    // Guard page_size (Draw recalculates each frame)
    if (dir_page_size < 1) dir_page_size = 1;

    var _count = array_length(dir_listing);
    if (_count <= 0) { exit; } // nothing to do

    // Clamp selection to list
    dir_sel = clamp(dir_sel, 0, max(0, _count - 1));

    // If confirm dialog active: handle Y/N only; block other inputs
    if (dir_confirm_active) {
        if (keyboard_check_pressed(ord("Y"))) {
            // Delete (desktop only)
            if (os_type != os_browser) {
                var _name = dir_listing[dir_confirm_index];
                var _path = dir_save_dir + _name;
                if (file_exists(_path)) {
                    if (dbg_on(DBG_IO)) show_debug_message("[DIR] delete " + _path);
                    file_delete(_path);
                }
                // refresh list
                list_saved_programs(); // re-enter overlay with fresh state
            } else {
                if (dbg_on(DBG_IO)) show_debug_message("[DIR] delete disabled on HTML5");
                dir_confirm_active = false;
            }
        }
        if (keyboard_check_pressed(ord("N")) || keyboard_check_pressed(vk_escape)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("[DIR] delete cancelled");
            dir_confirm_active = false;
        }
        exit; // modal consumes input
    }

    // NAVIGATION
    if (keyboard_check_pressed(vk_home))  dir_sel = 0;
    else if (keyboard_check_pressed(vk_end))   dir_sel = max(0, _count - 1);
    else if (keyboard_check_pressed(vk_up))    dir_sel = max(0, dir_sel - 1);
    else if (keyboard_check_pressed(vk_down))  dir_sel = min(_count - 1, dir_sel + 1);
    else if (keyboard_check_pressed(vk_pageup))   dir_sel = max(0, dir_sel - dir_page_size);
    else if (keyboard_check_pressed(vk_pagedown)) dir_sel = min(_count - 1, dir_sel + dir_page_size);

    // ACTIONS
    // Load on ENTER or '>' key
// Load on ENTER or '>' key
if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(ord(">"))) {
    var _name = dir_listing[dir_sel];
    if (_name != "No .bas files found.") {
        // Check if this is an HTML file list (has global.html_dir_files data)
        if (os_browser != browser_not_a_browser && variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > 0) {
            // HTML version - load from memory
            if (dbg_on(DBG_IO)) show_debug_message("[DIR] HTML load: " + _name + " at index " + string(dir_sel + 1));
            var success = editor_html_dir_open(string(dir_sel + 1));
            if (success) {
                showing_dir_overlay = false;
                dir_listing = [];
                global.justreturned = 1;
            } else {
                basic_show_message("Failed to load file from memory");
            }
            exit;
        } else {
            // Windows version - load from disk
            var _path = dir_save_dir + _name;
            if (file_exists(_path)) {
                if (dbg_on(DBG_IO)) show_debug_message("[DIR] load " + _path);
                load_program_from_path(_path, _name);
                showing_dir_overlay = false;
                dir_listing = [];
                global.justreturned = 1;
                exit;
            } else {
                basic_show_message("File not found");
            }
        }
    }
}

    // Delete on 'D', 'X', or Delete key (desktop only)
    if (os_browser != browser_not_a_browser) {
        if (keyboard_check_pressed(ord("D")) || keyboard_check_pressed(ord("X")) || keyboard_check_pressed(vk_delete)) {
            if (_count > 0 && dir_listing[dir_sel] != "No .bas files found.") {
                dir_confirm_active = true;
                dir_confirm_index  = dir_sel;
                if (dbg_on(DBG_FLOW)) show_debug_message("[DIR] confirm delete idx=" + string(dir_sel));
            }
        }
    }

    // NOTE: Do not let base editor input run while overlay is active
    exit;
}





// Handle Enter key
if (keyboard_check_pressed(vk_enter)) {
    add_to_history(current_input);
    process_input_line(current_input);
    current_input = "";
    cursor_pos = 0;
    global.history_index = -1;
    input_buffer = keyboard_string; // reset keyboard buffer
}

 else if (keyboard_check_released(vk_backspace)) {
    if (cursor_pos > 0) {
        current_input = string_delete(current_input, cursor_pos, 1);
        cursor_pos--;
    }
 }
 else if (keyboard_check_pressed(vk_left)) {
    cursor_pos = max(0, cursor_pos - 1);
 }
 else if (keyboard_check_pressed(vk_right)) {
    cursor_pos = min(string_length(current_input), cursor_pos + 1);
 }
 else if (keyboard_check_pressed(vk_up)) {
    navigate_history_up();
 }
 else if (keyboard_check_pressed(vk_down)) {
    navigate_history_down();
 }
 else if (keyboard_check_pressed(vk_pageup)) {
    display_start_line = max(0, display_start_line - lines_per_screen);
 }
 else if (keyboard_check_pressed(vk_pagedown)) {
    var max_start = max(0, ds_list_size(global.line_numbers) - lines_per_screen);
    display_start_line = min(max_start, display_start_line + lines_per_screen);
 }
 else if (keyboard_check(vk_control) && keyboard_check_pressed(ord("Z"))) {
    undo_last_change();
 }
 else if (keyboard_check(vk_f5)) {
    dump_program_to_console();
	basic_show_message("Dumped program to Console");	 
 }
 else {
    // Handle character input with repeat
    handle_character_input();
 }
 
  // In Step Event
 if (message_timer > 0) {
    message_timer--;
    if (message_timer <= 0) {
        message_text = "";
    }
 }
 


================================================================================

/// @file objects/obj_globals/Create_0.gml

/// @event obj_globals/Create
// obj_globals → Create Event



var save_dir = get_save_directory();
if (save_dir != "") {
    if (!directory_exists(save_dir)) {
        directory_create(save_dir);
    }
}

//global.debug_mask = DBG_ALL;// allow all debug;
global.debug_mask = 0; //No Debug

global.dbg_dropped_count = 0;

global.justreturned = 0;
global.program_filename = "";
global.username = "";
global.editor_spawned = false;

// Program and source management
global.program_lines = ds_map_create();
global.basic_program = ds_map_create();
global.program_map  = ds_map_create();

// Line tracking
global.line_list    = ds_list_create();
global.line_numbers = ds_list_create();
global.undo_stack = ds_list_create();
global.output_lines = ds_list_create();
global.output_colors = ds_list_create();
global.input_history = ds_list_create();

// Interpreter control stacks
global.gosub_stack = ds_stack_create();
global.for_stack   = ds_stack_create();
global.while_stack = ds_stack_create();
global.history_index = -1;

// IF…ELSE block handling
global.if_block_map = ds_map_create();
global.if_stack     = ds_stack_create();

// Spawn the editor after globals are ready
instance_create_layer(0, 0, "Instances", obj_editor);

// Initialize variable store
if (!variable_global_exists("basic_variables")) {
    global.basic_variables = ds_map_create();
}

// Output buffer
global.print_line_buffer = "";

// Color settings
global.basic_text_color = make_color_rgb(255, 191, 64);
global.current_draw_color = c_green;
global.background_draw_color = c_black;
global.background_draw_enabled = false;

// Input / Pause
global.awaiting_input = false;
global.input_target_var = "";
global.interpreter_input = "";
global.interpreter_cursor_pos = 0;
global.interpreter_running = false;
global.last_interpreter_string = "";
global.program_has_ended = false;
global.pause_in_effect = false;
global.input_expected = false;
global.pause_mode = false;

// Scrolling control
global.scroll_offset = 0;
global.scroll_lock = false;

// Named colors
global.colors = ds_map_create();
global.colors[? "RED"]     = c_red;
global.colors[? "GREEN"]   = c_green;
global.colors[? "BLUE"]    = c_blue;
global.colors[? "CYAN"]    = c_teal;
global.colors[? "MAGENTA"] = c_fuchsia;
global.colors[? "YELLOW"]  = c_yellow;
global.colors[? "WHITE"]   = c_white;
global.colors[? "BLACK"]   = c_black;
global.colors[? "GRAY"]    = c_gray;
global.colors[? "ORANGE"]  = c_orange;
global.colors[? "LIME"]    = c_lime;
global.colors[? "NAVY"] = make_color_rgb(0, 0, 128);
global.colors[? "DKGRAY"] = make_color_rgb(64, 64, 64);

// MODE control
global.current_mode = 0; // 0 = Text, 1 = Tile graphics, 2 = Pixel graphics
global.mode_rooms = ds_map_create();
global.mode_rooms[? 0] = rm_basic_interpreter; // Text
global.mode_rooms[? 1] = rm_mode1_graphics;    // Tile graphics
global.mode_rooms[? 2] = rm_mode2_pixel;       // Pixel graphics

// MODE 1 sprite sheet container
// FONT registry for MODE 1
global.font_sheets = ds_map_create();

// Base character sheet
ds_map_add(global.font_sheets, "DEFAULT", spr_charactersheet);

// Special 32×32 or alt glyphs
ds_map_add(global.font_sheets, "SPECIAL", spr_charactersheet_special);

// 16×16 set
ds_map_add(global.font_sheets, "16x16", spr_charactersheet_16x16);
ds_map_add(global.font_sheets, "16x16_SPECIAL", spr_charactersheet_16x16_special);

// 8×8 set
ds_map_add(global.font_sheets, "8x8", spr_charactersheet_8x8);
ds_map_add(global.font_sheets, "DEFAULT_32", spr_charactersheet);
ds_map_add(global.font_sheets, "DEFAULT_16", spr_charactersheet_16x16);
ds_map_add(global.font_sheets, "DEFAULT_8",  spr_charactersheet_8x8);

ds_map_add(global.font_sheets, "SPECIAL_16", spr_charactersheet_16x16_special);

// Initialize active sheet
global.mode1_active_sprite   = global.font_sheets[? "DEFAULT_32"];
global.mode1_active_font_key = "DEFAULT_32";
global.mode1_cell_px         = 32;

global.active_font_name = "DEFAULT";
global.active_font_sprite = global.font_sheets[? global.active_font_name];

global.grid_refresh_needed = false;
global.grid_refresh_char = 32;

global.basic_arrays = ds_map_create(); // name (string) → ds_list

global.interpreter_target_line = -1;
global.interpreter_target_stmt = 0;
global.interpreter_use_stmt_jump = false;
global.interpreter_resume_stmt_index = 0;

global.interpreter_current_stmt_index = 0;

global.config = ds_map_create();
global.config[? "max_line_number"] = 65535;
global.config[? "max_history_size"] = 50;


// === DATA/READ globals ===
// Create once; the builder will clear/reuse it each run.
if (!variable_global_exists("data_streams") || !ds_exists(global.data_streams, ds_type_map)) {
    global.data_streams = ds_map_create();
    if (dbg_on(DBG_FLOW)) show_debug_message("globals: created global.data_streams");
}


if (!variable_global_exists("__inkey_queue")) {
    global.__inkey_queue = ds_queue_create();
}

global.inkey_mode = false; 
global.pause_in_effect = false; 
global.inkey_waiting    = false;
global.inkey_captured   = "";
global.inkey_target_var = "";
global.interpreter_current_line_index = 0; 

// Archival copy of line numbers used by run_program
global.basic_line_numbers = ds_list_create();
global._syntax_error_just_emitted = false;

// optional, if you use these
global._validator_header_emitted = false;
global._abort_after_validation   = false;

// Where to return when leaving the interpreter
global.editor_return_room = room; // whatever room the editor lives in at startup

global.config[? "show_error_hints"] = true; // show compact help lines under syntax errors

global.screen_edit_mode = false; //for scree editing
if (dbg_on(DBG_FLOW)) show_debug_message("GLOBALS: screen_edit_mode initialized to false");


/// Put near your other globals the first time you use them:
if (!variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;
if (!variable_global_exists("__html_dir_open_time")) global.__html_dir_open_time = 0;

if (!variable_global_exists("DEBUG_INPUT")) global.DEBUG_INPUT = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }
	
	

================================================================================

/// @file objects/obj_globals/Other_3.gml

/// @event obj_globals/Game_End
global.inkey_mode = false;
// ─────────────────────────────
// MAPS
// ─────────────────────────────
if (ds_exists(global.basic_variables, ds_type_map)) ds_map_destroy(global.basic_variables);
if (ds_exists(global.program_lines, ds_type_map)) ds_map_destroy(global.program_lines);
if (ds_exists(global.basic_program, ds_type_map)) ds_map_destroy(global.basic_program);
if (ds_exists(global.program_map, ds_type_map)) ds_map_destroy(global.program_map);
if (ds_exists(global.colors, ds_type_map)) ds_map_destroy(global.colors);
if (ds_exists(global.if_block_map, ds_type_map)) {
    var _key = ds_map_find_first(global.if_block_map);
    while (!is_undefined(_key)) {
        var _info = global.if_block_map[? _key];
        if (ds_exists(_info[? "elseifIndices"], ds_type_list)) ds_list_destroy(_info[? "elseifIndices"]);
        ds_map_destroy(_info);
        _key = ds_map_find_next(global.if_block_map, _key);
    }
    ds_map_destroy(global.if_block_map);
}
if (ds_exists(global.mode_rooms, ds_type_map)) ds_map_destroy(global.mode_rooms);
if (ds_exists(global.font_sheets, ds_type_map)) ds_map_destroy(global.font_sheets);
if (ds_exists(global.config, ds_type_map)) ds_map_destroy(global.config);
if (ds_exists(global.data_streams, ds_type_map)) {
    var _key = ds_map_find_first(global.data_streams);
    while (!is_undefined(_key)) {
        var _stream = global.data_streams[? _key];
        if (ds_exists(_stream.list, ds_type_list)) ds_list_destroy(_stream.list);
        _key = ds_map_find_next(global.data_streams, _key);
    }
    ds_map_destroy(global.data_streams);
}

// ─────────────────────────────
// ARRAYS
// ─────────────────────────────
if (ds_exists(global.basic_arrays, ds_type_map)) {
    // Destroy each backing list…
    var _key = ds_map_find_first(global.basic_arrays);
    while (!is_undefined(_key)) {
        var _lst = global.basic_arrays[? _key];
        ds_list_destroy(_lst);
        _key = ds_map_find_next(global.basic_arrays, _key);
    }
    // Then destroy the map itself
    ds_map_destroy(global.basic_arrays);
}

// ─────────────────────────────
// LISTS
// ─────────────────────────────
if (ds_exists(global.line_list, ds_type_list)) ds_list_destroy(global.line_list);
if (ds_exists(global.line_numbers, ds_type_list)) ds_list_destroy(global.line_numbers);
if (ds_exists(global.basic_line_numbers, ds_type_list)) {
    ds_list_destroy(global.basic_line_numbers);
}

if (ds_exists(global.undo_stack, ds_type_list)) {
    while (!ds_list_empty(global.undo_stack)) {
        var _snapshot = ds_list_find_value(global.undo_stack, 0);
        if (ds_exists(_snapshot[? "global.program_lines"], ds_type_map)) ds_map_destroy(_snapshot[? "global.program_lines"]);
        if (ds_exists(_snapshot[? "global.line_numbers"], ds_type_list)) ds_list_destroy(_snapshot[? "global.line_numbers"]);
        ds_map_destroy(_snapshot);
        ds_list_delete(global.undo_stack, 0);
    }
    ds_list_destroy(global.undo_stack);
}
if (ds_exists(global.output_lines, ds_type_list)) ds_list_destroy(global.output_lines);
if (ds_exists(global.output_colors, ds_type_list)) ds_list_destroy(global.output_colors);
if (ds_exists(global.input_history, ds_type_list)) ds_list_destroy(global.input_history);

// ─────────────────────────────
// STACKS
// ─────────────────────────────
if (ds_exists(global.gosub_stack, ds_type_stack)) ds_stack_destroy(global.gosub_stack);
if (ds_exists(global.for_stack, ds_type_stack)) ds_stack_destroy(global.for_stack);
if (ds_exists(global.while_stack, ds_type_stack)) ds_stack_destroy(global.while_stack);
if (ds_exists(global.if_stack, ds_type_stack)) ds_stack_destroy(global.if_stack);

// ─────────────────────────────
// TEMPORARY LIST (used in interpreter object)
// ─────────────────────────────
if (variable_global_exists("interpreter_current_program")) {
    if (ds_exists(interpreter_current_program, ds_type_list)) {
        ds_list_destroy(interpreter_current_program);
    }
}

// ─────────────────────────────
// Buffer & State Cleanup
// ─────────────────────────────
global.print_line_buffer = "";
global.editor_spawned = false;

if (ds_exists(global.__inkey_queue, ds_type_queue)) {
    ds_queue_destroy(global.__inkey_queue);
}


================================================================================

/// @file objects/obj_globals/Other_62.gml

/// @event obj_globals/Async - HTTP
// This event only triggers when an HTTP request completes
// async_load is automatically valid here

var req_id = ds_map_find_value(async_load, "id");
if (!variable_global_exists("http_tags")) exit;
if (!ds_map_exists(global.http_tags, req_id)) exit;

var tag  = ds_map_find_value(global.http_tags, req_id);
var stat = ds_map_find_value(async_load, "status"); // 0 = OK
var body = ds_map_find_value(async_load, "result");

// Clean up the tag immediately
ds_map_delete(global.http_tags, req_id);

if (tag == ":LOADURL") {
    if (stat == 0 && is_string(body)) {
        var n = editor_import_text_to_program(body);
        show_error_message("Imported " + string(n) + " line(s) from URL.");
    } else {
        var sc = ds_map_find_value(async_load, "http_status");
        show_error_message("LOADURL failed (status=" + string(sc) + ").");
    }
}

================================================================================

/// @file objects/obj_globals/Step_0.gml

/// @event obj_globals/Step
if (room == rm_editor) {
    if (!instance_exists(obj_editor)) {
        instance_create_layer(0, 0, "Instances", obj_editor);
    }
}


================================================================================

/// @file objects/obj_inkey_feeder/Create_0.gml

/// @description obj_inkeyfeeder/create.gml
// You can write your code in this editor
// Make sure queue exists even if we entered a different room first
if (!variable_global_exists("inkey_queue")) {
    global.__inkey_queue = ds_queue_create();
}
// Optional: if you want it to survive room switches
persistent = true;


================================================================================

/// @file objects/obj_inkey_feeder/Step_0.gml

/// @event obj_inkey_feeder/Step
if (os_browser != browser_not_a_browser) exit;
// === EARLY EXIT GUARDS ===
var _is_editor_room =
    (variable_global_exists("editor_return_room") && room == global.editor_return_room)
 || (variable_global_exists("editor_room") && room == global.editor_room)
 || (asset_get_index("rm_editor") != -1 && room == asset_get_index("rm_editor"))
 || instance_exists(obj_editor);

if (_is_editor_room) { keyboard_string = ""; exit; }
if (variable_global_exists("interpreter_running") && !global.interpreter_running) { keyboard_string = ""; exit; }

// === Ensure queue exists ===
if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
    global.inkey_queue = ds_queue_create();
}

// Capacity-aware enqueue (pass cap explicitly to avoid scope issues)
var _enq = function(val, cap) {
    while (ds_queue_size(global.inkey_queue) >= cap) ds_queue_dequeue(global.inkey_queue);
    ds_queue_enqueue(global.inkey_queue, val);
    if (dbg_on(DBG_PARSE)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("##KEYFEED## ENQ='" + string(val) + "'"
            + " A1=" + string((is_string(val) && string_length(val)>=1) ? ord(string_char_at(val,1)) : -1)
            + " A2=" + string((is_string(val) && string_length(val)>=2) ? ord(string_char_at(val,2)) : -1));
    }
};
var _CAP = 128;

// === 1) DISPLAYABLE TEXT (letters, digits, punctuation, space, shifted forms) ===
if (keyboard_string != "") {
    var s = keyboard_string;
    var n = string_length(s);
    for (var i = 1; i <= n; i++) {
        _enq(string_char_at(s, i), _CAP);
    }
    keyboard_string = "";
}

// === 2) STANDARD CONTROL KEYS (single-char control codes) ===
if (keyboard_check_pressed(vk_enter))     _enq(chr(13), _CAP); // Enter
if (keyboard_check_pressed(vk_tab))       _enq(chr(9),  _CAP); // Tab
if (keyboard_check_pressed(vk_backspace)) _enq(chr(8),  _CAP); // Backspace
if (keyboard_check_pressed(vk_escape))    _enq(chr(27), _CAP); // Escape

// === 3) NUMPAD DIGITS (show up even if keyboard_string doesn't) ===
if (keyboard_check_pressed(vk_numpad0)) _enq("0", _CAP);
if (keyboard_check_pressed(vk_numpad1)) _enq("1", _CAP);
if (keyboard_check_pressed(vk_numpad2)) _enq("2", _CAP);
if (keyboard_check_pressed(vk_numpad3)) _enq("3", _CAP);
if (keyboard_check_pressed(vk_numpad4)) _enq("4", _CAP);
if (keyboard_check_pressed(vk_numpad5)) _enq("5", _CAP);
if (keyboard_check_pressed(vk_numpad6)) _enq("6", _CAP);
if (keyboard_check_pressed(vk_numpad7)) _enq("7", _CAP);
if (keyboard_check_pressed(vk_numpad8)) _enq("8", _CAP);
if (keyboard_check_pressed(vk_numpad9)) _enq("9", _CAP);

// === 4) EXTENDED KEYS (QBASIC style: CHR$(0)+CHR$(scan)) ===
var _enqueue_ext = function(sc) { _enq(chr(0) + chr(sc), _CAP); };
if (keyboard_check_pressed(vk_up))    _enqueue_ext(72); // Up
if (keyboard_check_pressed(vk_down))  _enqueue_ext(80); // Down
if (keyboard_check_pressed(vk_left))  _enqueue_ext(75); // Left
if (keyboard_check_pressed(vk_right)) _enqueue_ext(77); // Right

// Convenience WASD (uppercase; add lowercase if desired)
if (keyboard_check_pressed(ord("W"))) _enq("W", _CAP);
if (keyboard_check_pressed(ord("A"))) _enq("A", _CAP);
if (keyboard_check_pressed(ord("S"))) _enq("S", _CAP);
if (keyboard_check_pressed(ord("D"))) _enq("D", _CAP);


================================================================================

/// @file objects/obj_mode1_grid/Create_0.gml

/// @event obj_mode1_grid/Create
//Create 40x25 grid for 32x32 character tiles
grid_cols = 40;
grid_rows = 25;
tile_width = 32;
tile_height = 32;

grid = array_create(grid_cols * grid_rows);

// Each grid cell will be a struct:
function make_tile_struct(char = 32, fg = c_white, bg = c_black) {
    return { char: char, fg: fg, bg: bg };
}

// Initialize all tiles
for (var i = 0; i < array_length(grid); i++) {
    grid[i] = make_tile_struct();
}

self.mode1_grid_fill = function(char, fg, bg) {
    if (dbg_on(DBG_FLOW))  show_debug_message(">> GRID FILL START: char=" + string(char) + ", fg=" + string(fg) + ", bg=" + string(bg));
    if (dbg_on(DBG_FLOW))  show_debug_message(">> Grid array length: " + string(array_length(grid)));
    
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char;
        grid[i].fg = fg;
        grid[i].bg = bg;
    }
    
    // Check first few tiles to verify they were set
    for (var i = 0; i < 3; i++) {
        if (dbg_on(DBG_FLOW))  show_debug_message(">> Tile[" + string(i) + "]: char=" + string(grid[i].char) + ", fg=" + string(grid[i].fg) + ", bg=" + string(grid[i].bg));
    }
    if (dbg_on(DBG_FLOW))  show_debug_message(">> GRID FILL END");
}

	drewfont = 0;//temp var

	// CHANGE: compute cols/rows from cell size

	grid_cols = floor(room_width  / global.mode1_cell_px); // 40 @ 32px in 1280 room
	grid_rows = floor(room_height / global.mode1_cell_px); // 25 @ 32px in 800 room


	grid = array_create(grid_cols * grid_rows);

	for (var i = 0; i < array_length(grid); i++) {
	    grid[i] = { char: 32, fg: c_white, bg: c_black };
	}

	// Ensure sprite active
	if (is_undefined(global.mode1_active_sprite)) {
	    global.mode1_active_sprite = global.font_sheets[? "DEFAULT_32"];
	}



================================================================================

/// @file objects/obj_mode1_grid/Destroy_0.gml

/// @event obj_mode1_grid/Destroy
// You can write your code in this editor
reset_interpreter_state();
global.current_mode = 0;
show_message(" Unto the abyss I fall");

================================================================================

/// @file objects/obj_mode1_grid/Draw_0.gml

/// @event obj_mode1_grid/Draw
//draw_sprite(spr_charactersheet,10,10,10);
var tile_w    = global.mode1_cell_px; // 32 (default), 16, or 8
var tile_h    = global.mode1_cell_px;
var cols      = floor(room_width  / tile_w);
var rows      = floor(room_height / tile_h);
var max_chars = sprite_get_number(global.active_font_sprite);



if (global.grid_refresh_needed) {
    global.grid_refresh_needed = false;
    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var i = col + row * cols;
            if (i < array_length(grid)) {
                grid[i].char = global.grid_refresh_char;
            }
        }
    }
}

for (var _y = 0; _y < rows; _y++) {
    for (var _x = 0; _x < cols; _x++) {
        var i = _x + _y * cols;
        if (i < array_length(grid)) {
            var tile = grid[i];
            // Draw background
            draw_set_color(tile.bg);
            draw_rectangle(
                _x * tile_w, _y * tile_h,
                (_x + 1) * tile_w, (_y + 1) * tile_h,
                false
            );
            // Draw foreground (sprite tint)
            draw_set_color(tile.fg);
            // Force proper blending
            gpu_set_blendmode(bm_normal);
            draw_set_alpha(1.0);
            var subimg = clamp(tile.char, 0, max_chars - 1);
            // Draw character sprite
            draw_sprite_ext(
                global.active_font_sprite,
                subimg,
                _x * tile_w,
                _y * tile_h,
                1, 1, 0,
                tile.fg,
                1.0
            );
            // Debug helpers (commented out)
            //if (drewfont < 5000) { show_debug_message(global.active_font_sprite); drewfont++; }
            //draw_text(_x * tile_w, _y * tile_h + tile_h - 12, string(tile.char));
        }
    }
}

//    draw_set_color(c_white);
//	draw_text(4, room_height - 40, "FONT=" + global.active_font_name + "  spr=" + string(global.active_font_sprite) + "  num=" + string(sprite_get_number(global.active_font_sprite)));
	
// Reset draw state after the loop
draw_set_color(c_white);
gpu_set_blendmode(bm_normal);

// === END MESSAGE (MODE 1 style) === //
if (global.program_has_ended) {
    // Find a good position for the message - bottom of screen, centered
    var msg = "Program ended - ESC or ENTER to return";
    var msg_chars = string_length(msg);
    var start_col = max(0, floor((cols - msg_chars) / 2)); // Center horizontally
    var msg_row = rows - 2; // Two rows from bottom
    
    // Draw message character by character using the current font sprite
    for (var i = 0; i < msg_chars; i++) {
        var char_code = ord(string_char_at(msg, i + 1));
        var char_x = (start_col + i) * tile_w;
        var char_y = msg_row * tile_h;
        
        // Draw a background highlight for better visibility
        draw_set_color(c_black);
        draw_rectangle(char_x, char_y, char_x + tile_w, char_y + tile_h, false);
        
        // Draw the character in lime color to match MODE 0
        var subimg = clamp(char_code, 0, max_chars - 1);
        draw_sprite_ext(
            global.active_font_sprite,
            subimg,
            char_x, char_y,
            1, 1, 0,
            c_lime,
            1.0
        );
    }
    
    // Reset draw state
	
}

//draw_text(10, 24, "Font: " + global.active_font_name);



================================================================================

/// @file objects/obj_mode1_grid/Step_0.gml

/// @event obj_mode1_grid/Step
// You can write your code in this editor
// No active logic yet, but this is where future interactions (like SCROLL or POKE) will go.


================================================================================

/// @file objects/obj_screen_editor/Create_0.gml

show_debug_message("SCREEN_EDITOR: Create start");

// Sizing (keep your existing numbers if different)
char_width  = 16;
char_height = 24;
margin_x    = 8;
margin_y    = 8;

// Dynamic screen size
screen_cols = floor((room_width  - (margin_x * 2)) / char_width);
screen_rows = floor((room_height - (margin_y * 2) - 40) / char_height);

show_debug_message("SCREEN_EDITOR: Calculated screen size - " + string(screen_cols) + "x" + string(screen_rows) +
                   " (room: " + string(room_width) + "x" + string(room_height) + ")");

// Backing char buffer (your renderer already expects this)
screen_buffer = array_create(screen_cols * screen_rows, ord(" "));

// Cursor & scroll
cursor_x = 0;
cursor_y = 0;
horizontal_offset = 0;
scroll_margin = 5;
scroll_offset = 0;

// Caret blink
blink_timer = 0;
cursor_visible = true;

// NEW: live text buffer for the current row in this view
current_input = "";

// Pull program into buffer for display
screen_editor_load_program(id);

keyboard_string = ""; // start clean

show_debug_message("SCREEN_EDITOR: Create complete - " + string(screen_cols) + "x" + string(screen_rows) + " buffer");


================================================================================

/// @file objects/obj_screen_editor/Destroy_0.gml

// FILE: objects/obj_screen_editor/Destroy_0.gml
// REMOVE: Delete the entire Destroy event or replace with:

/// @event Destroy
// No cleanup needed - reverted to simple implementation
show_debug_message("SCREEN_EDITOR: Destroying");

================================================================================

/// @file objects/obj_screen_editor/Draw_0.gml

// Clear background
draw_set_color(c_black);
draw_rectangle(0, 0, room_width, room_height, false);

// Font/color
if (font_exists(fnt_basic)) draw_set_font(fnt_basic);
draw_set_color(make_color_rgb(255,191,64)); // your C64 yellow

// Draw any backing buffer you still use (safe-guarded)
if (is_array(screen_buffer)) {
    for (var _y = 0; _y < screen_rows; _y++) {
        for (var _x = 0; _x < screen_cols; _x++) {
            var idx = _x + _y * screen_cols;
            if (idx < array_length(screen_buffer)) {
                var ch = chr(screen_buffer[idx]);
                if (ch != " ") {
                    var draw_x = margin_x + (_x * char_width);
                    var draw_y = margin_y + (_y * char_height);
                    draw_text(draw_x, draw_y, ch);
                }
            }
        }
    }
}

// Draw caret on top of the existing buffer (no row_text/current_row)
if (cursor_visible) {
    draw_set_color(c_white);
    var caret_x = margin_x + (cursor_x * char_width);
    var caret_y = margin_y + (cursor_y * char_height);
    draw_text(caret_x, caret_y, "_");
}


================================================================================

/// @file objects/obj_screen_editor/Step_0.gml

/// @file objects/obj_screen_editor/Step_0.gml
/// @event Step
/// Final corrected horizontal scrolling implementation

// Handle ESC key - exit screen editor
if (keyboard_check_pressed(vk_escape)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: ESC pressed - exiting");
    screen_editor_exit(id);
    exit;
}

// Initialize line_modified flag if it doesn't exist
if (!variable_instance_exists(id, "line_modified")) {
    line_modified = false;
}

// Initialize key repeat timer for smoother arrow key movement
if (!variable_instance_exists(id, "arrow_repeat_timer")) {
    arrow_repeat_timer = 0;
}

// Handle cursor movement with horizontal scrolling
if (keyboard_check(vk_left)) {
    if (arrow_repeat_timer <= 0) {
        if (cursor_x > 0) {
            cursor_x--;
        } else if (horizontal_offset > 0) {
            // At left edge of screen, scroll left
            horizontal_offset--;
            screen_editor_load_program(id);
            if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled left - new h_offset=" + string(horizontal_offset));
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cursor left to (" + string(cursor_x) + "," + string(cursor_y) + "), h_offset=" + string(horizontal_offset));
        arrow_repeat_timer = 4; // 4-frame delay between movements
    }
}

if (keyboard_check(vk_right)) {
    if (arrow_repeat_timer <= 0) {
        // Get the FULL line content directly from program storage, not from screen buffer
        var line_index = cursor_y + scroll_offset;
        var full_line_text = "";
        
        if (line_index < ds_list_size(global.line_numbers)) {
            var line_num = ds_list_find_value(global.line_numbers, line_index);
            var code = ds_map_find_value(global.program_lines, line_num);
            full_line_text = string(line_num) + " " + code;
        }
        
        var actual_cursor_pos = cursor_x + horizontal_offset;
        var full_line_length = string_length(full_line_text);
        
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Right arrow - cursor_x=" + string(cursor_x) + ", h_offset=" + string(horizontal_offset) + ", actual_pos=" + string(actual_cursor_pos) + ", full_line_len=" + string(full_line_length));
        
        // Allow scrolling through the entire line content
        if (actual_cursor_pos < full_line_length && actual_cursor_pos < 200) {
            if (cursor_x < 79) {  // Use 79 for your 80-character screen
                cursor_x++;
            } else {
                // At right edge of screen, scroll right
                horizontal_offset++;
                screen_editor_load_program(id);
                if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled right - new h_offset=" + string(horizontal_offset));
            }
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: After right - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), h_offset=" + string(horizontal_offset));
        arrow_repeat_timer = 4; // 4-frame delay between movements
    }
}

// Decrement the arrow key repeat timer
if (arrow_repeat_timer > 0) {
    arrow_repeat_timer--;
}

if (keyboard_check_pressed(vk_up)) {
    // If current line was modified, commit it first
    if (line_modified) {
        screen_editor_commit_row(id, cursor_y);
        line_modified = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Auto-committed modified line before moving up");
    }
    
    // Store the desired horizontal position
    var desired_x = cursor_x + horizontal_offset;
    
    // Clear ALL keyboard input to prevent character leakage
    keyboard_string = "";
    keyboard_lastchar = "";
    keyboard_lastkey = 0;
    
    // Reset horizontal scrolling - always show left edge of new line
    horizontal_offset = 0;
    
    if (cursor_y > 0) {
        cursor_y--;
    } else if (scroll_offset > 0) {
        scroll_offset--;
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled up - scroll_offset=" + string(scroll_offset));
    }
    
    // Smart cursor positioning for new line
    var new_line_text = screen_editor_get_row_text(id, cursor_y);
    var new_line_length = string_length(new_line_text);
    var target_pos = min(desired_x, new_line_length);
    cursor_x = min(target_pos, 79);
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Up - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), cleared input");
}

if (keyboard_check_pressed(vk_down)) {
    // If current line was modified, commit it first
    if (line_modified) {
        screen_editor_commit_row(id, cursor_y);
        line_modified = false;
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Auto-committed modified line before moving down");
    }
    
    // Store the desired horizontal position
    var desired_x = cursor_x + horizontal_offset;
    
    // Clear ALL keyboard input to prevent character leakage
    keyboard_string = "";
    keyboard_lastchar = "";
    keyboard_lastkey = 0;
    
    // Reset horizontal scrolling - always show left edge of new line
    horizontal_offset = 0;
    
    var total_lines = ds_list_size(global.line_numbers);
    var visible_lines = min(screen_rows, total_lines - scroll_offset);
    
    if (cursor_y < visible_lines - 1 && cursor_y < screen_rows - 1) {
        cursor_y++;
    } else if (scroll_offset + screen_rows < total_lines) {
        scroll_offset++;
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Scrolled down - scroll_offset=" + string(scroll_offset));
    }
    
    // Smart cursor positioning for new line
    var new_line_text = screen_editor_get_row_text(id, cursor_y);
    var new_line_length = string_length(new_line_text);
    var target_pos = min(desired_x, new_line_length);
    cursor_x = min(target_pos, 79);
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Down - cursor(" + string(cursor_x) + "," + string(cursor_y) + "), cleared input");
}

// Handle Page Up/Down
if (keyboard_check_pressed(vk_pageup)) {
    var old_offset = scroll_offset;
    scroll_offset = max(0, scroll_offset - screen_rows);
    if (scroll_offset != old_offset) {
        horizontal_offset = 0;
        cursor_x = min(cursor_x, 79);
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Page Up - scroll_offset " + string(old_offset) + " -> " + string(scroll_offset));
    }
}

if (keyboard_check_pressed(vk_pagedown)) {
    var old_offset = scroll_offset;
    var total_lines = ds_list_size(global.line_numbers);
    scroll_offset = min(max(0, total_lines - screen_rows), scroll_offset + screen_rows);
    if (scroll_offset != old_offset) {
        horizontal_offset = 0;
        cursor_x = min(cursor_x, 79);
        screen_editor_load_program(id);
        if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Page Down - scroll_offset " + string(old_offset) + " -> " + string(scroll_offset));
    }
}

// Home/End key support
if (keyboard_check_pressed(vk_home)) {
    cursor_x = 0;
    horizontal_offset = 0;
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Home pressed - jump to beginning");
}

if (keyboard_check_pressed(vk_end)) {
    var current_line_text = screen_editor_get_row_text(id, cursor_y);
    var line_length = string_length(current_line_text);
    
    if (line_length <= 80) {
        // Line fits on screen
        cursor_x = line_length;
        horizontal_offset = 0;
    } else {
        // Line is longer - scroll to show the end
        horizontal_offset = line_length - 80;
        cursor_x = 79;
    }
    
    screen_editor_load_program(id);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: End pressed - jump to end, cursor=" + string(cursor_x) + ", h_offset=" + string(horizontal_offset));
}


// Character input
if (keyboard_check_pressed(vk_anykey)) {
    var k  = keyboard_lastkey;
    var ch = keyboard_lastchar;

    // Is this a printable keystroke (not pure modifier / not control)?
    var _is_printable =
        (k != vk_shift && k != vk_control && k != vk_alt) &&
        (!is_undefined(ch)) && (ch != "") && (ord(ch) >= 32);

    // CRITICAL: Ignore arrow keys and other navigation keys to prevent interference
    var _is_nav =
        keyboard_check(vk_left) || keyboard_check(vk_right) ||
        keyboard_check(vk_up)   || keyboard_check(vk_down)  ||
        keyboard_check_pressed(vk_left) || keyboard_check_pressed(vk_right) ||
        keyboard_check_pressed(vk_up)   || keyboard_check_pressed(vk_down)  ||
        keyboard_check_pressed(vk_home) || keyboard_check_pressed(vk_end)   ||
        keyboard_check_pressed(vk_pageup) || keyboard_check_pressed(vk_pagedown) ||
        keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_backspace) ||
        keyboard_check_pressed(vk_escape);

    // Only run the INSERT path for printable, non-nav keys.
    if (_is_printable && !_is_nav) {

        if (string_length(ch) == 1) {
            var ascii_code = ord(ch);
            if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Key pressed - char '" + ch + "', ASCII " + string(ascii_code));

            if (ascii_code >= 32 && ascii_code <= 126) {
                var current_line_text = screen_editor_get_row_text(id, cursor_y);
                var actual_cursor_pos = cursor_x + horizontal_offset;

                // Preserve intentional trailing spaces up to cursor (since get_row_text trims)
                if (string_length(current_line_text) < actual_cursor_pos) {
                    var pad = actual_cursor_pos - string_length(current_line_text);
                    repeat (pad) { current_line_text += " "; }
                }

                if (string_length(current_line_text) < 200) {
                    // Insert character at actual position
                    var before_cursor = string_copy(current_line_text, 1, actual_cursor_pos);
                    var after_cursor  = string_copy(current_line_text, actual_cursor_pos + 1, string_length(current_line_text));
                    var new_line      = before_cursor + ch + after_cursor;

                    // Update the actual BASIC program line
                    var line_index = cursor_y + scroll_offset;
                    if (line_index < ds_list_size(global.line_numbers)) {
                        var line_num  = ds_list_find_value(global.line_numbers, line_index);
                        var space_pos = string_pos(" ", new_line);
                        if (space_pos > 0) {
                            var code_part = string_copy(new_line, space_pos + 1, string_length(new_line));
                            ds_map_set(global.program_lines, line_num, code_part);
                        }
                    }

                    // Mark line as modified
                    line_modified = true;

                    // Advance cursor
                    if (cursor_x < 79) {
                        cursor_x++;
                    } else {
                        horizontal_offset++;
                    }

                    screen_editor_load_program(id);
                    // keep the live edit visible even if this is a not-yet-committed/new line
                    screen_editor_display_line(id, new_line, cursor_y);

                } else {
                    basic_show_message("Line too long (max 200 chars)");
                }
            }
        }
    }
    // IMPORTANT: do not exit here — lets Enter/Backspace handlers run later in Step
}



// Backspace
if (keyboard_check_pressed(vk_backspace)) {
    var current_line_text = screen_editor_get_row_text(id, cursor_y);
    var actual_cursor_pos = cursor_x + horizontal_offset;
	
	// ADD this padding block (so backspace can delete spaces you just typed):
	if (string_length(current_line_text) < actual_cursor_pos) {
	    var pad = actual_cursor_pos - string_length(current_line_text);
	    repeat (pad) { current_line_text += " "; }
	}
    
    if (actual_cursor_pos > 0) {
        // Delete character
        var before_cursor = string_copy(current_line_text, 1, actual_cursor_pos - 1);
        var after_cursor = string_copy(current_line_text, actual_cursor_pos + 1, string_length(current_line_text));
        var new_line = before_cursor + after_cursor;
        
        // Update program line
        var line_index = cursor_y + scroll_offset;
        if (line_index < ds_list_size(global.line_numbers)) {
            var line_num = ds_list_find_value(global.line_numbers, line_index);
            var space_pos = string_pos(" ", new_line);
            if (space_pos > 0) {
                var code_part = string_copy(new_line, space_pos + 1, string_length(new_line));
                ds_map_set(global.program_lines, line_num, code_part);
            }
        }
        
        // Mark line as modified
        line_modified = true;
        
        // Move cursor back
        if (cursor_x > 0) {
            cursor_x--;
        } else if (horizontal_offset > 0) {
            horizontal_offset--;
        }
        
        screen_editor_load_program(id);
		
		// re-assert the edited row on screen after the reload
		screen_editor_display_line(id, new_line, cursor_y);
    }
}

// Enter key
if (keyboard_check_pressed(vk_enter)) {
    if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Enter pressed - committing row " + string(cursor_y));
    screen_editor_commit_row(id, cursor_y);
    
    horizontal_offset = 0;
    cursor_x = 0;
    
    screen_editor_load_program(id);
    
    if (cursor_y < screen_rows - 1) {
        cursor_y++;
    }
}

// Cursor blink
blink_timer++;
if (blink_timer >= 30) {
    cursor_visible = !cursor_visible;
    blink_timer = 0;
}

================================================================================

/// @file scripts/add_or_update_program_line/add_or_update_program_line.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function add_or_update_program_line(line_num, code) {
    ds_map_set(global.program_lines, line_num, code);
    
    // Update ordered line numbers list
    var pos = ds_list_find_index(global.line_numbers, line_num);
    if (pos == -1) {
        // Insert in correct order
        insert_line_number_ordered(line_num);
    }
 }

================================================================================

/// @file scripts/add_to_history/add_to_history.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function add_to_history(input_text) {
    if (input_text != "" && (ds_list_size(global.input_history) == 0 || 
        ds_list_find_value(global.input_history, ds_list_size(global.input_history) - 1) != input_text)) {
        ds_list_add(global.input_history, input_text);
        // Limit history size
        while (ds_list_size(global.input_history) > 50) {
            ds_list_delete(global.input_history, 0);
        }
	}
 }

================================================================================

/// @file scripts/basic_array_get/basic_array_get.gml

/// @function basic_array_get(name, idx)
/// @description Retrieves a value from a 1D array stored in global.basic_arrays (0-based indexing)
/// @param name The name of the array (string)
/// @param idx  The index to access (0-based)
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_get(_name, _idx) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET: Accessing " + nm + "[" + string(_idx) + "]");

    // Must exist in the map
    if (!ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET ERROR: Array '" + nm + "' does not exist");
        return 0;
    }

    // Must be a valid ds_list handle
    var lst = global.basic_arrays[? nm];
    if (!ds_exists(lst, ds_type_list)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET ERROR: '" + nm + "' is not a ds_list");
        return 0;
    }

    // Normalize index
    var idx = floor(real(_idx)); // use floor; indices are 0..N-1

    // Bounds check
    var n = ds_list_size(lst);
    if (idx < 0 || idx >= n) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_GET ERROR: Index " + string(idx) + " out of bounds for " + nm + " (size=" + string(n) + ")");
        return 0;
    }

    // Fetch
    var value = ds_list_find_value(lst, idx);
    // OPTIONAL: verbose log (comment out if noisy)
    // show_debug_message("ARRAY_GET: " + nm + "[" + string(idx) + "] = " + string(value));
    return value;
}


================================================================================

/// @file scripts/basic_array_init/basic_array_init.gml

/// @function basic_array_init(name, size)
/// @description Initializes a 1D array as a ds_list in global.basic_arrays
/// @param name The name of the array (string)
/// @param size The size of the array (number of elements)
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_init(_name, _size) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT: Initializing " + nm + " with size " + string(_size));

    // If the array already exists, destroy its backing list
    if (ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT WARNING: Array '" + nm + "' already exists, destroying");
        var old_lst = global.basic_arrays[? nm];
        if (ds_exists(old_lst, ds_type_list)) {
            ds_list_destroy(old_lst);
        }
        ds_map_delete(global.basic_arrays, nm);
    }

    // Normalize and validate size
    var sz = floor(real(_size));
    if (sz < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT ERROR: Invalid size " + string(sz) + " for " + nm);
        return;
    }

    // Create and fill
    var lst = ds_list_create();
    repeat (sz) {
        ds_list_add(lst, 0);
    }
    global.basic_arrays[? nm] = lst;

    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_INIT: Created " + nm + " with size " + string(ds_list_size(lst)));
}


================================================================================

/// @file scripts/basic_array_set/basic_array_set.gml

/// @function basic_array_set(name, idx, value)
/// @description Sets a value in a 1D array stored in global.basic_arrays (0-based indexing, auto-grows)
/// @param name  The name of the array (string)
/// @param idx   The index to set (0-based)
/// @param value The value to set
/// arrays v1 — 2025-08-08
/// 1D arrays backed by ds_list, 0-based, auto-grow, OOB reads return 0

function basic_array_set(_name, _idx, _val) {
    var nm = string_upper(string_trim(_name));
    if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET: Setting " + nm + "[" + string(_idx) + "] = " + string(_val));

    // Ensure the map entry exists and is a ds_list
    if (!ds_map_exists(global.basic_arrays, nm)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET: Creating new ds_list for " + nm);
        global.basic_arrays[? nm] = ds_list_create();
    }

    var lst = global.basic_arrays[? nm];
    if (!ds_exists(lst, ds_type_list)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET: Replacing non-list backing store for " + nm);
        lst = ds_list_create();
        global.basic_arrays[? nm] = lst;
    }

    // Normalize index
    var idx = floor(real(_idx)); // integer index (use floor to avoid +1 surprises near boundaries)

    // OPTIONAL: hard-stop on negative indexes (comment this out if you prefer silent ignore)
    if (idx < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("ARRAY_SET ERROR: Negative index " + string(idx) + " for array " + nm);
        return;
    }

    // Grow to fit (fills with 0)
    while (ds_list_size(lst) <= idx) {
        ds_list_add(lst, 0);
        // OPTIONAL: verbose growth log (disable if noisy)
        // show_debug_message("ARRAY_SET: Growing " + nm + " to size " + string(ds_list_size(lst)));
    }

    // Assign
    ds_list_replace(lst, idx, _val);
    // OPTIONAL: confirmation log (disable if noisy)
    // show_debug_message("ARRAY_SET: Set " + nm + "[" + string(idx) + "] = " + string(_val));
}


================================================================================

/// @file scripts/basic_cmd_bgcolor/basic_cmd_bgcolor.gml

function basic_cmd_bgcolor(arg) {
    var colstr = string_upper(string_trim(arg));
    if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Raw argument: '" + arg + "', Normalized: '" + colstr + "'");
    
    var bg_color = c_black;
    var matched = false;

    // Look up named color
    if (ds_map_exists(global.colors, colstr)) {
        bg_color = global.colors[? colstr];
        matched = true;
        if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Matched named color → " + string(bg_color));
    }
    // RGB() syntax
   else if (string_pos("RGB(", colstr) == 1) {
    var l = string_pos("(", colstr), r = string_last_pos(")", colstr);
    if (r > l) {
        var inner = string_copy(colstr, l + 1, r - l - 1);
        var parts = []; var buf = ""; var _depth = 0;
        for (var i = 1; i <= string_length(inner); i++) {
            var ch = string_char_at(inner, i);
            if (ch == "(") _depth++; else if (ch == ")") _depth--;
            if (ch == "," && _depth == 0) { array_push(parts, buf); buf = ""; } else buf += ch;
        }
        array_push(parts, buf);
        if (array_length(parts) == 3) {
            var rV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[0]))), 0, 255);
            var gV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[1]))), 0, 255);
            var bV = clamp(floor(basic_evaluate_expression_v2(string_trim(parts[2]))), 0, 255);
            bg_color = make_color_rgb(rV, gV, bV); matched = true;
        } else if (dbg_on(DBG_FLOW))  {show_debug_message("BGCOLOR: Invalid RGB arg count in '" + inner + "'");}
    } else if (dbg_on(DBG_FLOW))  {show_debug_message("BGCOLOR: Missing ) in '" + colstr + "'");}
}
 else {
        if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: No matching named color or RGB format found for '" + colstr + "'");
    }

    global.background_draw_color = bg_color;
    global.background_draw_enabled = (bg_color != c_black);

    if (dbg_on(DBG_FLOW))  show_debug_message("BGCOLOR: Final color set to " + string(bg_color) + ", background_draw_enabled: " + string(global.background_draw_enabled));
}


================================================================================

/// @file scripts/basic_cmd_charat/basic_cmd_charat.gml

/// @function basic_cmd_charat(arg)
/// @desc CHARAT x, y, charIndex [, fg [, bg]]
function basic_cmd_charat(arg) {
    var args = basic_parse_csv_args(arg);
    if (array_length(args) < 3) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT requires 3 arguments: x, y, char");
        return;
    }

    // Evaluate coordinates (identifiers allowed)
    var _x = floor(real(basic_evaluate_expression_v2(string_trim(args[0]))));
    var _y = floor(real(basic_evaluate_expression_v2(string_trim(args[1]))));
    var char_index = floor(real(basic_evaluate_expression_v2(string_trim(args[2]))));

    // Optional colors
    var fg = (array_length(args) > 3) ? basic_parse_color(string_trim(args[3])) : undefined;
    var bg = (array_length(args) > 4) ? basic_parse_color(string_trim(args[4])) : undefined;

    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT: grid not found");
        return;
    }

    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _x >= cols || _y < 0 || _y >= rows) {
        if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT: coordinates out of bounds (" + string(_x) + "," + string(_y) + ")");
        return;
    }

    // If fg/bg are undefined, mode1_grid_set should keep existing cell colors
    mode1_grid_set(_x, _y, char_index, fg, bg);

    if (dbg_on(DBG_FLOW)) show_debug_message("CHARAT: set (" + string(_x) + "," + string(_y) + ")=" + string(char_index)
        + ((fg != undefined) ? " fg=" + string(fg) : "")
        + ((bg != undefined) ? " bg=" + string(bg) : ""));
}


================================================================================

/// @file scripts/basic_cmd_cls/basic_cmd_cls.gml

function basic_cmd_cls() {
    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Called");
    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Current color before clear: " + string(global.current_draw_color));

    ds_list_clear(global.output_lines);
    ds_list_clear(global.output_colors);

    global.current_draw_color = global.basic_text_color;

    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Screen cleared");
    if (dbg_on(DBG_FLOW))  show_debug_message("CLS: Current color reset to default: " + string(global.current_draw_color));
}


================================================================================

/// @file scripts/basic_cmd_cls_mode1/basic_cmd_cls_mode1.gml

// =================================================================
// MODE 1 Enhanced CLS - clear screen and reset cursor
// =================================================================
/// @function basic_cmd_cls_mode1()
/// @description MODE 1 version of CLS that clears the grid and resets cursor
function basic_cmd_cls_mode1() {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (instance_exists(grid_obj)) {
        with (grid_obj) {
            mode1_grid_fill(32, c_white, c_black); // Clear with spaces
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: Grid cleared");
    }
    
    // Reset cursor to top-left
    global.mode1_cursor_x = 0;
    global.mode1_cursor_y = 0;
    
    if (dbg_on(DBG_FLOW)) show_debug_message("CLS MODE1: Cursor reset to (0,0)");
}

================================================================================

/// @file scripts/basic_cmd_clschar/basic_cmd_clschar.gml

function basic_cmd_clschar(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("=== CLSCHAR DEBUG START ===");
    if (dbg_on(DBG_FLOW))  show_debug_message("Raw arg: '" + string(arg) + "'");
    
    var args = string_split(arg, ",");
    if (dbg_on(DBG_FLOW))  show_debug_message("Split args count: " + string(array_length(args)));
    for (var i = 0; i < array_length(args); i++) {
        show_debug_message("Arg[" + string(i) + "]: '" + string(args[i]) + "'");
    }

    var char_index = 0;
    var fg_color = c_white;
    var bg_color = c_black;

    if (array_length(args) >= 1) {
        char_index = real(string_trim(args[0]));
        if (dbg_on(DBG_FLOW))  show_debug_message("Parsed char_index: " + string(char_index));
    }

    if (array_length(args) >= 2) {
        var fg_str = string_upper(string_trim(args[1]));
        if (dbg_on(DBG_FLOW))  show_debug_message("Looking for fg color: '" + fg_str + "'");
        if (ds_map_exists(global.colors, fg_str)) {
            fg_color = global.colors[? fg_str];
            if (dbg_on(DBG_FLOW))  show_debug_message("Found fg color: " + string(fg_color));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("FG COLOR NOT FOUND!");
        }
    }

    if (array_length(args) >= 3) {
        var bg_str = string_upper(string_trim(args[2]));
        if (dbg_on(DBG_FLOW))  show_debug_message("Looking for bg color: '" + bg_str + "'");
        if (ds_map_exists(global.colors, bg_str)) {
            bg_color = global.colors[? bg_str];
            if (dbg_on(DBG_FLOW))  show_debug_message("Found bg color: " + string(bg_color));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("BG COLOR NOT FOUND!");
        }
    }

    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("❌ CLSCHAR: No obj_mode1_grid found!");
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("✅ CLSCHAR: Found grid obj - calling fill...");
        if (dbg_on(DBG_FLOW))  show_debug_message("Calling fill with: char=" + string(char_index) + ", fg=" + string(fg_color) + ", bg=" + string(bg_color));
        grid_obj.mode1_grid_fill(char_index, fg_color, bg_color);
    }
    if (dbg_on(DBG_FLOW))  show_debug_message("=== CLSCHAR DEBUG END ===");
}

================================================================================

/// @file scripts/basic_cmd_color/basic_cmd_color.gml

/// @script basic_cmd_color
/// @description Change text color (and optional background): COLOR fg[, bg]
function basic_cmd_color(arg) {
    // Split into up to two parts: foreground and optional background
    ///
	// Split on commas, but not inside parentheses
		var parts = [];
		var current = "";
		var paren_depth = 0;
		var trimmed_arg = string_trim(arg);

		for (var i = 1; i <= string_length(trimmed_arg); i++) {
		    var ch = string_char_at(trimmed_arg, i);
		    if (ch == "(") {
		        paren_depth++;
		        current += ch;
		    } else if (ch == ")") {
		        paren_depth--;
		        current += ch;
		    } else if (ch == "," && paren_depth == 0) {
		        array_push(parts, string_trim(current));
		        current = "";
		    } else {
		        current += ch;
		    }
		}
		if (string_trim(current) != "") {
		    array_push(parts, string_trim(current));
		}
	
	///
    var fgStr = string_upper(string_trim(parts[0]));
    var bgStr = (array_length(parts) > 1)
                ? string_upper(string_trim(parts[1]))
                : "";

    // Helper: parse a single color spec (named or RGB), returns -1 on error
    var parse_color = function(colSpec) {
        // RGB(r,g,b) form?
        if (string_copy(colSpec, 1, 4) == "RGB("
            && string_char_at(colSpec, string_length(colSpec)) == ")")
        {
            var inner = string_copy(colSpec, 5, string_length(colSpec) - 5);
            var comps = string_split(inner, ",");
            if (array_length(comps) == 3) {
                var r = clamp(real(string_trim(comps[0])), 0, 255);
                var g = clamp(real(string_trim(comps[1])), 0, 255);
                var b = clamp(real(string_trim(comps[2])), 0, 255);
                return make_color_rgb(r, g, b);
            } else {
                return -1;
            }
        }
        // Named color lookup
        if (ds_map_exists(global.colors, colSpec)) {
            return global.colors[? colSpec];
        }
        return -1;
    };

    // Parse and apply foreground
    var fgCol = parse_color(fgStr);
    if (fgCol >= 0) {
        global.basic_text_color   = fgCol;
        global.current_draw_color = fgCol;
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("?COLOR ERROR: Unknown foreground color '" + fgStr + "'");
    }

    // Parse and apply background (if provided)
    if (bgStr != "") {
        var bgCol = parse_color(bgStr);
        if (bgCol >= 0) {
            global.background_draw_color   = bgCol;
            global.background_draw_enabled = true;
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("?COLOR ERROR: Unknown background color '" + bgStr + "'");
        }
    }
}


================================================================================

/// @file scripts/basic_cmd_dim/basic_cmd_dim.gml

/// @function basic_cmd_dim(rest)
/// @description DIM NAME(expr) or DIM NAME1(expr1), NAME2(expr2), ...
/// Allocates 1-D arrays in global.basic_arrays as zero-filled ds_lists.
/// Semantics: inclusive upper bound like C64 — DIM A(10) => valid indices 0..10.
/// Notes:
/// - Safe alongside LET auto-grow: DIM preallocates; LET keeps working the same.
/// - Multiple arrays supported, comma-separated at top level (commas inside () are ignored).
function basic_cmd_dim(rest) {
    var s  = string_trim(rest);
    if (s == "") {
        if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Missing arguments");
        return;
    }

    // Ensure array registry exists
    if (is_undefined(global.basic_arrays)) {
        global.basic_arrays = ds_map_create();
        if (dbg_on(DBG_FLOW))  show_debug_message("DIM: Created global.basic_arrays map");
    }

    // Split on top-level commas (ignore commas inside parentheses or quotes)
    var defs = [];
    {
        var _depth = 0;
        var in_q  = false;
        var start = 1;
        for (var i = 1; i <= string_length(s); i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { in_q = !in_q; }
            if (!in_q) {
                if (ch == "(") _depth++;
                else if (ch == ")") _depth = max(0, _depth - 1);
                else if (ch == "," && _depth == 0) {
                    array_push(defs, string_trim(string_copy(s, start, i - start)));
                    start = i + 1;
                }
            }
        }
        // tail
        if (start <= string_length(s)) {
            array_push(defs, string_trim(string_copy(s, start, string_length(s) - start + 1)));
        }
    }

    // Process each NAME(expr)
    for (var d = 0; d < array_length(defs); d++) {
        var item = defs[d];
        if (item == "") continue;

        var openPos  = string_pos("(", item);
        var closePos = string_last_pos(")", item);

        if (openPos <= 0 || closePos <= openPos) {
            if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Expected NAME(expr), got: " + item);
            continue;
        }

        var nm_raw  = string_trim(string_copy(item, 1, openPos - 1));
        var nm      = string_upper(nm_raw);
        var lenExpr = string_copy(item, openPos + 1, (closePos - openPos - 1));
        var lenVal  = basic_evaluate_expression_v2(lenExpr);

        if (!is_real(lenVal)) {
            if (dbg_on(DBG_FLOW))  show_debug_message("DIM ERROR: Length expression not numeric for " + nm + " -> [" + lenExpr + "]");
            continue;
        }

        var n    = floor(max(0, lenVal));
        var size = n + 1; // inclusive upper bound (0..n)

        // Replace any existing ds_list to avoid leaks
        if (ds_map_exists(global.basic_arrays, nm)) {
            var _old = global.basic_arrays[? nm];
            if (ds_exists(_old, ds_type_list)) {
                ds_list_destroy(_old);
            }
        }

        // Create and zero-fill list
        var lst = ds_list_create();
        for (var i = 0; i < size; i++) ds_list_add(lst, 0);

        global.basic_arrays[? nm] = lst;

        if (dbg_on(DBG_FLOW))  {show_debug_message("DIM: " + nm + " sized to " + string(size) + " (indices 0.." + string(n) + ")"
            + " | lenExpr=[" + lenExpr + "] -> " + string(lenVal));}
    }
}


================================================================================

/// @file scripts/basic_cmd_else/basic_cmd_else.gml

/// @script basic_cmd_else
/// @description Handle ELSE in a structured IF…ELSEIF…ELSE…ENDIF
function basic_cmd_else() {
    if (dbg_on(DBG_FLOW))  show_debug_message("ELSE START");
    // ← GUARD: must have an open IF
    if (ds_stack_empty(global.if_stack)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSE ERROR: ELSE without matching IF");
        return;
    }
	
    var frame = ds_stack_top(global.if_stack);
    var taken = frame[? "takenBranch"];

    var current_index = global.interpreter_current_line_index;
    var endifIx = frame[? "endifIndex"];

    if (taken) {
        // Already ran IF or an ELSEIF → skip entire ELSE-block
        global.interpreter_next_line = endifIx;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSE skipping to ENDIF at index " + string(endifIx));
    } else {
        // No branch yet taken → run ELSE body
        ds_map_replace(frame, "takenBranch", true);
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSE entering branch at index " + string(global.interpreter_next_line));
    }
}


================================================================================

/// @file scripts/basic_cmd_elseif/basic_cmd_elseif.gml

/// @script basic_cmd_elseif
/// @description Handle an ELSEIF in a block‐structured IF…THEN…ELSEIF…ELSE…ENDIF chain
function basic_cmd_elseif(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF START — Raw arg: '" + arg + "'");
    
    // ── GUARD 1: Must have an open IF on the stack ──
    if (ds_stack_empty(global.if_stack)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: ELSEIF without matching IF");
        return;
    }
    
    // 1) Where are we in the program?
    var current_index = global.interpreter_current_line_index;
    
    // 2) Peek the top IF‐frame
    var frame = ds_stack_top(global.if_stack);
    
    // ── GUARD 2: Must have block metadata for this IF ──
    if (!ds_map_exists(global.if_block_map, frame[? "startIndex"])) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: No IF‐block metadata (bad nesting?)");
        return;
    }
    
    var taken       = frame[? "takenBranch"];
    var elseif_list = frame[? "elseifIndices"]; // ds_list of all ELSEIF positions
    var else_index  = frame[? "elseIndex"];
    var endif_index = frame[? "endifIndex"];
    
    // 3) Find which ELSEIF this is
    var pos = ds_list_find_index(elseif_list, current_index);
    if (pos < 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: Unexpected ELSEIF at index " + string(current_index));
        return;
    }
    
    // 4) If we’ve already taken a branch, skip straight through
    if (taken) {
        // decide next jump: next ELSEIF, or ELSE, or ENDIF
        var next_index = -1;
        if (pos < ds_list_size(elseif_list) - 1) {
            next_index = elseif_list[| pos + 1];
        } else if (else_index >= 0) {
            next_index = else_index;
        } else {
            next_index = endif_index;
        }
        global.interpreter_next_line = next_index;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF skipping to index " + string(next_index));
        return;
    }
    
    // 5) Parse and evaluate this ELSEIF’s condition
    var raw      = string_trim(arg);
    var upperRaw = string_upper(raw);
    var then_pos = string_pos("THEN", upperRaw);
    if (then_pos <= 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ELSEIF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var cond_text = string_trim(string_copy(raw, 1, then_pos - 1));
    if (dbg_on(DBG_FLOW))  show_debug_message("Parsed ELSEIF condition: '" + cond_text + "'");
    
    // Reuse your AND/OR logic from basic_cmd_if
    var result = false;
    var logic_op = "";
    var upcond   = string_upper(cond_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";
    if (logic_op != "") {
        var parts = string_split(cond_text, logic_op);
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        if (dbg_on(DBG_FLOW))  show_debug_message("Combined ELSEIF (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(cond_text);
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF single condition result: " + string(result));
    }
    
    // 6) If it’s true, mark the frame as “taken” and fall into this block…
    if (result) {
        frame[? "takenBranch"] = true;
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF TRUE: entering branch at index " + string(global.interpreter_next_line));
    } else {
        // …otherwise skip to the next ELSEIF/ELSE/ENDIF
        var next_index = (pos < ds_list_size(elseif_list) - 1)
                         ? elseif_list[| pos + 1]
                         : (else_index >= 0 ? else_index : endif_index);
        global.interpreter_next_line = next_index;
        if (dbg_on(DBG_FLOW))  show_debug_message("ELSEIF FALSE: skipping to index " + string(next_index));
    }
}


================================================================================

/// @file scripts/basic_cmd_end/basic_cmd_end.gml

function basic_cmd_end() {
    if (dbg_on(DBG_FLOW)) show_debug_message("END: Program termination requested");
    global.program_has_ended = true;
    global.interpreter_running = false;
	 global.current_mode = 0;
    if (dbg_on(DBG_FLOW)) show_debug_message("END: interpreter_running set to false");
}


================================================================================

/// @file scripts/basic_cmd_endif/basic_cmd_endif.gml

/// @script basic_cmd_endif
/// @description Handle ENDIF—pop IF-stack and continue
function basic_cmd_endif() {
  if (dbg_on(DBG_FLOW))  show_debug_message("ENDIF START");
    // ← GUARD: must have an open IF
    if (ds_stack_empty(global.if_stack)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?ENDIF ERROR: ENDIF without matching IF");
        return;
    }
    var frame = ds_stack_pop(global.if_stack);

    var current_index = global.interpreter_current_line_index;
    // Pop and destroy the frame

    ds_map_destroy(frame);

    // Continue immediately after ENDIF
    global.interpreter_next_line = current_index + 1;
    if (dbg_on(DBG_FLOW))  show_debug_message("ENDIF done, next index " + string(global.interpreter_next_line));
}


================================================================================

/// @file scripts/basic_cmd_font/basic_cmd_font.gml

/// @function basic_cmd_font(arg)
/// @desc FONTSET "KEY" -> switch active font sprite by registry key
function basic_cmd_font(arg) {
    if (global.current_mode < 1) {
        basic_print_system_message("FONT not implemented in MODE " + string(global.current_mode));
        return;
    }

    var key = string_trim(arg);

    // Strip quotes if present
    if (string_length(key) >= 2) {
        var f = string_char_at(key,1);
        var l = string_char_at(key,string_length(key));
        if ((f == "\"" || f == "'") && f == l) key = string_copy(key,2,string_length(key)-2);
    }

    key = string_upper(key);

    if (!variable_global_exists("font_sheets")) {
        basic_print_system_message("FONT registry not initialized");
        return;
    }

    if (ds_map_exists(global.font_sheets, key)) {
        var spr = ds_map_find_value(global.font_sheets, key);
        global.active_font_name   = key;
        global.active_font_sprite = spr;

        // DEBUG: prove which sprite & how many subimages
        var n = sprite_get_number(spr);
        if (dbg_on(DBG_FLOW)) {
            show_debug_message("FONTSET: key=" + key
                + " spr_id=" + string(spr)
                + " subimages=" + string(n));
        }

        // Trigger a lightweight refresh (keeps existing fg/bg)
        global.grid_refresh_needed = true;
        global.grid_refresh_char   = 32; // space

    } else {
        basic_cmd_print("FONT " + key + " not found", false);
        if (dbg_on(DBG_FLOW)) show_debug_message("FONTSET: missing registry key '" + key + "'");
    }
}


================================================================================

/// @file scripts/basic_cmd_fontset/basic_cmd_fontset.gml

/// @function basic_cmd_fontset(arg)
/// @description FONTSET "<registry-key>"
function basic_cmd_fontset(arg) {
    if (global.current_mode < 1) {
        basic_print_system_message("FONTSET not implemented in MODE " + string(global.current_mode));
        return;
    }

    var key = string_upper(string_trim(arg));

    // Strip quotes if present
    if (string_length(key) >= 2) {
        var first = string_char_at(key, 1);
        var last  = string_char_at(key, string_length(key));
        if ((first == "\"" || first == "'") && first == last) {
            key = string_copy(key, 2, string_length(key) - 2);
        }
    }

    if (!ds_map_exists(global.font_sheets, key)) {
        basic_cmd_print("FONTSET: " + key + " not found", false);
        return;
    }

    // Lock the font so MODE/room init won't overwrite it
    global.active_font_name   = key;
    global.active_font_sprite = global.font_sheets[? key];
    global.font_locked        = true;

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("FONTSET -> " + key
            + "  sprite=" + string(global.active_font_sprite)
            + "  subimages=" + string(sprite_get_number(global.active_font_sprite)));
    }

    // Reblank using current sheet's blank char, if you do that
    global.grid_refresh_needed = true;
}


================================================================================

/// @file scripts/basic_cmd_for/basic_cmd_for.gml

/// @function basic_cmd_for(arg) 
/// @description Parses and handles BASIC FOR loop initialization (spacing-tolerant; optional STEP)
function basic_cmd_for(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Entering handler with argument: '" + string(arg) + "'");

    // 1) Parse "VAR = start TO end [STEP step]"
    var raw   = string_trim(string(arg));
    var eqpos = string_pos("=", raw);
    if (eqpos <= 0) {
        basic_syntax_error("FOR missing '=' - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var varname = string_upper(string_trim(string_copy(raw, 1, eqpos - 1)));
    if (varname == "") {
        basic_syntax_error("FOR missing variable name before '='",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var rhs = string_trim(string_copy(raw, eqpos + 1, string_length(raw) - eqpos));

    // find TO
    var to_at = -1;
    for (var p = 1; p <= string_length(rhs) - 1; p++) {
        if (string_upper(string_copy(rhs, p, 2)) == "TO") { to_at = p; break; }
    }
    if (to_at < 0) {
        basic_syntax_error("FOR missing TO - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var start_expr = string_trim(string_copy(rhs, 1, to_at - 1));
    var after_to   = string_trim(string_copy(rhs, to_at + 2, string_length(rhs) - (to_at + 1)));
    if (start_expr == "" || after_to == "") {
        basic_system_message("SYNTAX ERROR IN FOR (incomplete expressions): " + raw);
        global.interpreter_running = false;
        return;
    }

    // optional STEP
    var step_expr = "1";
    var to_expr   = after_to;

    var step_at = -1;
    for (var q = 1; q <= string_length(after_to) - 3; q++) {
        if (string_upper(string_copy(after_to, q, 4)) == "STEP") { step_at = q; break; }
    }
    if (step_at > 0) {
        to_expr   = string_trim(string_copy(after_to, 1, step_at - 1));
        step_expr = string_trim(string_copy(after_to, step_at + 4, string_length(after_to) - (step_at + 3)));
        if (step_expr == "") step_expr = "1";
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Header pieces → var='" + varname
        + "' | start='" + start_expr + "' | to='" + to_expr + "' | step='" + step_expr + "'");

    // 2) Evaluate start, to, step
    var start_tokens  = basic_tokenize_expression_v2(start_expr);
    var start_postfix = infix_to_postfix(start_tokens);
    var start_val     = evaluate_postfix(start_postfix);

    var to_val_eval   = basic_evaluate_expression_v2(to_expr);
    var step_val_eval = basic_evaluate_expression_v2(step_expr);

    // --- SAFE RESOLUTION: only accept string if it's a variable name; never call real() on text ---
    if (is_string(to_val_eval)) {
        var key_to = string_upper(string_trim(to_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_to)) {
            to_val_eval = global.basic_variables[? key_to];
        } else {
            basic_syntax_error("FOR ... TO must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_RANGE");
            return;
        }
    }
    if (is_string(step_val_eval)) {
        var key_step = string_upper(string_trim(step_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_step)) {
            step_val_eval = global.basic_variables[? key_step];
        } else {
            // if user wrote STEP "" or a non-var string, reject
            basic_syntax_error("FOR ... STEP must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_STEP");
            return;
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Eval → start=" + string(start_val)
        + " | to(eval)=" + string(to_val_eval) + " [raw='" + to_expr + "']"
        + " | step(eval)=" + string(step_val_eval) + " [raw='" + step_expr + "']");

    // 3) Initialize loop var
    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }
    global.basic_variables[? varname] = start_val;
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Initialized variable " + varname + " = " + string(start_val));

    // 4) Push frame (legacy + inline stmt coordinates)
    var legacy_return_line = line_index;
    var loop_line_idx = line_index;
    var loop_stmt_idx = -1;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        loop_stmt_idx = global.interpreter_current_stmt_index + 1;
    }

    if (!ds_exists(global.for_stack, ds_type_stack)) {
        global.for_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Safety — created global.for_stack");
    }

    var frame = {
        varname     : varname,
        to          : to_val_eval,
        step        : step_val_eval,
        to_raw      : to_expr,       // keep raw for dynamic re-eval in NEXT
        step_raw    : step_expr,     // keep raw for dynamic re-eval in NEXT
        return_line : legacy_return_line,
        loop_line   : loop_line_idx,
        loop_stmt   : loop_stmt_idx
    };
    ds_stack_push(global.for_stack, frame);

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Pushed frame → {var=" + varname
        + ", to=" + string(to_val_eval)
        + ", step=" + string(step_val_eval)
        + ", return_line=" + string(legacy_return_line)
        + ", loop=(" + string(loop_line_idx) + "," + string(loop_stmt_idx) + ")}");
}


================================================================================

/// @file scripts/basic_cmd_gosub/basic_cmd_gosub.gml

/// @script basic_cmd_gosub
function basic_cmd_gosub(arg) {
    var raw = string_trim(arg);
    var colonPos = string_pos(":", raw);
    if (colonPos > 0) raw = string_trim(string_copy(raw, 1, colonPos - 1));
    var target = real(raw);

    // Ensure gosub stack exists
    if (!ds_exists(global.gosub_stack, ds_type_stack)) {
        global.gosub_stack = ds_stack_create();
    }

    // === CHANGE: capture statement-level resume point on this same line ===
    var resume_stmt = 0;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        resume_stmt = global.interpreter_current_stmt_index + 1;  // next stmt on this line
    }
    var frame = {
        kind: "stmt",                 // mark as statement-level resume
        line_index: line_index,       // current line index
        stmt_index: resume_stmt       // next statement to run on return
    };
    ds_stack_push(global.gosub_stack, frame);

    // Jump to target line
    global.interpreter_next_line = -1;
    var listSize = ds_list_size(global.line_list);
    for (var i = 0; i < listSize; i++) {
        if (ds_list_find_value(global.line_list, i) == target) {
            global.interpreter_next_line = i;
            break;
        }
    }
    if (global.interpreter_next_line == -1) {
        basic_syntax_error("GOSUB target line not found: " + string(target),
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_TARGET");
        return;
    }
}


================================================================================

/// @file scripts/basic_cmd_goto/basic_cmd_goto.gml

/// @function basic_cmd_goto(arg)
/// @description Sets the program counter to a new line number if it exists.
function basic_cmd_goto(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("GOTO START — Raw arg: '" + arg + "'");

    var trimmed_arg = string_trim(arg);
    var target_line = real(trimmed_arg);

    if (dbg_on(DBG_FLOW)) show_debug_message("GOTO: Parsed target line number: " + string(target_line));

    // Find the index in your line_list
    var index = -1;
	for (var i = 0; i < ds_list_size(global.line_list); i++) {
	    if (real(ds_list_find_value(global.line_list, i)) == target_line) {
	        index = i;
	        break;
	    }
	}

	
    if (index >= 0) {
        global.interpreter_next_line = index;
        if (dbg_on(DBG_FLOW)) show_debug_message("GOTO SUCCESS → Jumping to line " + string(target_line) + " (list index " + string(index) + ")");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("?GOTO ERROR: Line number " + string(target_line) + " not found in global.line_list");
    }
}


================================================================================

/// @file scripts/basic_cmd_if/basic_cmd_if.gml

/// @script basic_cmd_if
/// @description Block‐structured IF…THEN…ELSEIF…ELSE…ENDIF initializer
function basic_cmd_if(arg) {
    if (dbg_on(DBG_FLOW))  show_debug_message("IF START — Raw arg: '" + arg + "'");

    // 1) Compute the current line‐list index (we assume global.interpreter_next_line was pre-incremented)
    var current_index = global.interpreter_current_line_index;

// DEBUG: Show what's in the IF block map
    if (dbg_on(DBG_FLOW))  show_debug_message("DEBUG: current_index = " + string(current_index));
    var keys = ds_map_keys_to_array(global.if_block_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (dbg_on(DBG_FLOW))  show_debug_message("DEBUG: IF block map key[" + string(i) + "] = " + string(keys[i]));
    }



    // ── Legacy inline IF?  If no block metadata exists, invoke old handler ──
    if (!ds_map_exists(global.if_block_map, current_index)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("No block metadata for line " + string(current_index) + 
                           " — falling back to INLINE IF");
        basic_cmd_if_inline(arg);
        return;
    }

    // 2) Strip off the trailing THEN and isolate the condition
    var raw     = string_trim(arg);
    var upper   = string_upper(raw);
    var then_pos = string_pos("THEN", upper);
    if (then_pos <= 0) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: Missing THEN in '" + raw + "'");
        return;
    }
    var condition_text = string_trim(string_copy(raw, 1, then_pos - 1));
    if (dbg_on(DBG_FLOW))  show_debug_message("Parsed condition: '" + condition_text + "'");

    // 3) Evaluate the condition (supporting simple AND/OR)
    var result    = false;
    var logic_op  = "";
    var upcond    = string_upper(condition_text);
    if (string_pos("AND", upcond) > 0) logic_op = "AND";
    else if (string_pos("OR", upcond) > 0) logic_op = "OR";

    if (logic_op != "") {
        var parts = string_split(condition_text, logic_op);
        if (array_length(parts) != 2) {
            if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: Malformed " + logic_op + " condition: '" + condition_text + "'");
            return;
        }
        var res1 = basic_evaluate_condition(string_trim(parts[0]));
        var res2 = basic_evaluate_condition(string_trim(parts[1]));
        result = (logic_op == "AND") ? (res1 && res2) : (res1 || res2);
        if (dbg_on(DBG_FLOW))  show_debug_message("Combined condition (" + logic_op + "): " +
                           string(res1) + " " + logic_op + " " + string(res2) +
                           " = " + string(result));
    } else {
        result = basic_evaluate_condition(condition_text);
        if (dbg_on(DBG_FLOW))  show_debug_message("Single condition result: " + string(result));
    }

    // 4) Fetch the precomputed block‐metadata for this IF
    if (!ds_map_exists(global.if_block_map, current_index)) {
        if (dbg_on(DBG_FLOW))  show_debug_message("?IF ERROR: No IF block metadata for line index " + string(current_index));
        return;
    }
    var blockInfo    = global.if_block_map[? current_index];
    var firstBranch  = blockInfo[? "firstBranchIndex"];

    // 5) Push a new frame onto the IF‐stack
    var frame = ds_map_create();
    ds_map_add(frame, "startIndex",      current_index);
    ds_map_add(frame, "takenBranch",     result);
    ds_map_add(frame, "firstBranchIndex", firstBranch);
    ds_map_add(frame, "endifIndex",      blockInfo[? "endifIndex"]);
    ds_map_add(frame, "elseifIndices",   blockInfo[? "elseifIndices"]);  // a ds_list of indices
    ds_map_add(frame, "elseIndex",       blockInfo[? "elseIndex"]);      // –1 if none
    ds_stack_push(global.if_stack, frame);

    // 6) Jump into THEN‐block or skip to the first ELSEIF/ELSE/ENDIF
    if (result) {
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW))  show_debug_message("IF TRUE: entering THEN at index " + string(global.interpreter_next_line));
    } else {
        global.interpreter_next_line = firstBranch;
        if (dbg_on(DBG_FLOW))  show_debug_message("IF FALSE: skipping to index " + string(global.interpreter_next_line));
    }
}


================================================================================

/// @file scripts/basic_cmd_if_inline/basic_cmd_if_inline.gml

/// @script basic_cmd_if_inline
/// @description Single-line IF…THEN…ELSE. Executes THEN/ELSE here and tells Step which colon slot to resume at.
function basic_cmd_if_inline(arg) {
    // 1) Normalize and strip inline remarks first
    var s = string_trim(arg);
    s = strip_basic_remark(s);
    var s_upper = string_upper(s);

    // 2) Quote-safe, word-boundary keyword find
    var find_kw = function(_src, _up, _kw) {
        var L = string_length(_src), K = string_length(_kw), inq = false;
        for (var i = 1; i <= L - K + 1; i++) {
            var ch = string_char_at(_src, i);
            if (ch == "\"") { inq = !inq; continue; }
            if (inq) continue;

            if (string_copy(_up, i, K) == _kw) {
                var prev = (i == 1) ? " " : string_char_at(_up, i - 1);
                var next = (i + K <= L) ? string_char_at(_up, i + K) : " ";
                if ((prev == " " || prev == ":") && (next == " " || next == ":" || i + K - 1 == L)) {
                    return i;
                }
            }
        }
        return 0;
    };

    // 3) Require THEN
    var then_pos = find_kw(s, s_upper, "THEN");
		if (then_pos <= 0) {
		    basic_syntax_error("IF requires THEN", 
			basic_current_line_no(), 
			global.interpreter_current_stmt_index,
			"IF MISSING THEN");
		    return;
		}
    var else_pos = find_kw(s, s_upper, "ELSE");

    // 4) Slice parts
    var condition = string_trim(string_copy(s, 1, then_pos - 1));
    var then_action, else_action;
    if (else_pos > then_pos) {
        then_action = string_trim(string_copy(s, then_pos + 4, else_pos - (then_pos + 4)));
        else_action = string_trim(string_copy(s, else_pos + 4, string_length(s) - (else_pos + 3)));
    } else {
        then_action = string_trim(string_copy(s, then_pos + 4, string_length(s) - (then_pos + 3)));
        else_action = "";
    }

    // 5) Evaluate condition
    var cond = basic_evaluate_condition(condition);

    // 6) Split branches into colon segments
    var run_parts = cond ? (then_action != "" ? split_on_unquoted_colons(then_action) : []) 
                         : (else_action != "" ? split_on_unquoted_colons(else_action) : []);

    var p        = global.interpreter_current_stmt_index;
    var line_idx = global.interpreter_current_line_index;

    // 7) Runner: executes a single colon-segment with implicit-LET promotion
    var run_seg = function(seg) {
        seg = strip_basic_remark(string_trim(seg));
        if (seg == "") return;

        var sp = string_pos(" ", seg);
        var head = (sp > 0) ? string_upper(string_copy(seg, 1, sp - 1)) : string_upper(seg);

        var is_cmd =
              (head == "PRINT")   || (head == "LET")     || (head == "INPUT")   || (head == "CLS")
           || (head == "COLOR")   || (head == "BGCOLOR") || (head == "IF")      || (head == "FOR")
           || (head == "NEXT")    || (head == "WHILE")   || (head == "WEND")    || (head == "GOTO")
           || (head == "GOSUB")   || (head == "RETURN")  || (head == "DIM")     || (head == "END")
           || (head == "MODE")    || (head == "PSET")    || (head == "CHARAT")  || (head == "PRINTAT")
           || (head == "FONT")    || (head == "CLSCHAR") || (head == "PAUSE")
           || (head == "READ")    || (head == "RESTORE") || (head == "DATA")    || (head == "INKEY$");

        if (!is_cmd) {
            var d = 0, eq = 0, L = string_length(seg);
            for (var i = 1; i <= L; i++) {
                var ch = string_char_at(seg, i);
                if (ch == "(") d++;
                else if (ch == ")") d = max(0, d - 1);
                else if (ch == "=" && d == 0) { eq = i; break; }
            }
            if (eq > 0) seg = "LET " + seg;
        }

        var sp2 = string_pos(" ", seg);
        var cmd = (sp2 > 0) ? string_upper(string_copy(seg, 1, sp2 - 1)) : string_upper(seg);
        var arg = (sp2 > 0) ? string_trim(string_copy(seg, sp2 + 1, string_length(seg))) : "";

        if (cmd == "GOTO") {
            var line_target = real(arg);
            var idx = ds_list_find_index(global.line_list, line_target);
            if (idx >= 0) {
                global.interpreter_next_line = idx;
            } else {
                basic_syntax_error("GOTO target not found: " + string(line_target), 
				global.current_line_number, 
				p,
				"TARGET NOT FOUND");
            }
        } else {
            handle_basic_command(cmd, arg);
        }
    };

    // 8) Execute chosen branch (if any)
    for (var k = 0; k < array_length(run_parts); k++) {
        run_seg(run_parts[k]);
        if (global.program_has_ended || !global.interpreter_running) return; // error halted
    }

    // 9) Tell Step to resume after this IF colon-slot
    global.interpreter_use_stmt_jump = true;
    global.interpreter_target_line   = line_idx;
    global.interpreter_target_stmt   = p + 1;
}


================================================================================

/// @file scripts/basic_cmd_input/basic_cmd_input.gml

/// @script basic_cmd_input
/// @description Prompt the user with a text and await input into a variable

/// @script basic_cmd_input
/// @description Simple INPUT command that works with existing keyboard handling
function basic_cmd_input(arg) {
    var s = string_trim(arg);
    var prompt = "";
    var varName = "";

    // Parse INPUT syntax: INPUT "prompt", VAR or INPUT VAR
    var comma_pos = string_pos(",", s);
    var semicolon_pos = string_pos(";", s);
    
    // Find first separator (comma or semicolon)
    var sep_pos = 0;
    if (comma_pos > 0 && semicolon_pos > 0) {
        sep_pos = min(comma_pos, semicolon_pos);
    } else if (comma_pos > 0) {
        sep_pos = comma_pos;
    } else if (semicolon_pos > 0) {
        sep_pos = semicolon_pos;
    }
    
    if (sep_pos > 0) {
        // Has prompt: INPUT "prompt", VAR
        prompt = string_trim(string_copy(s, 1, sep_pos - 1));
        varName = string_upper(string_trim(string_copy(s, sep_pos + 1, string_length(s) - sep_pos)));
        
        // Remove quotes from prompt if present
        if (string_length(prompt) >= 2 
            && string_char_at(prompt, 1) == "\"" 
            && string_char_at(prompt, string_length(prompt)) == "\"") {
            prompt = string_copy(prompt, 2, string_length(prompt) - 2);
        }
    } else {
        // No prompt: INPUT VAR
        varName = string_upper(s);
        //prompt = "? "; // Default prompt
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Variable='" + varName + "', Prompt='" + prompt + "'");
    
    // Display the prompt
    if (prompt != "") {
        ds_list_add(global.output_lines, prompt);
        ds_list_add(global.output_colors, global.basic_text_color);
    }
    
    // Set up input state for your existing keyboard handler
    global.awaiting_input = true;
    global.pause_mode = false;
    global.input_expected = true;
    global.input_target_var = varName;
    global.interpreter_input = ""; // Clear any existing input buffer
    
// Initialize the variable only if absent; avoid numeric 0 pre-seed
 varName = basic_normvar(varName); // ensure canonical now
if (!ds_map_exists(global.basic_variables, varName)) {
    // Seed both kinds to empty string; numeric coercion happens on commit
    global.basic_variables[? varName] = "";
}

    
    if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Awaiting input for variable " + varName);
}
/*function basic_cmd_input(arg) {
    var s = string_trim(arg);
    var rawPrompt = "";
    var varName   = "";

    // 1) Primary split: first top-level ';' or ',' (quote-aware)
    var sep_pos = 0;
    var sep_ch  = "";
    var in_q = false;
    var L = string_length(s);
    for (var i = 1; i <= L; i++) {
        var ch = string_char_at(s, i);
        if (ch == "\"") { in_q = !in_q; continue; }
        if (!in_q && (ch == ";" || ch == ",")) { sep_pos = i; sep_ch = ch; break; }
    }

    if (sep_pos > 0) {
        rawPrompt = string_trim(string_copy(s, 1, sep_pos - 1));
        varName   = string_upper(string_trim(string_copy(s, sep_pos + 1, L - sep_pos)));
    } else {
        // 2) Fallback: starts with a quoted prompt but no separator was detected (e.g., `"PROMPT" ; VAR`)
        if (L >= 2 && string_char_at(s, 1) == "\"") {
            // find closing quote
            var close = 0;
            for (var k = 2; k <= L; k++) {
                if (string_char_at(s, k) == "\"") { close = k; break; }
            }
            if (close > 0) {
                rawPrompt = string_copy(s, 2, close - 2); // inside quotes
                var rest = string_trim(string_copy(s, close + 1, L - close));
                // consume optional separator and following spaces
                if (string_length(rest) > 0) {
                    var first = string_char_at(rest, 1);
                    if (first == ";" || first == ",") {
                        rest = string_trim(string_delete(rest, 1, 1));
                    }
                }
                varName = string_upper(string_trim(rest));
            } else {
                // no closing quote → treat entire thing as var
                varName = string_upper(s);
            }
        } else {
            // no prompt provided; entire arg is the variable name
            varName = string_upper(s);
        }
    }

    // 3) If prompt still has surrounding quotes, strip them
    if (string_length(rawPrompt) >= 2
        && string_char_at(rawPrompt, 1) == "\""
        && string_char_at(rawPrompt, string_length(rawPrompt)) == "\"")
    {
        rawPrompt = string_copy(rawPrompt, 2, string_length(rawPrompt) - 2);
    }

    // 4) Emit the prompt (append a space if missing) 
    if (rawPrompt != "") {
        if (string_char_at(rawPrompt, string_length(rawPrompt)) != " ") rawPrompt += " ";
        ds_list_add(global.output_lines, rawPrompt);
        ds_list_add(global.output_colors, global.basic_text_color);
        if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Prompt='" + rawPrompt + "'");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: No prompt (default '? ')");
    }

    // 5) Seed the variable (string vars end with $, others numeric)
    if (string_length(varName) > 0 && string_char_at(varName, string_length(varName)) == "$") {
        global.basic_variables[? varName] = "";
    } else {
        global.basic_variables[? varName] = "0";
    }

    // 6) Enter input mode
    global.awaiting_input   = true;
    global.pause_mode       = false;
    global.input_expected   = true;
    global.input_target_var = varName;

    if (dbg_on(DBG_FLOW)) show_debug_message("INPUT: Awaiting input for variable " + varName);
}


================================================================================

/// @file scripts/basic_cmd_let/basic_cmd_let.gml

/// === BEGIN: basic_cmd_let ===
/// LET handler with modal INKEY$ support and array handling
function basic_cmd_let(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("LET: Raw input: '" + arg + "'");

    // Split "NAME = EXPR"
    var eq = string_pos("=", arg);
    if (eq <= 0) {
        basic_syntax_error("LET requires '='", /*line*/ undefined, global.interpreter_current_stmt_index, "LET_MISSING_EQUALS");
        return;
    }

    var varName = string_trim(string_copy(arg, 1, eq - 1));
    var exprStr = string_trim(string_copy(arg, eq + 1, string_length(arg) - eq));

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("LET: Parsed variable name: '" + varName + "'");
        show_debug_message("LET: Parsed expression    : '" + exprStr + "'");
    }

    // ---------- MODAL INKEY$: pure RHS detection ----------
    var expr_uc = string_upper(exprStr);
    var is_pure_inkey = false;

    // Allow "INKEY$" or "INKEY$()" with arbitrary spaces
    // Strip whitespace
    var expr_compact = string_replace_all(string_replace_all(expr_uc, " ", ""), "\t", "");
    if (expr_compact == "INKEY$" || expr_compact == "INKEY$()") is_pure_inkey = true;

    if (is_pure_inkey) {

        // 1) If we are resuming from a prior wait and have a captured char, COMMIT now.
        if (variable_global_exists("inkey_waiting") && global.inkey_waiting) {
            if (variable_global_exists("inkey_captured") && string_length(global.inkey_captured) > 0) {
                var ch_commit = string(global.inkey_captured);
                
                // Handle array vs regular variable for INKEY$ assignment
                if (basic_is_array_reference(varName)) {
                    basic_assign_to_array(varName, ch_commit);
                } else {
                    var k = basic_normvar(varName);
                    global.basic_variables[? k] = ch_commit;
                }

                // Clear modal flags
                global.inkey_captured   = "";
                global.inkey_waiting    = false;
                global.pause_in_effect  = false;
                global.inkey_target_var = "";

                if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: committed '" + ch_commit + "' to " + varName + " (resume)");
                return;
            }

            // Still waiting, keep paused this frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: still waiting (no captured char yet)");
            return;
        }

        // 2) Not waiting yet – FAST PATH: assign immediately if queue already has a key
        // Support either queue name (__inkey_queue primary; inkey_queue legacy)
        var _q = undefined;
        if (ds_exists(global.__inkey_queue, ds_type_queue)) _q = global.__inkey_queue;
        else if (variable_global_exists("inkey_queue") && ds_exists(global.inkey_queue, ds_type_queue)) _q = global.inkey_queue;

        if (!is_undefined(_q) && ds_queue_size(_q) > 0) {
            var ch2 = ds_queue_dequeue(_q);
            if (is_real(ch2)) ch2 = chr(ch2);
            
            // Handle array vs regular variable for INKEY$ assignment
            if (basic_is_array_reference(varName)) {
                basic_assign_to_array(varName, string(ch2));
            } else {
                var k = basic_normvar(varName);
                global.basic_variables[? k] = string(ch2);
            }
            
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: fast-path assign '" + string(ch2) + "' to " + varName);
            return;
        }

        // 3) Arm modal wait: no key ready yet → pause interpreter and let Step capture ONE key
        global.inkey_waiting    = true;
        global.pause_in_effect  = true;
        global.inkey_target_var = varName; // Store the full variable name including array syntax
        global.inkey_captured   = "";
        if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: armed modal wait for " + varName);
        return;
    }
    // ---------- END MODAL INKEY$ special case ----------

    // ---------- Default LET path: evaluate expression and assign ----------
    var tokens  = basic_tokenize_expression_v2(exprStr);
    var postfix = infix_to_postfix(tokens);
    var val     = evaluate_postfix(postfix);

    // Check if this is an array assignment
    if (basic_is_array_reference(varName)) {
        basic_assign_to_array(varName, val);
        return;
    }

    // Regular variable assignment (existing logic)
    var k = basic_normvar(varName);

    // Coerce based on variable sigil: trailing $ means string var
    var is_string_var = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");
    if (is_string_var) {
        global.basic_variables[? k] = string(val);
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned string value: '" + string(val) + "' to '" + k + "'");
    } else {
        // Numeric: if it looks numeric, coerce to real; else 0 (or keep as-is if you prefer)
        if (is_real(val)) {
            global.basic_variables[? k] = val;
        } else if (basic_looks_numeric(string(val))) {
            global.basic_variables[? k] = real(val);
        } else {
            global.basic_variables[? k] = 0;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned value: '" + string(global.basic_variables[? k]) + "' to '" + k + "'");
    }
}

/// Helper function to check if a variable name is an array reference
function basic_is_array_reference(varName) {
    var open_paren = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
    return (open_paren > 0 && close_paren > open_paren);
}

/// Helper function to assign values to arrays
function basic_assign_to_array(varName, val) {
    // Parse array name and index from varName like "TOPIC$(I)"
    var open_paren = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
    
    if (open_paren <= 0 || close_paren <= open_paren) {
        basic_syntax_error("Invalid array syntax: " + varName);
        return;
    }
    
    var arrayName = string_trim(string_copy(varName, 1, open_paren - 1));
    var indexExpr = string_trim(string_copy(varName, open_paren + 1, close_paren - open_paren - 1));
    
    // Normalize the array name
    var normalizedArrayName = basic_normvar(arrayName);
    
    // Evaluate the index expression
    var indexTokens = basic_tokenize_expression_v2(indexExpr);
    var indexPostfix = infix_to_postfix(indexTokens);
    var indexVal = evaluate_postfix(indexPostfix);
    
    // Convert index to integer
    var index = floor(real(indexVal));
    
    if (dbg_on(DBG_FLOW)) {
        show_debug_message("ARRAY ASSIGN: Array='" + normalizedArrayName + "' Index=" + string(index) + " Value='" + string(val) + "'");
    }
    
    // Ensure the array exists in global.basic_arrays
    if (!ds_map_exists(global.basic_arrays, normalizedArrayName)) {
        // Create the array if it doesn't exist
        global.basic_arrays[? normalizedArrayName] = ds_list_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: Created new array '" + normalizedArrayName + "'");
    }
    
    var arrayList = global.basic_arrays[? normalizedArrayName];
    
    // Ensure the list is big enough for this index
    while (ds_list_size(arrayList) <= index) {
        ds_list_add(arrayList, 0); // Add default values
    }
    
    // Determine if this should be stored as string or number based on array name
    var is_string_array = (string_length(normalizedArrayName) > 0) && (string_char_at(normalizedArrayName, string_length(normalizedArrayName)) == "$");
    
    if (is_string_array) {
        ds_list_replace(arrayList, index, string(val));
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: Set " + normalizedArrayName + "[" + string(index) + "] = '" + string(val) + "' (string)");
    } else {
        // Numeric array
        var numVal = is_real(val) ? val : (basic_looks_numeric(string(val)) ? real(val) : 0);
        ds_list_replace(arrayList, index, numVal);
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: Set " + normalizedArrayName + "[" + string(index) + "] = " + string(numVal) + " (numeric)");
    }
}
/// === END: basic_cmd_let ===

================================================================================

/// @file scripts/basic_cmd_locate/basic_cmd_locate.gml

// =================================================================
// LOCATE command - set cursor position for next PRINT
// =================================================================
function basic_cmd_locate(arg) {
    if (global.current_mode < 1) {
        // In text mode, just ignore or show message
        if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE: Not implemented in text mode");
        return;
    }
    
    var args = basic_parse_csv_args(arg);
    if (array_length(args) < 2) {
        if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE requires 2 arguments: row, col");
        return;
    }
    
    var row = real(basic_evaluate_expression_v2(string_trim(args[0])));
    var col = real(basic_evaluate_expression_v2(string_trim(args[1])));
    
    // BASIC typically uses 1-based coordinates, convert to 0-based
    row = max(0, min(24, row - 1));
    col = max(0, min(39, col - 1));
    
    // Store cursor position in globals for PRINT to use
    global.mode1_cursor_x = col;
    global.mode1_cursor_y = row;
    
    if (dbg_on(DBG_FLOW)) show_debug_message("LOCATE: Set cursor to (" + string(col) + "," + string(row) + ")");
}

================================================================================

/// @file scripts/basic_cmd_mode/basic_cmd_mode.gml

// FILE: scripts/basic_cmd_mode.gml
// FUNCTION: basic_cmd_mode(arg)
// BEHAVIOR: MODE 1 optionally accepts a size (8,16,32). Sets global.mode1_cell_px,
//           selects a size-matched default font from global.font_sheets, and switches rooms when needed.
function basic_cmd_mode(arg) {
    var mode    = 0;
    var size_px = -1;
    // --- Parse "1" or "1,16" (CSV-aware) ---
    var s = string_trim(arg);
    if (string_pos(",", s) > 0) {
        var parts = basic_parse_csv_args(s);
        mode = real(string_trim(parts[0]));
        if (array_length(parts) >= 2) size_px = real(string_trim(parts[1]));
    } else {
        mode = real(s);
    }
    // --- Validate mode key in registry ---
    if (!ds_map_exists(global.mode_rooms, mode)) {
        basic_show_message("Invalid MODE: " + string(mode));
        return;
    }
    // --- MODE 1: accept 8/16/32; default 32 for back-compat ---
// --- Only MODE 1 supports size selection (8/16/32), default 32 ---
if (mode == 1) {
    if (size_px != 8 && size_px != 16 && size_px != 32) size_px = 32;
    global.mode1_cell_px = size_px;
    if (dbg_on(DBG_FLOW)) show_debug_message("MODE 1: cell size set to " + string(size_px) + " px");

    // Pick a matching DEFAULT_* only if user hasn't FONTSET-locked a font
    if (!variable_global_exists("font_locked") || !global.font_locked) {
        var _key = "DEFAULT_32";
        if (size_px == 16) _key = "DEFAULT_16";
        else if (size_px == 8) _key = "DEFAULT_8";

        if (ds_map_exists(global.font_sheets, _key)) {
            global.active_font_name   = _key;
            global.active_font_sprite = global.font_sheets[? _key];
            if (dbg_on(DBG_FLOW)) show_debug_message("MODE: active font -> " + _key);
        }
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("MODE: font locked by user (" + global.active_font_name + "), leaving as-is");
    }
}

    // --- If mode already active, do not switch rooms (we still updated size/font above) ---
    if (mode == global.current_mode) {
        if (dbg_on(DBG_FLOW)) show_debug_message("MODE already set to " + string(mode) + "; no room switch needed.");
        return;
    }
    // --- Switch to the room for the requested mode ---
    global.current_mode = mode;
    var target_room = ds_map_find_value(global.mode_rooms, mode);
    if (dbg_on(DBG_FLOW)) show_debug_message("Switching to MODE " + string(mode) + " → room: " + string(target_room));
    room_goto(target_room);
}

================================================================================

/// @file scripts/basic_cmd_next/basic_cmd_next.gml

/// @function basic_cmd_next(arg)
/// @description Handles BASIC NEXT loop continuation (legacy-compatible; optional inline-colon support)
function basic_cmd_next(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Entering handler with arg: '" + string(arg) + "'");

    if (!ds_exists(global.for_stack, ds_type_stack) || ds_stack_empty(global.for_stack)) {
        basic_syntax_error("NEXT without matching FOR",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_MISMATCH");
        return;
    }

    var frame = ds_stack_top(global.for_stack);

    // Optional check: NEXT I
    var user_var = string_trim(string_upper(string(arg)));
    if (user_var != "" && is_struct(frame) && variable_struct_exists(frame, "varname")) {
        if (string_upper(frame.varname) != user_var && dbg_on(DBG_FLOW)) {
            show_debug_message("NEXT: WARNING — NEXT " + user_var + " does not match active FOR var " + string(frame.varname));
        }
    }

    var varname     = frame.varname;
    var to_val      = frame.to;
    var step_val    = frame.step;
    var return_line = frame.return_line;
    var loop_line   = (variable_struct_exists(frame, "loop_line")) ? frame.loop_line : -1;
    var loop_stmt   = (variable_struct_exists(frame, "loop_stmt")) ? frame.loop_stmt : -1;

    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }

    // Re-evaluate TO / STEP each iteration if they weren’t numeric
    if (!is_real(to_val)) {
        var to_expr_local = variable_struct_exists(frame, "to_raw") ? frame.to_raw : to_val;
        to_val = basic_evaluate_expression_v2(to_expr_local);
        if (is_string(to_val)) {
            var key_to = string_upper(string_trim(to_expr_local));
            if (!ds_map_exists(global.basic_variables, key_to)) {
                basic_syntax_error("FOR ... TO must be numeric",
                    global.current_line_number, global.interpreter_current_stmt_index, "FOR_TO_NONNUM");
                return;
            }
            to_val = global.basic_variables[? key_to];
        }
        frame.to = to_val;
    }
    if (!is_real(step_val)) {
        var step_expr_local = variable_struct_exists(frame, "step_raw") ? frame.step_raw : step_val;
        step_val = basic_evaluate_expression_v2(step_expr_local);
        if (is_string(step_val)) {
            var key_step = string_upper(string_trim(step_expr_local));
            if (!ds_map_exists(global.basic_variables, key_step)) {
                // default if someone did STEP with a non-numeric symbol
                step_val = 1;
            } else {
                step_val = global.basic_variables[? key_step];
            }
        }
        frame.step = step_val;
    }

    var current = global.basic_variables[? varname];

    if (step_val == 0) {
        var inferred = (to_val >= current) ? 1 : -1;
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: STEP=0; defaulting to " + string(inferred));
        step_val = inferred;
        frame.step = step_val;
    }

    current += step_val;
    global.basic_variables[? varname] = current;

    var continue_loop = (step_val > 0) ? (current <= to_val) : (current >= to_val);
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: to=" + string(to_val)
        + " step=" + string(step_val) + " current=" + string(current)
        + " → continue=" + string(continue_loop));

    if (continue_loop) {
        var have_stmt_jump =
            variable_global_exists("interpreter_target_line") &&
            variable_global_exists("interpreter_target_stmt");

        if (have_stmt_jump && loop_line >= 0 && loop_stmt >= 0) {
            global.interpreter_target_line = loop_line;
            global.interpreter_target_stmt = loop_stmt;
            if (variable_global_exists("interpreter_use_stmt_jump")) {
                global.interpreter_use_stmt_jump = true;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Inline jump → (" + string(loop_line) + "," + string(loop_stmt) + ")");
        } else {
            global.interpreter_next_line = return_line + 1; // legacy line jump
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Legacy jump → line index " + string(global.interpreter_next_line));
        }
    } else {
        ds_stack_pop(global.for_stack);
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Loop complete — popped FOR frame");
    }
}


================================================================================

/// @file scripts/basic_cmd_pause/basic_cmd_pause.gml

function basic_cmd_pause() {
    if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: Execution paused. Waiting for user to press ENTER...");

	global.pause_in_effect = true;
    global.awaiting_input = true;
    global.input_target_var = ""; // No variable to store
    global.pause_mode = true;     // Optional flag if you want to treat it differently in draw
	global.input_expected = false;

}


================================================================================

/// @file scripts/basic_cmd_print/basic_cmd_print.gml

// === BEGIN: basic_cmd_print ===
function basic_cmd_print(arg, line_number) {

    if (!ds_exists(global.output_lines, ds_type_list))  global.output_lines  = ds_list_create();
    if (!ds_exists(global.output_colors, ds_type_list)) global.output_colors = ds_list_create();

    var suppress_newline = false;

    // Check for and remove trailing semicolon
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Trailing semicolon detected; suppressing newline");
    }

    arg = string_trim(arg);
    var output = "";

    // Split into parts by semicolon for multi-part print
    var parts = split_on_unquoted_semicolons(arg);

    // --- REMOVED: naive INKEY$ pre-scan that falsely paused inside quoted strings ---

    // --- NEW: also treat commas as PRINT argument separators ---
    // Flatten: for each semicolon part, split by unquoted commas and append
    var _flat = [];
    for (var _i = 0; _i < array_length(parts); _i++) {
        var _seg = string_trim(parts[_i]);
        if (_seg == "") continue;

        var _comma_parts = split_on_unquoted_commas(_seg);
        if (array_length(_comma_parts) <= 1) {
            _flat[array_length(_flat)] = _seg;
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: splitting by comma → " + string(_comma_parts));
            for (var _j = 0; _j < array_length(_comma_parts); _j++) {
                var __p = string_trim(_comma_parts[_j]);
                if (__p != "") _flat[array_length(_flat)] = __p;
            }
        }
    }
    parts = _flat;

    for (var i = 0; i < array_length(parts); i++) {
        var part = parts[i];

        // Empty segment (e.g., consecutive separators) → nothing to do
        if (string_length(part) == 0) {
            continue;
        }

        var _print_compact = (array_length(parts) > 1); // compact formatting when multiple args

        var treat_as_literal = false;

        if (is_quoted_string(part)) {
            var inner = string_copy(part, 2, string_length(part) - 2);
            if (!string_pos("+", inner) && !string_pos("-", inner) && !string_pos("*", inner) && !string_pos("/", inner)) {
                treat_as_literal = true;
            }
        }

        if (treat_as_literal) {
            var _inner = string_copy(part, 2, string_length(part) - 2);
            _inner = string_replace_all(_inner, "\"\"", "\""); // unescape doubled quotes "" → "
            output += _inner;
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " is string literal → " + _inner);
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Part " + string(i) + " is expression → " + part);
            var tokens = basic_tokenize_expression_v2(part);
            if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Tokens = " + string(tokens));

            var postfix = infix_to_postfix(tokens);
            if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Postfix = " + string(postfix));

            var result = evaluate_postfix(postfix);
            if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Evaluated result = " + string(result));

            // === INKEY$ modal sentinel handling (defer PRINT until key captured) ===
            if (is_string(result) && result == "<<INKEY_WAIT>>") {
                if (is_undefined(global.inkey_waiting)) global.inkey_waiting = false;
                if (is_undefined(global.inkey_captured)) global.inkey_captured = "";
                global.inkey_waiting    = true;
                global.inkey_captured   = "";
                global.pause_in_effect  = true;   // Step will halt advancement and capture key
                global.awaiting_input   = false;
                if (dbg_on(DBG_FLOW))  show_debug_message("INKEY_WAIT: Deferring PRINT until a key is captured.");
                return; // abort PRINT now; we'll re-run this statement after resume
            }
            // === END ===

            if (is_real(result)) {
                var _text_value;
                if (_print_compact) {
                    // when multiple PRINT args, don’t pad → prevents mid-number wraps
                    _text_value = string(result);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (compact) → '" + _text_value + "'");
                } else {
                    // ORIGINAL single-expr formatting (keep your look & feel)
                    if (frac(result) == 0) {
                        _text_value = string(round(result)); // whole number → no decimal
                    } else {
                        _text_value = string_format(result, 12, 8); // your existing padded decimal format
                    }
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (padded) → '" + _text_value + "'");
                }
                output += _text_value;
            } else {
                output += string(result);
            }
        }
    }

    // Append to line buffer with wrap
    var wrap_width = 40;
    var full_line = global.print_line_buffer + output;

    while (string_length(full_line) > wrap_width) {
        var line = string_copy(full_line, 1, wrap_width);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, global.current_draw_color);
        full_line = string_copy(full_line, wrap_width + 1, string_length(full_line) - wrap_width);
    }

    global.print_line_buffer = full_line;

    if (!suppress_newline) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Line committed → " + global.print_line_buffer);
        global.print_line_buffer = "";
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("PRINT: Output buffered without newline → " + global.print_line_buffer);
    }
}
// === END: basic_cmd_print ===


================================================================================

/// @file scripts/basic_cmd_print_mode1/basic_cmd_print_mode1.gml

// @function basic_cmd_print_mode1(arg)
/// @description MODE 1 version of PRINT that writes to the grid using cursor position
function basic_cmd_print_mode1(arg) {
    // Initialize cursor if not set
    if (!variable_global_exists("mode1_cursor_x")) global.mode1_cursor_x = 0;
    if (!variable_global_exists("mode1_cursor_y")) global.mode1_cursor_y = 0;
    
    var suppress_newline = false;
    
    // Check for trailing semicolon
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Semicolon detected, suppressing newline");
    }
    
    arg = string_trim(arg);
    if (arg == "") {
        if (!suppress_newline) {
            // Move cursor to next line
            global.mode1_cursor_x = 0;
            global.mode1_cursor_y = min(24, global.mode1_cursor_y + 1);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Empty line, cursor now at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
        }
        return;
    }
    
    var output_text = "";
    
    // Handle simple quoted strings directly
    if (string_length(arg) >= 2 && string_char_at(arg, 1) == "\"" && string_char_at(arg, string_length(arg)) == "\"") {
        output_text = string_copy(arg, 2, string_length(arg) - 2);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Simple quoted string: '" + output_text + "'");
    } else {
        // Evaluate as expression for variables, numbers, etc.
        try {
            var tokens = basic_tokenize_expression_v2(arg);
            var postfix = infix_to_postfix(tokens);
            var result = evaluate_postfix(postfix);
            output_text = string(result);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Evaluated expression '" + arg + "' to: '" + output_text + "'");
        } catch (e) {
            // If evaluation fails, treat as literal string
            output_text = arg;
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Expression failed, using literal: '" + output_text + "'");
        }
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Starting at cursor (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
    
    // Print each character at cursor position using mode1_grid_set
    for (var i = 0; i < string_length(output_text); i++) {
        var ch = ord(string_char_at(output_text, i + 1));
        
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Setting char '" + string_char_at(output_text, i + 1) + "' (code " + string(ch) + ") at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
        
        // Use mode1_grid_set to place character
        mode1_grid_set(global.mode1_cursor_x, global.mode1_cursor_y, ch, c_white, c_black);
        
        // Advance cursor
        global.mode1_cursor_x++;
        if (global.mode1_cursor_x >= 40) {
            global.mode1_cursor_x = 0;
            global.mode1_cursor_y = min(24, global.mode1_cursor_y + 1);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Wrapped to next line, cursor now at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
        }
    }
    
    if (!suppress_newline) {
        global.mode1_cursor_x = 0;
        global.mode1_cursor_y = min(24, global.mode1_cursor_y + 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Newline, cursor now at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT MODE1: Finished printing '" + output_text + "', cursor at (" + string(global.mode1_cursor_x) + "," + string(global.mode1_cursor_y) + ")");
}

================================================================================

/// @file scripts/basic_cmd_printat/basic_cmd_printat.gml

function basic_cmd_printat(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== PRINTAT DEBUG START ===");
    if (dbg_on(DBG_FLOW)) show_debug_message("Raw arg: '" + string(arg) + "'");

    // Parse arguments (x, y, "string" [, fg [, bg]])
    var args = basic_parse_csv_args(arg);
    if (dbg_on(DBG_FLOW)) show_debug_message("Parsed " + string(array_length(args)) + " arguments");
    if (array_length(args) < 3) {
        if (dbg_on(DBG_FLOW)) show_debug_message("❌ PRINTAT ERROR: Not enough arguments.");
        return;
    }

    // Evaluate x and y using the SAME expression engine your FOR header uses
    var x_expr = string_trim(args[0]);
    var y_expr = string_trim(args[1]);
    var _x     = floor(real(basic_evaluate_expression_v2(x_expr)));
    var _y     = floor(real(basic_evaluate_expression_v2(y_expr)));
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: start=(" + string(_x) + "," + string(_y) + ")");

	// 3rd argument: literal if quoted, otherwise evaluate expression → string
	var str_expr = string_trim(args[2]);

	if (string_length(str_expr) >= 2) {
		var first = string_char_at(str_expr, 1);
		var last  = string_char_at(str_expr, string_length(str_expr));
		if ((first == "\"" || first == "'") && first == last) {
		    // literal
		    str_expr = string_copy(str_expr, 2, string_length(str_expr) - 2);
		    var str = str_expr;
		} else {
		    // expression (supports variables, STR$, concatenation, etc.)
		    var _val = basic_evaluate_expression_v2(str_expr);
		    var str  = string(_val);
		}
	} else {
		var str = string(basic_evaluate_expression_v2(str_expr));
	}


    // Optional colors
    var fg = (array_length(args) > 3) ? basic_parse_color(string_trim(args[3])) : c_white;
    var bg = (array_length(args) > 4) ? basic_parse_color(string_trim(args[4])) : c_black;

    // Grid and bounds
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) { if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: grid not found"); return; }
    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _y < 0 || _x >= cols || _y >= rows) {
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: start out of bounds"); return;
    }

    // Write characters, clamped to right edge
    var max_len = min(string_length(str), cols - _x);
    if (dbg_on(DBG_FLOW)) show_debug_message("PRINTAT: str len=" + string(string_length(str)) + " -> max_len=" + string(max_len));
    for (var j = 0; j < max_len; j++) {
        var ch = ord(string_char_at(str, j + 1));
        mode1_grid_set(_x + j, _y, ch, fg, bg);
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("✅ PRINTAT complete");
    if (dbg_on(DBG_FLOW)) show_debug_message("=== PRINTAT DEBUG END ===");
}


================================================================================

/// @file scripts/basic_cmd_pset/basic_cmd_pset.gml

function basic_cmd_pset(arg) {
    var args = string_split(arg, ",");
    if (array_length(args) < 5) {
        if (dbg_on(DBG_FLOW))  show_debug_message("PSET requires 5 arguments: x, y, char, fg, bg");
        return;
    }
    
    // Evaluate expressions for x, y, and char (they might be variables or expressions)
    var x_val = real(basic_evaluate_expression_v2(string_trim(args[0])));
    var y_val = real(basic_evaluate_expression_v2(string_trim(args[1])));
    var char_index = real(basic_evaluate_expression_v2(string_trim(args[2])));
    
    var fg_str = string_upper(string_trim(args[3]));
    var bg_str = string_upper(string_trim(args[4]));
    
    var fg_color = ds_map_exists(global.colors, fg_str) ? global.colors[? fg_str] : c_white;
    var bg_color = ds_map_exists(global.colors, bg_str) ? global.colors[? bg_str] : c_black;
    
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (instance_exists(grid_obj)) {
        var cols = 40;
        var rows = 25;
        if (x_val >= 0 && x_val < cols && y_val >= 0 && y_val < rows) {
            var index = x_val + y_val * cols;
            grid_obj.grid[index].char = char_index;
            grid_obj.grid[index].fg = fg_color;
            grid_obj.grid[index].bg = bg_color;
            if (dbg_on(DBG_FLOW))  show_debug_message("PSET: Set tile at (" + string(x_val) + "," + string(y_val) + ") to char=" + string(char_index));
        } else {
            if (dbg_on(DBG_FLOW))  show_debug_message("PSET: coordinates out of bounds: (" + string(x_val) + "," + string(y_val) + ")");
        }
    } else {
        if (dbg_on(DBG_FLOW))  show_debug_message("PSET: No grid object found");
    }
}

================================================================================

/// @file scripts/basic_cmd_read/basic_cmd_read.gml

/// @func basic_cmd_read(arg)
/// @desc READ [@stream,] var1[, var2 ...]
///       Pulls values from pre-scanned DATA streams into variables (incl. arrays).
function basic_cmd_read(arg) {
    var s = strip_basic_remark(string_trim(arg));
    if (s == "") { 
    basic_syntax_error("READ requires variable names", 
        global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
    return; 
	}	
    // Optional @stream prefix: READ @name, A, B$
    var stream_name = "";
    var dest_text   = s;
    if (string_char_at(s, 1) == "@") {
        var _depth = 0, inq = false, cut = 0, L = string_length(s);
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") {
                var nxt = (i < L) ? string_char_at(s, i + 1) : "";
                if (inq && nxt == "\"") { i++; continue; }
                inq = !inq; continue;
            }
            if (inq) continue;
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (ch == ",") { cut = i; break; }
        }
        if (cut <= 0) { 
            basic_syntax_error("READ expected ',' after @name in '" + s + "'", 
                global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
            return; 
        }
        stream_name = string_trim(string_copy(s, 2, cut - 2)); // exclude '@'
        dest_text   = string_trim(string_copy(s, cut + 1, L - cut));
    }
    if (!ds_exists(global.data_streams, ds_type_map) || !ds_map_exists(global.data_streams, stream_name)) {
        basic_syntax_error("READ stream not found: '" + stream_name + "'", 
            global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
        return;
    }
    var stream = ds_map_find_value(global.data_streams, stream_name);
    var lst    = stream.list;
    var dests = split_on_unquoted_commas(dest_text);
    for (var di = 0; di < array_length(dests); di++) {
        if (stream.ptr >= ds_list_size(lst)) {
            var msg = "?READ ERROR: Out of DATA on stream '" + stream_name + "'";
            if (dbg_on(DBG_FLOW))  show_debug_message(msg);
            // Graceful stop: reuse your END command
            handle_basic_command("END", "");
            return;
        }
        var v = lst[| stream.ptr];
        stream.ptr++;
        var dest = string_trim(dests[di]);
        
        // NEW: Validate variable name
        if (dest == "" || !is_letter(string_char_at(dest, 1))) {
            basic_syntax_error("Invalid variable name in READ: " + dest, 
                global.current_line_number, global.interpreter_current_stmt_index, "READ_SYNTAX");
            return;
        }
        
        var rhs;
        if (is_string(v)) {
            var escaped = string_replace_all(v, "\"", "\"\"");
            rhs = "\"" + escaped + "\"";
        } else {
            rhs = string(v);
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("READ: stream='" + stream_name + "' → " + dest + "=" + rhs);
        // Route through the existing LET path so arrays etc. work
        basic_cmd_let(dest + "=" + rhs);
    }
}

================================================================================

/// @file scripts/basic_cmd_rem/basic_cmd_rem.gml

function basic_cmd_rem() {
    // Do nothing — comment line
}


================================================================================

/// @file scripts/basic_cmd_restore/basic_cmd_restore.gml

/// @func basic_cmd_restore(arg)
/// @desc RESTORE [@stream]    — reset the read pointer to the start of the stream.
///       No arg resets the default stream "".
function basic_cmd_restore(arg) {
    var s = strip_basic_remark(string_trim(arg));
    var stream_name = "";
    // Optional @name or bare name
    if (s != "") {
        if (string_char_at(s, 1) == "@") {
            stream_name = string_trim(string_copy(s, 2, string_length(s) - 1)); // drop '@'
        } else {
            stream_name = s; // bare stream name
        }
    }
	if (!ds_exists(global.data_streams, ds_type_map) || !ds_map_exists(global.data_streams, stream_name)) {
	    basic_syntax_error("RESTORE stream not found: " + stream_name, 
	        global.current_line_number, global.interpreter_current_stmt_index, "DATA_STREAM");
	    return;
	}
    var st = ds_map_find_value(global.data_streams, stream_name);
    st.ptr = 0;
    if (dbg_on(DBG_FLOW)) {
        var cnt = ds_list_size(st.list);
        if (dbg_on(DBG_FLOW)) show_debug_message("RESTORE: stream='" + stream_name + "' ptr=0 (size=" + string(cnt) + ")");
    }
}

================================================================================

/// @file scripts/basic_cmd_return/basic_cmd_return.gml

/// @file scripts/basic_cmd_return/basic_cmd_return.gml
function basic_cmd_return() {
    if (ds_stack_empty(global.gosub_stack)) {
        basic_syntax_error("RETURN without matching GOSUB",
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_MISMATCH");
        return;
    }

    var frame = ds_stack_pop(global.gosub_stack);

    // Backward-compat: older frames were numeric line indexes
    if (is_real(frame)) {
        global.interpreter_next_line = frame;
        return;
    }

    // === CHANGE: statement-level resume ===
    if (is_struct(frame) && frame.kind == "stmt") {
        global.interpreter_use_stmt_jump = true;
        global.interpreter_target_line  = frame.line_index;
        global.interpreter_target_stmt  = max(0, frame.stmt_index);
        return;
    }

    // Fallback: if unknown, behave like legacy
    global.interpreter_next_line = is_real(frame) ? frame : (line_index + 1);
}


================================================================================

/// @file scripts/basic_cmd_scroll/basic_cmd_scroll.gml

/// @function basic_cmd_scroll(arg)
/// @description SCROLL [direction,] amount  -- direction defaults to UP when omitted or numeric-first.
function basic_cmd_scroll(arg) {
    if (global.current_mode < 1) {
        if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: Not implemented in text mode");
        return;
    }
    
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: No grid object found");
        return;
    }

    // Defaults
    var _direction = "UP";
    var amount     = 1;

    var s = string_trim(arg);
    if (s != "") {
        var args = basic_parse_csv_args(s);

        if (array_length(args) == 1) {
            var a0 = string_trim(args[0]);

            // If the single arg is numeric (or an identifier that evals numeric), treat it as AMOUNT, direction=UP
            var treat_as_amount = false;
            if (is_numeric_string(a0)) {
                treat_as_amount = true;
            } else {
                // try evaluator; if it yields a number, we accept it as amount
                var v = basic_evaluate_expression_v2(a0);
                if (is_real(v)) {
                    amount = max(1, floor(real(v)));
                    treat_as_amount = true;
                }
            }

            if (treat_as_amount) {
                // direction remains default "UP"
                if (is_numeric_string(a0)) amount = max(1, floor(real(a0)));
            } else {
                // Otherwise it’s a direction token
                _direction = string_upper(a0);
                // Remove quotes if present
                if (string_length(_direction) >= 2 && (string_char_at(_direction,1) == "\"" || string_char_at(_direction,1) == "'")) {
                    _direction = string_copy(_direction, 2, string_length(_direction) - 2);
                    _direction = string_upper(_direction);
                }
            }
        }
        else if (array_length(args) >= 2) {
            // direction, amount
            _direction = string_upper(string_trim(args[0]));
            if (string_length(_direction) >= 2 && (string_char_at(_direction,1) == "\"" || string_char_at(_direction,1) == "'")) {
                _direction = string_copy(_direction, 2, string_length(_direction) - 2);
                _direction = string_upper(_direction);
            }
            amount = max(1, floor(real(basic_evaluate_expression_v2(string_trim(args[1])))));
        }
    }

    // Hand off
    mode1_scroll_grid(grid_obj, _direction, amount);
    if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: " + _direction + " by " + string(amount));
}


================================================================================

/// @file scripts/basic_cmd_wend/basic_cmd_wend.gml

function basic_cmd_wend() {
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Entering handler...");

    if (!ds_exists(global.while_stack, ds_type_stack) || ds_stack_empty(global.while_stack)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: ERROR — while_stack missing or empty");
        basic_show_message("WEND without matching WHILE");
        return;
    }

    var while_line_index = ds_stack_top(global.while_stack); // Peek, do not pop yet
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Top of while_stack is line index: " + string(while_line_index));

    // Prefer exact condition & resume slot captured at WHILE time
    var have_meta = (variable_global_exists("while_meta") && ds_exists(global.while_meta, ds_type_map)
                     && ds_map_exists(global.while_meta, string(while_line_index)));

    var cond_str, stmt_after;

    if (have_meta) {
        var meta = global.while_meta[? string(while_line_index)];
        cond_str   = string(meta[? "cond_str"]);
        stmt_after = meta[? "stmt_after"];
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Using stored cond='" + cond_str + "', stmt_after=" + string(stmt_after));
    } else {
        // === Legacy fallback (keeps prior behavior if meta missing) ===
        var while_line_number = ds_list_find_value(global.line_list, while_line_index);
        var while_code        = ds_map_find_value(global.program_map, while_line_number);
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Fallback WHILE line " + string(while_line_number) + " code: '" + while_code + "'");

        cond_str = string_trim(string_delete(while_code, 1, string_pos(" ", while_code)));
        stmt_after = 0; // we’ll jump to start of line as before in fallback
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Fallback extracted condition: '" + cond_str + "'");
    }

    var condition_value = basic_evaluate_condition(string_upper(cond_str));
    if (dbg_on(DBG_FLOW)) show_debug_message("WEND: Re-evaluated condition result: " + string(condition_value));

    if (condition_value) {
        if (have_meta) {
            // === FIX 2: loop back to the colon slot immediately AFTER the WHILE header ===
            global.interpreter_use_stmt_jump = true;
            global.interpreter_target_line   = while_line_index;
            global.interpreter_target_stmt   = max(0, stmt_after);
            global.interpreter_next_line     = -1;
            if (dbg_on(DBG_FLOW)) show_debug_message("WEND: TRUE → jump to (line="
                + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt) + ")");
        } else {
            // Legacy behavior
            if (dbg_on(DBG_FLOW)) show_debug_message("WEND: TRUE (fallback) — setting line_index = " + string(while_line_index - 1));
            line_index = while_line_index - 1; // causes Step to re-run the WHILE line
        }
    } else {
        // Exit loop
        ds_stack_pop(global.while_stack);
        if (have_meta) {
            // Clean up stored meta for this WHILE
            ds_map_delete(global.while_meta, string(while_line_index));
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("WEND: FALSE → pop and continue");
    }
}


================================================================================

/// @file scripts/basic_cmd_while/basic_cmd_while.gml

function basic_cmd_while(arg) {
    // Keep your original behavior & logging
    var condition = string_upper(string_trim(arg));
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Raw condition string: '" + condition + "'");

    var value = basic_evaluate_condition(condition);
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Evaluated result of '" + condition + "' → " + string(value));

    // ---- Lazy-init tiny metadata store for WHILE frames (no global file edits required)
    if (!variable_global_exists("while_meta") || !ds_exists(global.while_meta, ds_type_map)) {
        global.while_meta = ds_map_create();
    }

    if (!value) {
        // === FIX 1: robust skip ahead that inspects colon-separated statements, not only first token ===
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Condition is FALSE — skipping ahead to matching WEND");
        var _depth = 1;

        var li_max = ds_list_size(global.line_list);
        var li     = global.interpreter_current_line_index;         // current physical line index
        var stmt   = global.interpreter_current_stmt_index + 1;     // start after the WHILE header

        while (li < li_max) {
            var _ln   = ds_list_find_value(global.line_list, li);
            var code  = ds_map_find_value(global.program_map, _ln);
            var parts = split_on_unquoted_colons(string_trim(code));

            for (var p = stmt; p < array_length(parts); p++) {
                var raw  = string_trim(parts[p]);
                if (raw == "") continue;

                raw = strip_basic_remark(raw);
                var sp  = string_pos(" ", raw);
                var cmd = (sp > 0) ? string_upper(string_copy(raw, 1, sp - 1)) : string_upper(raw);

                if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: scan line " + string(_ln) + " part " + string(p) + " → " + cmd);

                if (cmd == "WHILE") {
                    _depth += 1; // nested while inside the false body we’re skipping
                } else if (cmd == "WEND") {
                    _depth -= 1;
                    if (_depth == 0) {
                        if (dbg_on(DBG_FLOW)) show_debug_message(
                            "WHILE: Found matching WEND at line index " + string(li) + ", line " + string(_ln) + ", part " + string(p)
                        );
                        // Land just AFTER this WEND colon slot
                        global.interpreter_use_stmt_jump = true;
                        global.interpreter_target_line   = li;
                        global.interpreter_target_stmt   = p + 1;
                        global.interpreter_next_line     = -1;
                        return;
                    }
                }
            }

            li   += 1;
            stmt  = 0; // from next physical line, start at first colon slot
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("?WHILE ERROR: No matching WEND found — control flow may break");
        return;
    }

    // === Condition TRUE → record minimal metadata and push loop frame as you already do ===
    if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Condition is TRUE — evaluating stack push logic");

    // Ensure stack exists
    if (!ds_exists(global.while_stack, ds_type_stack)) {
        global.while_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Created new while_stack");
    }

    // Only push if not already at top (preserve your logic)
    if (ds_stack_empty(global.while_stack) || ds_stack_top(global.while_stack) != line_index) {
        ds_stack_push(global.while_stack, line_index);
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Pushed line_index " + string(line_index) + " onto while_stack");
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("WHILE: Stack already contains this line_index at top — skipping push");
    }

    // Save exact condition and the colon slot to resume the loop body after WHILE’s header
    var key = string(line_index); // key by the WHILE's physical line index
    var meta = ds_map_create();
    meta[? "cond_str"]   = string_trim(arg); // store as written on the line (not uppercased)
    meta[? "stmt_after"] = global.interpreter_current_stmt_index + 1;
    ds_map_replace(global.while_meta, key, meta);

    // Continue normally
    global.interpreter_next_line = -1;
}


================================================================================

/// @file scripts/basic_current_line_no/basic_current_line_no.gml

/// @script basic_current_line_no
function basic_current_line_no() {
    if (ds_exists(global.line_list, ds_type_list)) {
        var idx = global.interpreter_current_line_index;
        if (is_real(idx) && idx >= 0 && idx < ds_list_size(global.line_list)) {
            return global.line_list[| idx];
        }
    }
    return is_undefined(global.current_line_number) ? -1 : global.current_line_number;
}

================================================================================

/// @file scripts/basic_error_hint/basic_error_hint.gml

/// @script basic_error_hint
/// Return an array of short hint lines (<= 3) for a given key.
function basic_error_hint(key) {
    var lines = [];
    switch (string_upper(string(key))) {
        case "INKEY_MISUSE":
            lines[0] = "INKEY$ must assign to a var.";
            lines[1] = "Use:  K$ = INKEY$";
            lines[2] = "Then PRINT K$ if desired.";
            break;

        case "IF_MISSING_THEN":
            lines[0] = "Use: IF cond THEN stmt";
            lines[1] = "Or multi-line IF...ENDIF";
            lines[2] = "Example: IF X=1 THEN PRINT X";
            break;

        case "FOR_MISMATCH":
            lines[0] = "FOR must have matching NEXT.";
            lines[1] = "Example: FOR I=1 TO 10 : ... : NEXT";
            break;

        case "WHILE_MISMATCH":
            lines[0] = "WHILE must end with WEND.";
            break;

        default:
            lines[0] = ""; lines[1] = ""; lines[2] = "";
            break;
    }
    return lines;
}


================================================================================

/// @file scripts/basic_evaluate_condition/basic_evaluate_condition.gml

function basic_evaluate_condition(expr) {
    var s = string_trim(expr);
    if (dbg_on(DBG_FLOW)) show_debug_message ("COND: Begin evaluate_condition → '" + s + "'");

    // ===== boolean precedence: OR (low) then AND (high) =====
    {
        var su = string_upper(s);
        var L  = string_length(su);
        var _depth = 0;
        var in_q  = false;

        // ---- Top-level OR ----
        for (var i = 1; i <= L - 1; i++) {
            var ch = string_char_at(su, i);
            if (ch == "\"") { in_q = !in_q; continue; }
            if (in_q) continue;

            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (_depth != 0) continue;

            if (string_copy(su, i, 2) == "OR") {
                // require space boundaries (avoid COLOR etc.)
                var prev = (i == 1) ? " " : string_char_at(su, i - 1);
                var next = (i + 2 <= L) ? string_char_at(su, i + 2) : " ";
                if (prev == " " && next == " ") {
                    var left  = string_trim(string_copy(s, 1, i - 1));
                    var right = string_trim(string_copy(s, i + 2, L - (i + 2) + 1));
                    if (dbg_on(DBG_FLOW)) show_debug_message ("COND: top-level OR split → LHS='" + left + "'  ||  RHS='" + right + "'");

                    var lres = basic_evaluate_condition(left);
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: OR left result = " + string(lres));
                    if (lres) { 
						if (dbg_on(DBG_FLOW)) {show_debug_message("COND: OR short-circuit TRUE");}
					return true; }

                    var rres = basic_evaluate_condition(right);
                    var ores = (lres || rres);
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: OR final = " + string(ores));
                    return ores;
                }
            }
        }

        // ---- Top-level AND ----
        _depth = 0; in_q = false;  // FIX: use _depth, not 'depth'
        for (var j = 1; j <= L - 2; j++) {
            var ch2 = string_char_at(su, j);
            if (ch2 == "\"") { in_q = !in_q; continue; }
            if (in_q) continue;

            if (ch2 == "(") { _depth++; continue; }
            if (ch2 == ")") { _depth = max(0, _depth - 1); continue; }
            if (_depth != 0) continue;

            if (string_copy(su, j, 3) == "AND") {
                var prev2 = (j == 1) ? " " : string_char_at(su, j - 1);
                var next2 = (j + 3 <= L) ? string_char_at(su, j + 3) : " ";
                if (prev2 == " " && next2 == " ") {
                    var left2  = string_trim(string_copy(s, 1, j - 1));
                    var right2 = string_trim(string_copy(s, j + 3, L - (j + 3) + 1));
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: top-level AND split → LHS='" + left2 + "'  &&  RHS='" + right2 + "'");

                    var lres2 = basic_evaluate_condition(left2);
                    if (dbg_on(DBG_FLOW)) show_debug_message("COND: AND left result = " + string(lres2));
                    if (!lres2) { if (dbg_on(DBG_FLOW)) show_debug_message("COND: AND short-circuit FALSE"); return false; }

                    var rres2 = basic_evaluate_condition(right2);
                    var andres = (lres2 && rres2);
                    if (dbg_on(DBG_FLOW)) show_debug_message("Combined condition (AND): " + string(lres2) + " AND " + string(rres2) + " = " + string(andres));
                    return andres;
                }
            }
        }
    }
    // ===== END boolean handling =====

    // --- Comparator search (unchanged) ---
    var ops = ["<>", "<=", ">=", "=", "<", ">"];
    var found_op = "";
    var op_pos = 0;
    var _depth = 0;

    for (var i2 = 1; i2 <= string_length(s); i2++) {
        var ch3 = string_char_at(s, i2);
        if (ch3 == "(") { _depth++; continue; }
        if (ch3 == ")") { _depth--; continue; }
        if (_depth != 0) continue;

        if (i2 < string_length(s)) {
            var two = string_copy(s, i2, 2);
            if (two == "<>" || two == "<=" || two == ">=") {
                found_op = two; op_pos = i2;
                if (dbg_on(DBG_FLOW)) show_debug_message("COND: Found 2-char op '" + found_op + "' at pos " + string(op_pos));
                break;
            }
        }
        if (ch3 == "=" || ch3 == "<" || ch3 == ">") {
            found_op = ch3; op_pos = i2;
            if (dbg_on(DBG_FLOW)) show_debug_message("COND: Found 1-char op '" + found_op + "' at pos " + string(op_pos));
            break;
        }
    }

    if (found_op != "") {
        var lhs = string_trim(string_copy(s, 1, op_pos - 1));
        var rhs = string_trim(string_copy(s, op_pos + string_length(found_op), string_length(s) - (op_pos + string_length(found_op) - 1)));
        var op  = found_op;

        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Split → LHS='" + lhs + "'  OP='" + op + "'  RHS='" + rhs + "'");

        var lhs_val = basic_evaluate_expression_v2(lhs);
        var rhs_val = basic_evaluate_expression_v2(rhs);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Eval → LHS=" + string(lhs_val) + "  RHS=" + string(rhs_val));

        var lhs_str = string(lhs_val);
        var rhs_str = string(rhs_val);
        var lhs_is_num = is_real(lhs_val) || is_numeric_string(lhs_str);
        var rhs_is_num = is_real(rhs_val) || is_numeric_string(rhs_str);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Types → LHS_is_num=" + string(lhs_is_num) + "  RHS_is_num=" + string(rhs_is_num));

        if (!(lhs_is_num && rhs_is_num)) {
            var sres = false;
            switch (op) {
                case "=":  sres = (lhs_str == rhs_str); break;
                case "<>": sres = (lhs_str != rhs_str); break;
                default:   sres = false;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("COND: String-compare '" + op + "' → " + string(sres));
            return sres;
        }

        var lhs_num = real(lhs_str);
        var rhs_num = real(rhs_str);
        var nres = false;
        switch (op) {
            case "=":  nres = (lhs_num == rhs_num); break;
            case "<":  nres = (lhs_num <  rhs_num); break;
            case ">":  nres = (lhs_num >  rhs_num); break;
            case "<=": nres = (lhs_num <= rhs_num); break;
            case ">=": nres = (lhs_num >= rhs_num); break;
            case "<>": nres = (lhs_num != rhs_num); break;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Numeric-compare '" + op + "' → " + string(nres));
        return nres;
    }

    // --- Legacy space-split path (kept) ---
    var tokens = string_split(s, " ");
    if (array_length(tokens) == 3) {
        var lhs2 = string_trim(tokens[0]);
        var op2  = string_trim(tokens[1]);
        var rhs2 = string_trim(tokens[2]);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback (space-split) → LHS='" + lhs2 + "' OP='" + op2 + "' RHS='" + rhs2 + "'");

        var lhs_val2 = basic_evaluate_expression_v2(lhs2);
        var rhs_val2 = basic_evaluate_expression_v2(rhs2);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback eval → LHS=" + string(lhs_val2) + "  RHS=" + string(rhs_val2));

        var lhs_str2 = string(lhs_val2);
        var rhs_str2 = string(rhs_val2);
        var lhs_is_num2 = is_real(lhs_val2) || is_numeric_string(lhs_str2);
        var rhs_is_num2 = is_real(rhs_val2) || is_numeric_string(rhs_str2);
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback types → LHS_is_num=" + string(lhs_is_num2) + "  RHS_is_num=" + string(rhs_is_num2));

        if (!(lhs_is_num2 && rhs_is_num2)) {
            var sres2 = false;
            switch (op2) {
                case "=":  sres2 = (lhs_str2 == rhs_str2); break;
                case "<>": sres2 = (lhs_str2 != rhs_str2); break;
                default:   sres2 = false;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback string-compare '" + op2 + "' → " + string(sres2));
            return sres2;
        }

        var lhs_num2 = real(lhs_str2);
        var rhs_num2 = real(rhs_str2);
        var nres2 = false;
        switch (op2) {
            case "=":  nres2 = (lhs_num2 == rhs_num2); break;
            case "<":  nres2 = (lhs_num2 <  rhs_num2); break;
            case ">":  nres2 = (lhs_num2 >  rhs_num2); break;
            case "<=": nres2 = (lhs_num2 <= rhs_num2); break;
            case ">=": nres2 = (lhs_num2 >= rhs_num2); break;
            case "<>": nres2 = (lhs_num2 != rhs_num2); break;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("COND: Fallback numeric-compare '" + op2 + "' → " + string(nres2));
        return nres2;
    }

    // --- NEW: final fallback — evaluate whole expression as truthy/falsey ---
    if (dbg_on(DBG_FLOW)) show_debug_message("COND: No operator; evaluating whole expression for truthiness");
    var _val = basic_evaluate_expression_v2(s);
    var _truth = 0;
    if (is_real(_val) || is_numeric_string(string(_val))) {
        _truth = (real(string(_val)) != 0);
    } else {
        var _s = string(_val);
        _truth = (string_length(_s) > 0);
    }
    if (dbg_on(DBG_FLOW)) show_debug_message("COND: expression value=" + string(_val) + " → truth=" + string(_truth));
    return _truth;
}


================================================================================

/// @file scripts/basic_evaluate_expression/basic_evaluate_expression.gml

function basic_evaluate_expression(expr) {
    expr = string_trim(expr);

    // Variable lookup
    if (ds_map_exists(global.basic_variables, string_upper(expr))) {
        return global.basic_variables[? string_upper(expr)];
    }

    // Handle MOD
    if (string_pos("MOD", string_upper(expr)) > 0) {
        var parts = string_split(string_upper(expr), "MOD");
        if (array_length(parts) == 2) {
            var a = real(basic_evaluate_expression_v2(parts[0]));
            var b = real(basic_evaluate_expression_v2(parts[1]));
            return a mod b;
        }
    }

    // Handle RND(n)
    if (string_upper(string_copy(expr, 1, 4)) == "RND(" && string_char_at(expr, string_length(expr)) == ")") {
        var inner = string_copy(expr, 5, string_length(expr) - 5);
        return irandom(real(basic_evaluate_expression_v2(inner)));
    }

    // Handle ABS(x)
    if (string_upper(string_copy(expr, 1, 4)) == "ABS(" && string_char_at(expr, string_length(expr)) == ")") {
        var inner = string_copy(expr, 5, string_length(expr) - 5);
        return abs(real(basic_evaluate_expression_v2(inner)));
    }

    // Fallback to real()
    return real(expr);
}


================================================================================

/// @file scripts/basic_evaluate_expression_v2/basic_evaluate_expression_v2.gml

function basic_evaluate_expression_v2(expr) {
    var tokens = basic_tokenize_expression_v2(expr);
    if (dbg_on(DBG_FLOW)) show_debug_message("Tokens: " + string(tokens)); // for debug
    var postfix = infix_to_postfix(tokens);
    return evaluate_postfix(postfix);
}


================================================================================

/// @file scripts/basic_fn_INKEY/basic_fn_INKEY.gml

/// === BASIC_fn_INKEY$ : dequeue 1 char for INKEY$ ===
/// Returns "" if queue empty. Safe to call from evaluator/command handler.
function BASIC_fn_INKEY() {
    if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
        global.inkey_queue = ds_queue_create();
    }
    if (ds_queue_size(global.inkey_queue) > 0) {
        var _ch = ds_queue_dequeue(global.inkey_queue);
        if (is_real(_ch)) _ch = chr(_ch);
        return string(_ch);
    }
    return "";
}

================================================================================

/// @file scripts/basic_normvar/basic_normvar.gml

/// basic_normvar(name) -> canonical variable key
function basic_normvar(_name) {
    return string_upper(string_trim(string(_name)));
}

/// basic_looks_numeric(s) -> bool  (no regex; robust enough for BASIC)
function basic_looks_numeric(_s) {
    var s = string_trim(string(_s));
    if (s == "") return false;
    var digits = 0;
    for (var i = 1; i <= string_length(s); i++) {
        var c = ord(string_char_at(s, i));
        if ((c >= 48 && c <= 57)) digits++;                     // 0..9
        else if (c == 46 || c == 45) { /* '.' or leading '-' */ }
        else return false;
    }
    return digits > 0;
}


================================================================================

/// @file scripts/basic_parse_color/basic_parse_color.gml

/// FILE: scripts/basic_parse_color.gml
/// FUNCTION: basic_parse_color(colstr)
/// Behavior:
/// 1) Try global.colors map (case-insensitive; quotes ok; aliases normalized)
/// 2) Try hex formats: &Hrrggbb, 0xrrggbb, #rrggbb, $rrggbb
/// 3) Try decimal integer
/// 4) Fallback to c_white with a debug note

function basic_parse_color(colstr) {
    var s = string_trim(colstr);

    // Strip matching quotes
    if (string_length(s) >= 2) {
        var f = string_char_at(s, 1);
        var l = string_char_at(s, string_length(s));
        if ((f == "\"" || f == "'") && f == l) s = string_copy(s, 2, string_length(s) - 2);
    }

    // Normalize for name lookup
    var key = string_upper(s);

    // Alias normalization to your existing keys
    if (key == "GREY") key = "GRAY";
    if (key == "DARKGRAY" || key == "DARKGREY") key = "DKGRAY";
    // LIGHTGRAY not in your map; handle as special case

    // 1) Named color via global.colors (global is a struct, so check the variable)
    if (variable_global_exists("colors")) {
        if (key == "LIGHTGRAY" || key == "LIGHTGREY") {
            return make_color_rgb(192,192,192);
        }
        if (ds_map_exists(global.colors, key)) {
            return ds_map_find_value(global.colors, key);
        }
    }

    // 2) Hex parsing (RRGGBB)
    var hex = "";
    var ku  = string_upper(s);
    if (string_length(ku) >= 3 && string_copy(ku,1,2) == "&H") {
        hex = string_copy(s, 3, string_length(s)-2);
    } else if (string_length(ku) >= 3 && string_copy(ku,1,2) == "0X") {
        hex = string_copy(s, 3, string_length(s)-2);
    } else if (string_length(ku) >= 1 && string_char_at(ku,1) == "#") {
        hex = string_copy(s, 2, string_length(s)-1);
    } else if (string_length(ku) >= 1 && string_char_at(ku,1) == "$") {
        hex = string_copy(s, 2, string_length(s)-1);
    }

    if (hex != "") {
        var clean = "";
        for (var i = 1; i <= string_length(hex); i++) {
            var ch = string_upper(string_char_at(hex, i));
            if ((ch >= "0" && ch <= "9") || (ch >= "A" && ch <= "F")) clean += ch;
        }
        if (string_length(clean) == 6) {
            var rr = string_copy(clean,1,2);
            var gg = string_copy(clean,3,2);
            var bb = string_copy(clean,5,2);
            return make_color_rgb(__hex_byte(rr), __hex_byte(gg), __hex_byte(bb));
        }
    }

    // 3) Decimal integer fallback
    if (is_numeric_string(s)) {
        return real(s);
    }

    // 4) Fallback
    if (dbg_on(DBG_FLOW)) show_debug_message("basic_parse_color: unknown color '" + s + "', defaulting to WHITE");
    return c_white;
}

function __hex_byte(two) {
    var hi = string_char_at(two,1);
    var lo = string_char_at(two,2);
    return __hex_nibble(hi) * 16 + __hex_nibble(lo);
}
function __hex_nibble(ch) {
    ch = string_upper(ch);
    if (ch >= "0" && ch <= "9") return ord(ch) - ord("0");
    if (ch >= "A" && ch <= "F") return 10 + (ord(ch) - ord("A"));
    return 0;
}


================================================================================

/// @file scripts/basic_parse_csv_args/basic_parse_csv_args.gml

function basic_parse_csv_args(str) {
    var args = [];
    var current = "";
    var in_quotes = false;
    var i = 1;
    var len = string_length(str);

    while (i <= len) {
        var c = string_char_at(str, i);

        if (c == "\"") {
            in_quotes = !in_quotes;
            current += c; // Preserve quote so later commands can detect strings
        }
        else if (c == "," && !in_quotes) {
            array_push(args, string_trim(current));
            current = "";
        }
        else {
            current += c;
        }

        i += 1;
    }

    if (string_length(current) > 0) {
        array_push(args, string_trim(current));
    }

    return args;
}


================================================================================

/// @file scripts/basic_run_to_console/basic_run_to_console.gml

/// @function basic_run_to_console()
/// @description Executes the BASIC program in memory and prints the output to the console instead of the screen.

function basic_run_to_console() {
   if (dbg_on(DBG_FLOW)) show_debug_message("==== BEGIN PROGRAM CONSOLE OUTPUT ====");

    // Safety check
    if (!ds_exists(global.program_lines, ds_type_map) || !ds_exists(global.line_numbers, ds_type_list)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("No program loaded.");
        return;
    }

    // Local context for LET variable storage
    var local_vars = ds_map_create();

    // Run through each line in order
    for (var i = 0; i < ds_list_size(global.line_numbers); i++) {
        var line_num = ds_list_find_value(global.line_numbers, i);
        var code = ds_map_find_value(global.program_lines, line_num);
        var trimmed = string_trim(code);

        var sp = string_pos(" ", trimmed);
        var cmd = (sp > 0) ? string_upper(string_copy(trimmed, 1, sp - 1)) : string_upper(trimmed);
        var arg = (sp > 0) ? string_trim(string_copy(trimmed, sp + 1, string_length(trimmed))) : "";

        switch (cmd) {
            case "LET":
                var eq_pos = string_pos("=", arg);
                if (eq_pos > 0) {
                    var varname = string_trim(string_copy(arg, 1, eq_pos - 1));
                    var value = string_trim(string_copy(arg, eq_pos + 1, string_length(arg)));
                    var value_num = real(value);
                    ds_map_replace(local_vars, varname, value_num);
                }
                break;

            case "PRINT":
                // Check if last character is semicolon
                var ends_with_semicolon = (string_char_at(arg, string_length(arg)) == ";");
                if (ends_with_semicolon) {
                    arg = string_copy(arg, 1, string_length(arg) - 1);
                }

                var segments = string_split(arg, "+");
                var output = "";
                for (var j = 0; j < array_length(segments); j++) {
                    var segment = string_trim(segments[j]);
                    if (string_length(segment) >= 2 && string_char_at(segment, 1) == "\"" && string_char_at(segment, string_length(segment)) == "\"") {
                        output += string_copy(segment, 2, string_length(segment) - 2);
                    } else if (ds_map_exists(local_vars, segment)) {
                        output += string(ds_map_find_value(local_vars, segment));
                    } else {
                        output += segment;
                    }
                }

                if (ends_with_semicolon) {
                    // no newline
                    if (dbg_on(DBG_FLOW)) show_debug_message(">> " + output);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message(">> " + output + "\n");
                }
                break;

            default:
                if (dbg_on(DBG_FLOW)) show_debug_message("Unknown command on line " + string(line_num) + ": " + cmd);
        }
    }

    ds_map_destroy(local_vars);
	basic_run_to_console_flag = false;
    if (dbg_on(DBG_FLOW)) show_debug_message("==== END PROGRAM CONSOLE OUTPUT ====");
}


================================================================================

/// @file scripts/basic_show_error_message/basic_show_error_message.gml


// Optional helper for errors: prefix message with a "?" as classic BASIC did.
function basic_show_error_message(err) {
    basic_show_message("?" + err);
}




================================================================================

/// @file scripts/basic_show_message/basic_show_message.gml

// Call this to display a message for roughly 2 seconds (120 frames at 60 fps).
function basic_show_message(msg) {
    message_text  = msg;
    global.message_timer = 120;
}

================================================================================

/// @file scripts/basic_stop_execution/basic_stop_execution.gml

// SCRIPT: basic_stop_execution
function basic_stop_execution() {
    if (dbg_on(DBG_FLOW)) show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
    if (dbg_on(DBG_FLOW)) show_debug_message("BASIC_STOP_EXECUTION CALLED!");
    if (dbg_on(DBG_FLOW)) show_debug_message("Call Stack:");
    if (dbg_on(DBG_FLOW)) show_debug_message(debug_get_callstack()); // THIS IS THE KEY!
    if (dbg_on(DBG_FLOW)) show_debug_message("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");

    global.interpreter_running = false;
    global.awaiting_input = false;
    global.program_has_ended = true;

    // Clear input buffer if input was pending
    if (global.input_buffer != undefined && ds_list_exists(global.input_buffer, ds_type_list)) {
        ds_list_clear(global.input_buffer);
    }
}

================================================================================

/// @file scripts/basic_syntax_error/basic_syntax_error.gml

/// @script basic_syntax_error
/// Print a visible error line and stop the interpreter gracefully.
/// @param msg        string message explaining the error
/// @param line_no    (optional) line number; defaults to current
/// @param stmt_idx   (optional) colon-slot index; defaults to current
/// @param hint_key   (optional) short key for contextual hints, e.g. "INKEY_MISUSE"
function basic_syntax_error(msg, line_no, stmt_idx, hint_key) {
    if (is_undefined(line_no))  line_no  = global.current_line_number;
    if (is_undefined(stmt_idx)) stmt_idx = global.interpreter_current_stmt_index;
    // Flush any buffered PRINT so error doesn't glue to prior text
    if (is_string(global.print_line_buffer) && string_length(global.print_line_buffer) > 0) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        global.print_line_buffer = "";
    }
    var prev_col = global.current_draw_color;
    // Header + reason
    global.current_draw_color = c_red;
    basic_wrap_and_commit("SYNTAX ERROR at " + string(line_no) + ":", global.current_draw_color);
    basic_wrap_and_commit(string(msg), global.current_draw_color);
    // Compact hints
    if (ds_exists(global.config, ds_type_map) && global.config[? "show_error_hints"]) {
        var _h = basic_error_hint(hint_key);
        for (var i = 0; i < array_length(_h); i++) {
            if (_h[i] != "") basic_wrap_and_commit("  " + _h[i], global.current_draw_color);
        }
    }
    global.current_draw_color = prev_col;
    // Stop cleanly (no gates left engaged)
    global.pause_in_effect     = false;
    global.awaiting_input      = false;
    global.input_expected      = false;
    global.inkey_mode          = false;
    global.inkey_waiting       = false;
    global.interpreter_running = false;
    global.program_has_ended   = true;
    // Let run_program() know not to clear the screen immediately
    global._syntax_error_just_emitted = true;
    if (dbg_on(DBG_FLOW)) show_debug_message("SYNTAX: " + msg + " (line " + string(line_no) + ")");
}

================================================================================

/// @file scripts/basic_system_message/basic_system_message.gml

function basic_system_message(_msg, _color) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message START ===");
    if (dbg_on(DBG_FLOW)) show_debug_message("Incoming message: " + string(_msg));
    if (dbg_on(DBG_FLOW)) show_debug_message("Incoming color arg: " + string(_color));

    // Do NOT create here — run_program owns creation.
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("basic_system_message: output buffers not initialized; SKIPPING write.");
        if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message END (skipped) ===");
        return;
    }

    var wrap_width = 40; // keep in sync with PRINT path
    var col = is_undefined(_color) ? global.current_draw_color : _color;
    if (dbg_on(DBG_FLOW)) show_debug_message("Using color: " + string(col));

    var text = string(_msg);
    if (dbg_on(DBG_FLOW)) show_debug_message("Wrapping text: " + text);

    while (string_length(text) > wrap_width) {
        var chunk = string_copy(text, 1, wrap_width);
        if (dbg_on(DBG_FLOW)) show_debug_message("Adding wrapped chunk: '" + chunk + "'");
        ds_list_add(global.output_lines, chunk);
        ds_list_add(global.output_colors, col);
        text = string_delete(text, 1, wrap_width);
    }

   if (dbg_on(DBG_FLOW))  show_debug_message("Adding final remainder: '" + text + "'");
    ds_list_add(global.output_lines, text);
    ds_list_add(global.output_colors, col);

    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_system_message END ===");
}


================================================================================

/// @file scripts/basic_tokenize_expression_v2/basic_tokenize_expression_v2.gml

function basic_tokenize_expression_v2(expr) {
    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting expression: '" + expr + "'");

    var tokens = [];
    var i = 1;
    var len = string_length(expr);
    var current = "";

    var function_names = ["RND", "ABS", "EXP", "LOG", "LOG10", "SGN", "INT", "SIN", "COS", "TAN", "STR$", "CHR$", "REPEAT$", "ASC"];

    while (i <= len) {
        var c = string_char_at(expr, i);
//        show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");
		if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");
		

        // --- STRING LITERAL SUPPORT (preserve exact quoted content) ---
        if (c == "\"") {
            var str = "\"";
            i++;
            while (i <= len) {
                var ch = string_char_at(expr, i);
                str += ch;
                if (ch == "\"") break;
                i++;
            }
            array_push(tokens, str);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added (quoted string): " + str);
            i++;
            continue;
        }

        // --- Handle whitespace ---
        if (c == " ") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token from space: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            i++;
            continue;
        }


        // --- Handle operators ---
		// --- Handle operators ---
		// add "\" (integer division) as a real operator
		if (c == "+" || c == "*" || c == "/" || c == "\\" || c == "(" || c == ")" || c == "%" || c == "^") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before operator: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            if (c == "(" && array_length(tokens) > 0) {
				var last = "";
				if (variable_instance_exists(id, "tokens") && is_array(tokens) && array_length(tokens) > 0) {
				    last = string_upper(string(tokens[array_length(tokens) - 1]));
				}
                if (array_contains(function_names, last)) {
                    array_push(tokens, "(");
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Function call detected: " + last + "(");
                } else {
                    array_push(tokens, "(");
                    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);
                }
            } else {
                array_push(tokens, c);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);
            }
            i++;
            continue;
        }

        // --- Handle commas ---
        if (c == ",") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before comma: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, ",");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Comma token added");
            i++;
            continue;
        }

// --- Handle subtraction/negative numbers ---
if (c == "-") {
    // First, finalize any pending token
    if (current != "") {
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before minus: '" + current + "'");
        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
        current = "";
    }
    
    // Check if this should be a negative number
    var is_negative = false;
    
    // Must be followed by a digit to be a negative number
    if (i < len && (ord(string_char_at(expr, i + 1)) >= 48 && ord(string_char_at(expr, i + 1)) <= 57)) {
        if (array_length(tokens) == 0) {
            // Start of expression -> negative number
            is_negative = true;
        } else {
            // Check what the last token was
            var last_token = tokens[array_length(tokens) - 1];
            if (last_token == "+" || last_token == "-" || last_token == "*" || 
                last_token == "/" || last_token == "(" || last_token == "%" || 
                last_token == "^" || string_upper(last_token) == "MOD" || 
                last_token == "=" || last_token == "<" || last_token == ">" ||
                last_token == "<=" || last_token == ">=" || last_token == "<>") {
                // After operator -> negative number
                is_negative = true;
            }
        }
    }
    
    if (is_negative) {
        // Start building a negative number token
        current = "-";
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting negative number");
    } else {
        // Regular subtraction operator
        array_push(tokens, "-");
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Added subtraction operator");
    }
    
    i++;
    continue;
}
//END if c = -

        // --- Accumulate characters for identifiers or numbers ---
        current += c;
        i++;
    }

    // --- Finalize any remaining token ---
    if (current != "") {
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing last token: '" + current + "'");
        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Final token list = " + string(tokens));
    return tokens;
}

================================================================================

/// @file scripts/basic_validate_program/basic_validate_program.gml

function basic_validate_program() {
    // Ensure structures exist
    if (!ds_exists(global.program_map, ds_type_map) || !ds_exists(global.line_list, ds_type_list)) return true;

    // Helpers local to validator
    var _top_level_eq_pos = function(s) {
        var L = string_length(s), _depth = 0, inq = false;
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if (ch == "\"") { inq = !inq; continue; }
            if (inq) continue;
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { if (_depth > 0) _depth--; continue; }
            if (ch == "=" && _depth == 0) return i;
        }
        return 0;
    };
    
    var _is_letter = function(ch) {
        if (string_length(ch) < 1) return false;
        var c = ord(string_upper(ch));
        return (c >= 65 && c <= 90);
    };
    
    var _is_valid_lhs = function(lhs) {
        lhs = string_trim(lhs);
        if (lhs == "") return false;
        var head = string_char_at(lhs, 1);
        // Inline the letter check to avoid scoping issues
        var head_ord = ord(string_upper(head));
        var is_valid_head = (string_length(head) >= 1) && (head_ord >= 65 && head_ord <= 90);
        if (!is_valid_head) return false;
        var p = string_pos("(", lhs);
        if (p > 0 && string_char_at(lhs, string_length(lhs)) != ")") return false;
        return true;
    };
    
    var _has_unquoted_inkey = function(stmt, up) {
        var inq = false;
        var stmt_len = string_length(stmt);
        for (var j = 1; j <= stmt_len - 5; j++) {
            var ch = string_char_at(stmt, j);
            if (ch == "\"") {
                if (j < stmt_len && string_char_at(stmt, j + 1) == "\"") {
                    j++; // skip escaped quote
                    continue;
                }
                inq = !inq;
                continue;
            }
            if (!inq && j + 5 <= stmt_len && string_copy(up, j, 6) == "INKEY$") {
                return true;
            }
        }
        return false;
    };

    // Walk each physical line in program order
    for (var i = 0; i < ds_list_size(global.line_list); i++) {
        var line_no  = global.line_list[| i];
        var src_line = ds_map_find_value(global.program_map, line_no);
        if (!is_string(src_line)) continue;

        // Split on top-level colons (your helper)
        var parts = split_on_unquoted_colons(string_trim(src_line));
        for (var p = 0; p < array_length(parts); p++) {
            var stmt_raw = string_trim(parts[p]);
            if (stmt_raw == "") continue;

            // Ignore REM / apostrophe comments entirely
            var sp  = string_pos(" ", stmt_raw);
            var verb = (sp > 0) ? string_upper(string_copy(stmt_raw, 1, sp - 1)) : string_upper(stmt_raw);
            if (verb == "REM" || string_char_at(stmt_raw, 1) == "'") break;

            var stmt = strip_basic_remark(stmt_raw);
            var up   = string_upper(stmt);

            // Use quote-aware INKEY$ detection instead of simple string_pos
            if (_has_unquoted_inkey(stmt, up)) {
                var eqp = _top_level_eq_pos(stmt);
                if (eqp > 0) {
                    var lhs = string_copy(stmt, 1, eqp - 1);
                    if (!_is_valid_lhs(lhs)) {
                        basic_syntax_error("Left side of assignment must be a variable or array name before INKEY$", line_no, p, "INKEY_LHS");
                        return false;
                    }
                } else if (verb != "LET") {
                    basic_syntax_error("INKEY$ may only appear on the right side of an assignment like  X$ = INKEY$", line_no, p, "INKEY_MISUSE");
                    return false;
                }
            }
        }
    }
    return true;
}

================================================================================

/// @file scripts/basic_wrap_and_commit/basic_wrap_and_commit.gml

function basic_wrap_and_commit(_text, _color) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_wrap_and_commit START ===");

    // Output buffers must already exist
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("wrap: buffers not initialized; SKIP");
        return;
    }

    // Width: default 64 unless caller set global.wrap_width
    var wrap_width = (variable_global_exists("wrap_width") && is_real(global.wrap_width) && global.wrap_width > 0)
        ? floor(global.wrap_width) : 70;

    var remaining = string(_text);

    while (string_length(remaining) > wrap_width) {
        var len_rem = string_length(remaining);
        var cut = wrap_width;
        var last_space = 0;
        var found_space = false;

        // Find the last space at or before wrap_width
        var p = min(wrap_width, len_rem);
        for (; p >= 1; p--) {
            if (string_char_at(remaining, p) == " ") { last_space = p; break; }
        }

        if (last_space > 0) {
            // Break on that space (exclude it)
            cut = last_space - 1;
            found_space = true;
        } else {
            // Hard break … but avoid dangling punctuation on next line
            var next_char = (wrap_width + 1 <= len_rem) ? string_char_at(remaining, wrap_width + 1) : "";
            if (next_char == ")" || next_char == "]" || next_char == "}" ||
                next_char == "!" || next_char == "?" || next_char == "." ||
                next_char == "," || next_char == ":" || next_char == ";") {
                var back = wrap_width;
                while (back > 1 && string_char_at(remaining, back) != " ") back--;
                if (back > 1) {
                    cut = back - 1;   // exclude that space
                    found_space = true;
                }
            }
        }

        if (cut < 1) cut = wrap_width; // safety for huge first word

        var line = string_copy(remaining, 1, cut);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, _color);

        // Advance; skip the space when we broke on a space
        var next_start = cut + (found_space ? 2 : 1);
        if (next_start <= len_rem) {
            remaining = string_copy(remaining, next_start, len_rem - (next_start - 1));
        } else {
            remaining = "";
        }

        // Trim any leading spaces on the next line
        while (string_length(remaining) > 0 && string_char_at(remaining, 1) == " ") {
            remaining = string_copy(remaining, 2, string_length(remaining) - 1);
        }
    }

    // Tail
    ds_list_add(global.output_lines, remaining);
    ds_list_add(global.output_colors, _color);
}


================================================================================

/// @file scripts/build_data_streams/build_data_streams.gml

/// @func build_data_streams()
/// @desc Pre-scan the loaded program for DATA statements and harvest values
///       into named streams: global.data_streams[stream_name] = { list, ptr }.
///       Default stream name is "" (empty). Named stream: DATA @name: v1, v2, ...
function build_data_streams() {
    // Ensure the container map exists; clear any prior contents safely
    // We rely on obj_globals to have created global.data_streams (a ds_map).
    // Here we only clear/recycle it between runs by destroying per-stream lists.
    if (!ds_exists(global.data_streams, ds_type_map)) {
        // Safety net (shouldn't happen if obj_globals set it up)
        global.data_streams = ds_map_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("DATA: safety-created global.data_streams (missing map)");
    }

    // Destroy any old lists then clear the map for a fresh build
    var _k = ds_map_find_first(global.data_streams);
    while (!is_undefined(_k)) {
        var _st = ds_map_find_value(global.data_streams, _k);
        if (is_struct(_st)) {
            if (ds_exists(_st.list, ds_type_list)) ds_list_destroy(_st.list);
        }
        _k = ds_map_find_next(global.data_streams, _k);
    }
    ds_map_clear(global.data_streams);

    var total_vals = 0, added_lines = 0;

    // Iterate by physical line order using your runtime copies
    // (run_program() already did ds_map_copy → basic_program and ds_list_copy → basic_line_numbers)
    for (var i = 0; i < ds_list_size(global.basic_line_numbers); i++) {
        var line_no = global.basic_line_numbers[| i];
        var raw     = ds_map_find_value(global.basic_program, line_no);
        if (is_undefined(raw)) continue;

        var parts = split_on_unquoted_colons(string_trim(raw));

        for (var p = 0; p < array_length(parts); p++) {
            // *** CHANGE: look at the raw colon slot first (before stripping remarks)
            var stmt_full = string_trim(parts[p]);
            if (stmt_full == "") continue;

            var sp0   = string_pos(" ", stmt_full);
            var verb0 = (sp0 > 0) ? string_upper(string_copy(stmt_full, 1, sp0 - 1)) : string_upper(stmt_full);

            // *** CHANGE: if this part is REM or starts with apostrophe, stop scanning the rest of THIS line
            if (verb0 == "REM" || string_char_at(stmt_full, 1) == "'") {
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA scan: REM/' stops line " + string(line_no) + " at part " + string(p));
                break; // stop processing parts[] for this physical line
            }

            // Now strip inline remarks (so code like: DATA 1,2 'comment keeps "DATA 1,2")
            var part_raw = strip_basic_remark(stmt_full);
            if (part_raw == "") continue;

            var sp   = string_pos(" ", part_raw);
            var verb = (sp > 0) ? string_upper(string_copy(part_raw, 1, sp - 1)) : string_upper(part_raw);
            var rest = (sp > 0) ? string_trim(string_copy(part_raw, sp + 1, string_length(part_raw))) : "";

            if (verb != "DATA") continue;

            // --- collapse the remainder of THIS physical line so ':' after @name doesn't split the DATA ---
            // *** CHANGE: also stop collapse if we hit a REM/' part later on the same line.
            var remainder = part_raw;
            for (var t = p + 1; t < array_length(parts); t++) {
                var tail_full = string_trim(parts[t]);
                if (tail_full == "") continue;

                var spT   = string_pos(" ", tail_full);
                var verbT = (spT > 0) ? string_upper(string_copy(tail_full, 1, spT - 1)) : string_upper(tail_full);

                // *** CHANGE: if a later colon slot is a whole-line comment, stop collapse here
                if (verbT == "REM" || string_char_at(tail_full, 1) == "'") {
                    if (dbg_on(DBG_FLOW)) show_debug_message("DATA collapse: hit REM/' at part " + string(t) + " on line " + string(line_no));
                    break;
                }

                var tail = strip_basic_remark(tail_full);
                if (tail != "") remainder += ":" + tail;
            }
            if (dbg_on(DBG_FLOW) && remainder != part_raw) show_debug_message("DATA: collapsed line parts → '" + remainder + "'");

            // Recompute 'rest' from the collapsed DATA statement
            var sp2  = string_pos(" ", remainder);
            rest     = (sp2 > 0) ? string_trim(string_copy(remainder, sp2 + 1, string_length(remainder))) : "";
            added_lines++;

            var stream_name = "";     // default stream
            var values_text = rest;   // may be rewritten if @name: is present

            // Optional named stream: DATA @name: v1, v2, ...
            if (string_length(rest) > 0 && string_char_at(rest, 1) == "@") {
                var _depth = 0, inq = false, cut = 0, L = string_length(rest);
                for (var j = 1; j <= L; j++) {
                    var ch = string_char_at(rest, j);
                    if (ch == "\"") {
                        var nxt = (j < L) ? string_char_at(rest, j + 1) : "";
                        if (inq && nxt == "\"") { j++; continue; }
                        inq = !inq; continue;
                    }
                    if (inq) continue;
                    if (ch == "(") { _depth++; continue; }
                    if (ch == ")") { _depth = max(0, _depth - 1); continue; }
                    if (ch == ":" && _depth == 0) { cut = j; break; }
                }
                if (cut == 0) {
                   if (dbg_on(DBG_FLOW)) show_debug_message("?DATA ERROR: expected ':' after @name — line " + string(line_no) + " text: '" + part_raw + "'");
                    continue;
                }
                stream_name = string_trim(string_copy(rest, 2, cut - 2)); // exclude '@'
                values_text = string_trim(string_copy(rest, cut + 1, L - cut));
            }

            var vals = split_on_unquoted_commas(values_text);

            if (!ds_map_exists(global.data_streams, stream_name)) {
                var stream = { list: ds_list_create(), ptr: 0 };
                ds_map_add(global.data_streams, stream_name, stream);
            }
            var sref = ds_map_find_value(global.data_streams, stream_name);

            for (var vi = 0; vi < array_length(vals); vi++) {
                var token = vals[vi];
                var v = parse_data_value(token);
                ds_list_add(sref.list, v);
                total_vals++;
                if (dbg_on(DBG_FLOW)) show_debug_message(
                    "DATA: +" + (is_string(v) ? ("\"" + string(v) + "\"") : string(v)) +
                    " -> stream='" + stream_name + "' (line " + string(line_no) + ")"
                );
            }

            // we consumed the collapsed remainder of this physical line for this DATA
            break;
        }
    }

    if (dbg_on(DBG_FLOW)) {
        var summary = "DATA SUMMARY — streams: ";
        var k2 = ds_map_find_first(global.data_streams);
        while (!is_undefined(k2)) {
            var st2 = ds_map_find_value(global.data_streams, k2);
            var cnt = ds_list_size(st2.list);
            summary += "'" + string(k2) + "'=" + string(cnt) + "  ";
            k2 = ds_map_find_next(global.data_streams, k2);
        }
       if (dbg_on(DBG_FLOW)) show_debug_message(summary + "| values=" + string(total_vals) + " | data_lines=" + string(added_lines));
    }

    // TEMP: verify default stream size
    if (ds_map_exists(global.data_streams, "")) {
        var _def = ds_map_find_value(global.data_streams, "");
       if (dbg_on(DBG_FLOW)) show_debug_message("DATA DEFAULT SIZE = " + string(ds_list_size(_def.list)));
    }
}


================================================================================

/// @file scripts/build_if_block_map/build_if_block_map.gml

/// @script build_if_block_map
/// @description Scan basic_program for IF…ELSEIF…ELSE…ENDIF block structure,
///              but skip inline IFs so they don’t trigger mismatches.

function build_if_block_map() {
    // 1) Destroy any old map
    if (variable_global_exists("if_block_map") && ds_exists(global.if_block_map, ds_type_map)) {
        ds_map_destroy(global.if_block_map);
    }
    global.if_block_map = ds_map_create();

    // 2) Temp stack for nested block IFs
    var openStack = ds_stack_create();
    var total     = ds_list_size(global.basic_line_numbers);

    // 3) Walk every line
    for (var idx = 0; idx < total; idx++) {
        var lineNum = global.basic_line_numbers[| idx];
        var rawText = string_trim(global.basic_program[? lineNum]);
        var text    = string_upper(rawText);
        var sp      = string_pos(" ", text);
        var kw      = (sp > 0) ? string_copy(text, 1, sp - 1) : text;

        switch (kw) {
            case "IF":
                // detect inline IF: IF … THEN <command> on same line
                var thenPos = string_pos("THEN", text);
                var after   = (thenPos > 0)
                              ? string_trim(string_copy(rawText, thenPos + 4, string_length(rawText)))
                              : "";
                if (thenPos > 0 && string_length(after) > 0) {
                    // Inline IF → skip block indexing entirely
                    if (dbg_on(DBG_FLOW)) show_debug_message("INLINE IF skip at line " + string(lineNum));
                    break;
                }
                // Block IF → record it
                var info = ds_map_create();
                ds_map_add(info, "startIndex",       idx);
                ds_map_add(info, "elseifIndices",    ds_list_create());
                ds_map_add(info, "elseIndex",        -1);
                ds_map_add(info, "endifIndex",       -1);
                ds_map_add(info, "firstBranchIndex", idx + 1);
                ds_stack_push(openStack, info);
                break;

            case "ELSEIF":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_top(openStack);
                    ds_list_add(top[? "elseifIndices"], idx);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: ELSEIF at line " + string(lineNum) + " without IF");
                }
                break;

            case "ELSE":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_top(openStack);
                    ds_map_replace(top, "elseIndex", idx);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: ELSE at line " + string(lineNum) + " without IF");
                }
                break;

            case "ENDIF":
                if (!ds_stack_empty(openStack)) {
                    var top = ds_stack_pop(openStack);
                    ds_map_replace(top, "endifIndex", idx);

                    // recompute firstBranchIndex
                    var eList = top[? "elseifIndices"];
                    var fb = (ds_list_size(eList) > 0)
                             ? eList[| 0]
                             : ((top[? "elseIndex"] >= 0) ? top[? "elseIndex"] : idx);
                    ds_map_replace(top, "firstBranchIndex", fb);

                    ds_map_add(global.if_block_map, top[? "startIndex"], top);
                } else {
                    if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: ENDIF at line " + string(lineNum) + " without IF");
                }
                break;
        }
    }

    // 4) Any unclosed IFs left on the stack?
    while (!ds_stack_empty(openStack)) {
        var orphan = ds_stack_pop(openStack);
        var startIdx  = orphan[? "startIndex"];
        var startLine = global.basic_line_numbers[| startIdx];
        if (dbg_on(DBG_FLOW)) show_debug_message("?MISMATCH ERROR: IF at line " + string(startLine) + " missing ENDIF");
        ds_map_destroy(orphan);
    }
    ds_stack_destroy(openStack);

    if (dbg_on(DBG_FLOW)) show_debug_message("Built IF block map with " + string(ds_map_size(global.if_block_map)) + " entries.");
}


================================================================================

/// @file scripts/dbg/dbg.gml

function dbg(cat, msg) {
    // Off fast-path
    if ((global.debug_mask & cat) == 0) return;

    // Per-frame quota (avoid tanking fps)
    if (global.dbg_frame_count >= global.dbg_frame_quota) {
        global.dbg_dropped_count++;
        return;
    }
    global.dbg_frame_count++;

    // ✅ Print unconditionally now that the category is enabled
   if (dbg_on(DBG_FLOW)) show_debug_message(msg);
}


================================================================================

/// @file scripts/dbg_macros/dbg_macros.gml

/// @script dbg_macros.gml
#macro DBG_PARSE  1     // tokenizer, parser, DIM/LET parsing
#macro DBG_EVAL   2     // postfix eval, expression values
#macro DBG_FLOW   4     // IF/WHILE/GOTO/GOSUB flow
#macro DBG_IO     8     // INPUT/PRINT/UI prompts
#macro DBG_ARRAY  16    // array get/set, DIM
#macro DBG_PERF   32    // performance
#macro DBG_STEP   64    // Execution
#macro DBG_EXEC   128	// EXEC
#macro DBG_ALL    0x7fffffff

/*
DEBUG MASKING — HOW TO USE (READ THIS FIRST)
============================================

## WHAT THIS FILE IS

These `#macro` lines define **compile-time constants** used to *categorize* your
debug logs. They are simple bit flags (1, 2, 4, …) that you OR together to
decide which kinds of messages should print at runtime.

```
#macro DBG_PARSE  1     // tokenizer & parser chatter
#macro DBG_EVAL   2     // postfix evaluation & expression results
#macro DBG_FLOW   4     // IF/WHILE/WEND/GOTO/GOSUB decisions
#macro DBG_IO     8     // INPUT/PRINT/UI prompts & commits
#macro DBG_ARRAY  16    // DIM + array get/set + bounds logs
#macro DBG_ALL    0x7fffffff  // convenience: everything on
```

> IMPORTANT: Macros must live at **top level** (not inside a function). Keep
> this file as-is; don’t wrap these lines in a function.

## REQUIRED COMPANION (dbg.gml)

You also have two helper functions defined in `dbg.gml`:

```
function dbg_on(cat) -> bool
    // Returns TRUE if the category bit is enabled in global.debug_mask.
    // Very cheap; use around *occasional* logs.

function dbg(cat, msg) -> void
    // Prints a message if the category bit is enabled AND you haven’t
    // exceeded the per-frame quota. Use inside tight loops to avoid FPS hits.
```

Both helpers rely on these globals, which you should initialize once in your
interpreter’s Create/Init event:

```
if (!variable_global_exists("debug_mask")) {
    global.debug_mask        = DBG_ALL;   // start verbose; tune later
    global.dbg_frame_quota   = 1200;      // max logs per frame before dropping
    global.dbg_frame_count   = 0;         // internal counter (do not set manually)
    global.dbg_dropped_count = 0;         // internal counter (do not set manually)
}
```

And reset the quota each frame (Step Start of the interpreter object):

```
global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}
```

## HOW TO WRAP EXISTING LOGS

You have hundreds of `show_debug_message(...)` calls. Wrap them gradually:

• High-volume / in loops (tokenizer, postfix, array hot-paths) → **use `dbg()`**
This enforces the per-frame quota automatically.
BEFORE:
show\_debug\_message("TOKENIZER: Char\[" + string(i) + "]='" + c + "'");
AFTER:
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "]='" + c + "'");

• Low-volume / occasional (flow decisions, one-off prints) → **use `dbg_on()`**
This is a tiny mask check; then you call `show_debug_message` yourself.
BEFORE:
show\_debug\_message("WEND: Condition is TRUE — looping");
AFTER:
if (dbg\_on(DBG\_FLOW)) show\_debug\_message("WEND: Condition is TRUE — looping");

Tip: It’s fine to mix both styles. Prefer `dbg()` anywhere that can spam.

## WHAT EACH MASK MEANS (AND WHERE TO USE IT)

• DBG\_PARSE
Use on: tokenizer (`basic_tokenize_expression_v2`), parser/splitters,
command lexing (verb/arg extraction).
Goal: see how text becomes tokens. No evaluation yet.

• DBG\_EVAL
Use on: postfix creation/evaluation, math/operator application, variable loads.
Goal: see stack pushes/pops and numeric/string results.

• DBG\_FLOW
Use on: `basic_cmd_if/_if_inline`, `basic_cmd_while`, `basic_cmd_wend`,
loop stack push/pop, `GOTO/GOSUB/RETURN` target resolution.
Goal: follow control flow decisions and jumps.

• DBG\_IO
Use on: `basic_cmd_input`, `basic_cmd_print`, wrapping/commit pipeline,
prompt emission, input state flips.
Goal: ensure prompts and outputs render and input mode is toggled correctly.

• DBG\_ARRAY
Use on: `basic_cmd_dim`, `basic_array_get`, `basic_array_set`, bounds checks.
Goal: track sizes, indices, auto-grow, and OOB warnings.

• DBG\_ALL
Convenience macro: enable all categories at once.

## HOW TO TURN CATEGORIES ON/OFF

At runtime (debugger Watch window, a script, or once in Create):

```
// All off:
global.debug_mask = 0;

// Only FLOW:
global.debug_mask = DBG_FLOW;

// Only IO:
global.debug_mask = DBG_IO;

// FLOW + IO together:
global.debug_mask = DBG_FLOW | DBG_IO;

// Everything on:
global.debug_mask = DBG_ALL;
```

You can also toggle bits on the fly:

```
// Flip the PARSE bit:
global.debug_mask ^= DBG_PARSE;
```

If you temporarily cranked the quota for a heavy trace, put it back:

```
global.dbg_frame_quota = 1200;    // typical safe value
// (set larger, e.g., 100000, if you want to capture *everything* for a short run)
```

## OPTIONAL: QUICK HOTKEY TO CYCLE VERBOSITY

Add this to the interpreter object’s Step (or Step Begin):

```
if (keyboard_check_pressed(vk_f9)) {
    var next = (global.debug_mask == 0)
        ? (DBG_FLOW | DBG_IO)   // useful day-to-day
        : (global.debug_mask == (DBG_FLOW | DBG_IO) ? DBG_ALL : 0);
    global.debug_mask = next;
    show_debug_message("DBG: mask now = " + string(next));
}
```

## COMMON PITFALLS & TIPS

• Macros not recognized → Ensure this file (`dbg_macros.gml`) is a separate
script asset with **only** the `#macro` lines at top level. If you still see
“variable not defined” on a macro name, **Clean** the project and rebuild.

• Compile order → Place `dbg_macros.gml` near the top of your Scripts folder so
everything else sees it. (Macros are compile-time, but ordering can trip
partial rebuilds.)

• Use `dbg()` for anything inside loops; it’s quota-aware. If you use
`dbg_on()` + `show_debug_message(...)` in a hot loop you can still tank FPS.

• Migration strategy → You don’t need to wrap everything at once. Start with:
tokenizer (DBG\_PARSE), evaluation (DBG\_EVAL), flow (DBG\_FLOW). That usually
kills 90% of the spam while keeping the most actionable signal.

## EXAMPLES (COPY/PASTE)

Tokenizer char echo (quota-aware):
dbg(DBG\_PARSE, "TOKENIZER: Char\[" + string(i) + "] = '" + string\_char\_at(s, i) + "'");

Flow decision:
if (dbg\_on(DBG\_FLOW))
show\_debug\_message("IF: result=" + string(result) + " → " + (result ? "THEN" : "ELSE"));

Input prompt emission:
dbg(DBG\_IO, "INPUT: Prompt='" + rawPrompt + "' → var=" + varName);

Array set:
dbg(DBG\_ARRAY, "ARRAY SET: " + name + "\[" + string(idx) + "] = " + string(val));

## QUICK START

1. Keep these macros here (top level).
2. Ensure `dbg.gml` exists with `dbg_on` and `dbg`.
3. Initialize the globals in Create, reset counters in Step Start.
4. Wrap high-volume logs with `dbg(cat, msg)`, occasional logs with `dbg_on`.
5. Control verbosity by setting `global.debug_mask` at runtime:
   • All off: 0
   • Only FLOW: DBG\_FLOW
   • Only IO: DBG\_IO
   • FLOW + IO: DBG\_FLOW | DBG\_IO
   • Everything: DBG\_ALL
6. If things feel slow, reduce the mask and/or lower `global.dbg_frame_quota`.

That’s it. You keep the power of your detailed logs without drowning the Runner.
*/


================================================================================

/// @file scripts/dbg_on/dbg_on.gml

function dbg_on(cat) {
    return (global.debug_mask & cat) != 0;
}



================================================================================

/// @file scripts/delete_program_line/delete_program_line.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function delete_program_line(line_num) {
    ds_map_delete(global.program_lines, line_num);
    var pos = ds_list_find_index(global.line_numbers, line_num);
    if (pos != -1) {
        ds_list_delete(global.line_numbers, pos);
    }
 }

================================================================================

/// @file scripts/dump_program_to_console/dump_program_to_console.gml

function dump_program_to_console() {
    if (dbg_on(DBG_FLOW)) show_debug_message("==== BASIC PROGRAM DUMP ====");

    var lines = global.line_numbers; // numeric line numbers
    var prog = global.program_lines;

    for (var i = 0; i < ds_list_size(lines); i++) {
        var linenum = ds_list_find_value(lines, i); // numeric
        if (ds_map_exists(prog, linenum)) {
            var code = ds_map_find_value(prog, linenum);
            if (dbg_on(DBG_FLOW)) show_debug_message(string(linenum) + " " + code);
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("Missing entry for key: " + string(linenum));
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("==== END OF DUMP ====");
}


================================================================================

/// @file scripts/editor__apply_pasted_text/editor__apply_pasted_text.gml

/// FILE: scripts/editor__apply_pasted_text.gml
/// @function editor__apply_pasted_text(text)
/// @desc Parses BASIC lines from `text` and mutates global.program_lines/global.line_numbers.
/// @returns {bool} true if at least one line was applied; false otherwise
function editor__apply_pasted_text(text) {
    if (is_undefined(text) || string_length(text) <= 0) {
        show_message("Clipboard is empty.");
        return false;
    }

    var applied = false;
    var lines = string_split(text, "\n");
    if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
       if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: received " + string(array_length(lines)) + " raw lines");
    }

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);
        if (string_length(line) == 0) continue;

        var space_pos = string_pos(" ", line);
        if (space_pos <= 0) continue;

        var line_num_str = string_copy(line, 1, space_pos - 1);
        var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

        // Strip trailing CR in CRLF cases
        if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
            code_str = string_copy(code_str, 1, string_length(code_str) - 1);
        }

        // Validate line number is digits-only
        if (string_digits(line_num_str) != line_num_str) continue;

        var line_num = real(line_num_str);
        if (line_num <= 0 || string_length(code_str) <= 0) continue;

        // Insert/replace in program_lines
        ds_map_set(global.program_lines, line_num, code_str);

        if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
           if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");
        }

        // Maintain ordered list of line numbers
        var idx = ds_list_find_index(global.line_numbers, line_num);
        if (idx == -1) {
            ds_list_add(global.line_numbers, line_num);
            ds_list_sort(global.line_numbers, true);
            if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
               if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
            }
        } else if (function_exists(dbg_on) && dbg_on(DBG_FLOW)) {
            show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
        }

        applied = true;
    }

    if (applied) {
        basic_show_message("Program pasted successfully.");
    } else {
        // Nothing matched the `<num> <code>` pattern; keep parity with Windows behavior:
        // do not show success if nothing was applied.
        show_message("Clipboard is empty or not in '<line> <code>' format.");
    }
    return applied;
}


================================================================================

/// @file scripts/editor_handle_paste_command/editor_handle_paste_command.gml

/// @function editor_handle_paste_command
// === BEGIN: editor_handle_paste_command ===
function editor_handle_paste_command() {
	
	// Prevent HTML5 from touching the clipboard API
	if (os_browser != browser_not_a_browser) {
	    show_error_message("Use :PASTE to open paste box in browser.");
	    return;
	}

	
	
    var raw_clip = clipboard_get_text();
    if (string_length(raw_clip) <= 0) {
        show_message("Clipboard is empty.");
        return;
    }

    var lines = string_split(raw_clip, "\n");
    if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: captured " + string(array_length(lines)) + " raw lines");

    for (var i = 0; i < array_length(lines); i++) {
        var line = string_trim(lines[i]);
        if (string_length(line) == 0) continue;

        // Expect: <number><space><code>
        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var line_num_str = string_copy(line, 1, space_pos - 1);
            var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            // Windows CRLF: trim trailing '\r' if present
            if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
                code_str = string_copy(code_str, 1, string_length(code_str) - 1);
            }

            if (string_digits(line_num_str) == line_num_str) {
                var line_num = real(line_num_str);

                if (line_num > 0 && string_length(code_str) > 0) {
                    // INSERT or REPLACE program text
                    ds_map_set(global.program_lines, line_num, code_str);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");

                    // Maintain ordered line number list — add only if not present
                    var idx = ds_list_find_index(global.line_numbers, line_num);
                    if (idx == -1) {
                        ds_list_add(global.line_numbers, line_num);
                        ds_list_sort(global.line_numbers, true);
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
                    } else if (dbg_on(DBG_FLOW)) {
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
                    }
                }
            }
        }
    }

    basic_show_message("Program pasted successfully.");
}
// === END: editor_handle_paste_command ===


================================================================================

/// @file scripts/editor_html_build_program_text/editor_html_build_program_text.gml

/// @function editor_html_build_program_text
/// @desc Serialize the current BASIC program into canonical lines: "<line> <code>\r\n"
///       Uses the same sources your desktop save_program_as() already prefers.
/// @returns {string}
function editor_html_build_program_text() {
    var lines_list = ds_list_create(); // ordered strings to emit
    var source_used = "NONE";
    var ed = instance_find(obj_editor, 0);

    // === Try obj_editor.program_lines (array) ===
    if (ed != noone && variable_instance_exists(ed, "program_lines") && is_array(ed.program_lines)) {
        for (var i = 0; i < array_length(ed.program_lines); i++) {
            ds_list_add(lines_list, string(ed.program_lines[i]));
        }
        if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (array)";
    }

    // === Try obj_editor.program_lines (ds_list) ===
    if (source_used == "NONE" && ed != noone && variable_instance_exists(ed, "program_lines") &&
        ds_exists(ed.program_lines, ds_type_list)) {
        var n = ds_list_size(ed.program_lines);
        for (var j = 0; j < n; j++) {
            ds_list_add(lines_list, string(ds_list_find_value(ed.program_lines, j)));
        }
        if (n > 0) source_used = "obj_editor.program_lines (ds_list)";
    }

    // === Try obj_editor.program_lines (ds_map keyed by line numbers) ===
    if (source_used == "NONE" && ed != noone && variable_instance_exists(ed, "program_lines") &&
        ds_exists(ed.program_lines, ds_type_map)) {

        var epl_keys = ds_list_create();
        var e_k = ds_map_find_first(ed.program_lines);
        while (e_k != undefined) { ds_list_add(epl_keys, e_k); e_k = ds_map_find_next(ed.program_lines, e_k); }

        var epl_numeric = true;
        for (var ei = 0; ei < ds_list_size(epl_keys); ei++) {
            if (!is_real(ds_list_find_value(epl_keys, ei))) { epl_numeric = false; break; }
        }
        if (epl_numeric) ds_list_sort(epl_keys, true);

        for (var ej = 0; ej < ds_list_size(epl_keys); ej++) {
            var _ln  = ds_list_find_value(epl_keys, ej);
            var _val = ds_map_find_value(ed.program_lines, _ln);
            ds_list_add(lines_list, string(_ln) + " " + string(_val));
        }
        if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (ds_map)";

        ds_list_destroy(epl_keys);
    }

    // === Try common ds_map containers keyed by line numbers ===
    if (source_used == "NONE") {
        var map_names = [
            "program_map", "program_lines_map", "basic_program",
            "lines_map", "line_store", "program"
        ];
        for (var mi = 0; mi < array_length(map_names); mi++) {
            var mn = map_names[mi];
            if (variable_instance_exists(ed, mn) && ds_exists(ed[? mn], ds_type_map)) {
                var keys = ds_list_create();
                var k = ds_map_find_first(ed[? mn]);
                while (k != undefined) { ds_list_add(keys, k); k = ds_map_find_next(ed[? mn], k); }
                var numeric = true;
                for (var ki = 0; ki < ds_list_size(keys); ki++) {
                    if (!is_real(ds_list_find_value(keys, ki))) { numeric = false; break; }
                }
                if (numeric) ds_list_sort(keys, true);
                for (var kj = 0; kj < ds_list_size(keys); kj++) {
                    var _ln  = ds_list_find_value(keys, kj);
                    var val = ds_map_find_value(ed[? mn], _ln);
                    ds_list_add(lines_list, string(_ln) + " " + string(val));
                }
                ds_list_destroy(keys);
                if (ds_list_size(lines_list) > 0) { source_used = "obj_editor." + mn; break; }
            }
        }
    }

    // === Try global.program_lines (ds_map keyed by line numbers) ===
    if (source_used == "NONE" && variable_global_exists("program_lines") && ds_exists(global.program_lines, ds_type_map)) {
        var gpl_keys = ds_list_create();
        var gpl_k = ds_map_find_first(global.program_lines);
        while (gpl_k != undefined) { ds_list_add(gpl_keys, gpl_k); gpl_k = ds_map_find_next(global.program_lines, gpl_k); }
        var gpl_numeric = true;
        for (var gpi = 0; gpi < ds_list_size(gpl_keys); gpi++) {
            if (!is_real(ds_list_find_value(gpl_keys, gpi))) { gpl_numeric = false; break; }
        }
        if (gpl_numeric) ds_list_sort(gpl_keys, true);
        for (var gpj = 0; gpj < ds_list_size(gpl_keys); gpj++) {
            var gln  = ds_list_find_value(gpl_keys, gpj);
            var gval = ds_map_find_value(global.program_lines, gln);
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        ds_list_destroy(gpl_keys);
        if (ds_list_size(lines_list) > 0) source_used = "global.program_lines (ds_map)";
    }

    // --- Emit CRLF text
    var out = "";
    var total = ds_list_size(lines_list);
    for (var ii = 0; ii < total; ii++) {
        out += string(ds_list_find_value(lines_list, ii)) + "\r\n";
    }
    ds_list_destroy(lines_list);
    return out; // empty if nothing found
}


================================================================================

/// @file scripts/editor_html_decode_data_url_to_text/editor_html_decode_data_url_to_text.gml

/// Decode a data: URL (base64) into a text string (ASCII/UTF-8)
function editor_html_decode_data_url_to_text(data_url) {
    var comma = string_pos(",", data_url);
    if (comma <= 0) return "";
    var b64 = string_copy(data_url, comma + 1, string_length(data_url) - comma);

    var buf = buffer_base64_decode(b64); // native GMS
    if (buf <= 0) return "";
    buffer_seek(buf, buffer_seek_start, 0);

    var n = buffer_get_size(buf);
    var s = "";
    for (var i = 0; i < n; i++) {
        s += chr(buffer_read(buf, buffer_u8));
    }
    buffer_delete(buf);
    return s;
}


================================================================================

/// @file scripts/editor_html_dir__open_filter/editor_html_dir__open_filter.gml

/// Persistent filter for YAL open dialog (files only)
function editor_html_dir__open_filter(kind, type) {
    return (kind == "file");
}


================================================================================

/// @file scripts/editor_html_dir__open_handler/editor_html_dir__open_handler.gml

function editor_html_dir__open_handler(data, name, type) {
    if (dbg_on(DBG_FLOW)) show_debug_message("[ENTER] editor_html_dir__open_handler");
    
    // clear the guard immediately on first callback
    if (variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;

    if (is_undefined(name)) { // defensive
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir__open_handler (undefined name)");
        return;
    }

    if (!variable_global_exists("html_dir_files")) global.html_dir_files = ds_list_create();
    var rec = ds_map_create();
    ds_map_set(rec, "name", name);
    ds_map_set(rec, "type", type);
    ds_map_set(rec, "data", data);

    // estimate size from base64 length (as before)
    var size_est = 0, comma = string_pos(",", data);
    if (comma > 0) {
        var b64 = string_copy(data, comma + 1, string_length(data) - comma);
        var L = string_length(b64), pad = 0;
        if (L >= 1 && string_char_at(b64, L) == "=") pad++;
        if (L >= 2 && string_char_at(b64, L - 1) == "=") pad++;
        size_est = max(0, floor(L * 3 / 4) - pad);
    }
    ds_map_set(rec, "size", size_est);

    ds_list_add(global.html_dir_files, rec);
    if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] added '" + name + "' (" + string(size_est) + " bytes)");

    // After all files are loaded, automatically show the directory overlay
    // Use call_later to ensure all files are processed first
    if (!variable_global_exists("__html_dir_auto_show_scheduled") || !global.__html_dir_auto_show_scheduled) {
        global.__html_dir_auto_show_scheduled = true;
        
        // Schedule the directory show for next frame
        call_later(1, time_source_units_frames, function() {
            // Only show if we have .bas files
            if (variable_global_exists("html_dir_files") && ds_list_size(global.html_dir_files) > 0) {
                var has_bas_files = false;
                var n = ds_list_size(global.html_dir_files);
                for (var i = 0; i < n; i++) {
                    var rec = global.html_dir_files[| i];
                    var filename = ds_map_find_value(rec, "name");
                    if (string_pos(".bas", string_lower(filename)) > 0) {
                        has_bas_files = true;
                        break;
                    }
                }
                
                if (has_bas_files) {
                    editor_html_dir_show();
                    basic_show_message("Files loaded. Use arrows to select, Enter to open.");
                } else {
                    basic_show_message("Files selected, but no .bas files found.");
                }
            }
            global.__html_dir_auto_show_scheduled = false;
        });
    }
    
    if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir__open_handler");
}

================================================================================

/// @file scripts/editor_html_dir__reset/editor_html_dir__reset.gml

/// Destroys previous records and clears the list.
function editor_html_dir__reset() {
    if (!variable_global_exists("html_dir_files")) {
        global.html_dir_files = ds_list_create();
        return;
    }
    var n = ds_list_size(global.html_dir_files);
    for (var i = 0; i < n; i++) {
        var rec = global.html_dir_files[| i];
        if (ds_exists(rec, ds_type_map)) ds_map_destroy(rec);
    }
    ds_list_clear(global.html_dir_files);
}


================================================================================

/// @file scripts/editor_html_dir_open/editor_html_dir_open.gml

/// Load a selected file (by 1-based index or exact filename) into program_lines/line_numbers
function editor_html_dir_open(which) {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("html_dir_files") || ds_list_size(global.html_dir_files) == 0) {
        show_message("No files selected. Use DIR to choose files first.");
        return false;
    }

    var idx = -1, n = ds_list_size(global.html_dir_files);
    var w = string_trim(which), W = string_upper(w);

    // numeric index (1-based)
    if (string_digits(w) == w) {
        var k = real(w);
        if (k >= 1 && k <= n) idx = k - 1;
    }
    // filename match
    if (idx < 0) {
        for (var i = 0; i < n; i++) {
            var rec_i = global.html_dir_files[| i];
            if (string_upper(ds_map_find_value(rec_i, "name")) == W) { idx = i; break; }
        }
    }
    if (idx < 0) { show_message("Not found. Use DIR SHOW to see indexes."); return false; }

    var rec = global.html_dir_files[| idx];
    var text = editor_html_decode_data_url_to_text(ds_map_find_value(rec, "data"));
    if (string_length(text) <= 0) {
        show_message("Unable to read file text.");
        return false;
    }

    // Parse exactly like your paste/Windows path
    var lines = string_split(text, "\n");
   if (dbg_on(DBG_FLOW)) show_debug_message("LOAD(HTML): captured " + string(array_length(lines)) + " raw lines");

    for (var j = 0; j < array_length(lines); j++) {
        var line = string_trim(lines[j]);
        if (string_length(line) == 0) continue;

        var space_pos = string_pos(" ", line);
        if (space_pos > 0) {
            var ln_str = string_copy(line, 1, space_pos - 1);
            var code   = string_copy(line, space_pos + 1, string_length(line) - space_pos);

            if (string_length(code) > 0 && string_char_at(code, string_length(code)) == chr(13)) {
                code = string_copy(code, 1, string_length(code) - 1);
            }

            if (string_digits(ln_str) == ln_str) {
                var _ln = real(ln_str);
                if (_ln > 0 && string_length(code) > 0) {
                    ds_map_set(global.program_lines, _ln, code);
                    var found = ds_list_find_index(global.line_numbers, _ln);
                    if (found == -1) { ds_list_add(global.line_numbers, _ln); ds_list_sort(global.line_numbers, true); }
                }
            }
        }
    }

    basic_show_message("Program loaded: " + ds_map_find_value(rec, "name"));
    return true;
}


================================================================================

/// @file scripts/editor_html_dir_prompt/editor_html_dir_prompt.gml

function editor_html_dir_prompt() {
    if (dbg_on(DBG_FLOW)) show_debug_message("[ENTER] editor_html_dir_prompt");

    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt (not browser)");
        return false;
    }

    // --- Re-entrancy guard: prevent duplicate dialogs for a single DIR dispatch
    if (!variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;
    if (global.__html_dir_opening) {
        if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] prompt suppressed (already opening)");
        if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt (guard)");
        return false;
    }
    global.__html_dir_opening = true;

    // --- Init extension (safe to call repeatedly)
    browser_file_tools_init();

    // --- Reset cached list (destroy old maps, clear list)
    editor_html_dir__reset();

    // --- Open dialog (multiselect = true). Accept .bas and text/plain
    browser_show_open_dialog(
        ".bas,text/plain",
        true,
        editor_html_dir__open_handler,   // persistent handler; will clear the guard
        editor_html_dir__open_filter
    );

    // Show the warning message about potential bugs using BASIC interpreter's message system
    basic_show_message("If Load fails, try again: bugs.");

    if (dbg_on(DBG_FLOW)) show_debug_message("[DIR/HTML] open dialog shown");
    if (dbg_on(DBG_FLOW)) show_debug_message("[EXIT] editor_html_dir_prompt");
    return true;
}

================================================================================

/// @file scripts/editor_html_dir_show/editor_html_dir_show.gml

function editor_html_dir_show() {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML DIR is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("html_dir_files") || ds_list_size(global.html_dir_files) == 0) {
        basic_show_message("No files selected. Use DIR to choose files first.");
        return false;
    }

    var ed = instance_find(obj_editor, 0);
    if (ed == noone) return false;

    // Initialize directory variables
    ed.dir_listing = [];
    ed.showing_dir_overlay = false;
    ed.dir_save_dir = "";

    // Build listing from html_dir_files
    var n = ds_list_size(global.html_dir_files);
    for (var i = 0; i < n; i++) {
        var rec = global.html_dir_files[| i];
        var filename = ds_map_find_value(rec, "name");
        array_push(ed.dir_listing, filename);
    }
    
    if (n == 0) {
        array_push(ed.dir_listing, "No .bas files found.");
    }

    // Initialize overlay state
    ed.dir_sel = 0;
    ed.dir_page = 0;
    ed.dir_page_size = 1;
    ed.dir_sorted_by = "name";
    ed.dir_filter = "";
    ed.dir_preview_on = false;
    ed.dir_confirm_active = false;
    ed.dir_confirm_index = -1;
    ed.dir_mouse_hover_row = -1;
    ed.dir_mouse_hover_action = "";

    // Show the overlay
    ed.showing_dir_overlay = true;
    return true;
}

================================================================================

/// @file scripts/editor_html_handle_paste_command/editor_html_handle_paste_command.gml

/// @function editor_html_handle_paste_command
// === BEGIN: editor_html_handle_paste_command ===
function editor_html_handle_paste_command() {
    // Only meaningful in browser builds; desktop uses editor_handle_paste_command
    if (os_browser == browser_not_a_browser) {
        show_error_message("Use normal Paste on desktop. :PASTE is for browser builds.");
        return;
    }

    // Gate to avoid double-bind/log spam
    if (is_undefined(global.__editor_html_paste_bound)) global.__editor_html_paste_bound = false;
    if (global.__editor_html_paste_bound) {
        // Already waiting for a Ctrl/Cmd+V from the user
        basic_show_message("Paste is already waiting — click the game, then press Ctrl+V (⌘V on Mac).");
        if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE/HTML] already bound");
        return;
    }

    // Accept text only
    var _filter = function(kind, type) {
        // kind: "string" for text; "file" for files
        return (kind == "string");
    };

    // One-shot handler: identical parsing/mutation to Windows path
    var _handler = function(data, name, type) {
        // For text, YellowAfterLife sets name==undefined
        if (!is_undefined(name)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE/HTML] ignored non-text paste: name=" + string(name) + " type=" + string(type));
            // unbind and reset
            browser_paste_bind();
            global.__editor_html_paste_bound = false;
            return;
        }

        var raw_clip = string(data);
        if (string_length(raw_clip) <= 0) {
            show_message("Clipboard is empty.");
            browser_paste_bind();
            global.__editor_html_paste_bound = false;
            return;
        }

        var lines = string_split(raw_clip, "\n");
        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: captured " + string(array_length(lines)) + " raw lines");

        for (var i = 0; i < array_length(lines); i++) {
            var line = string_trim(lines[i]);
            if (string_length(line) == 0) continue;

            // Expect: <number><space><code>
            var space_pos = string_pos(" ", line);
            if (space_pos > 0) {
                var line_num_str = string_copy(line, 1, space_pos - 1);
                var code_str     = string_copy(line, space_pos + 1, string_length(line) - space_pos);

                // Windows CRLF: trim trailing '\r' if present
                if (string_length(code_str) > 0 && string_char_at(code_str, string_length(code_str)) == chr(13)) {
                    code_str = string_copy(code_str, 1, string_length(code_str) - 1);
                }

                if (string_digits(line_num_str) == line_num_str) {
                    var line_num = real(line_num_str);

                    if (line_num > 0 && string_length(code_str) > 0) {
                        // INSERT or REPLACE program text
                        ds_map_set(global.program_lines, line_num, code_str);
                        if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: set " + string(line_num) + " → '" + code_str + "'");

                        // Maintain ordered line number list — add only if not present
                        var idx = ds_list_find_index(global.line_numbers, line_num);
                        if (idx == -1) {
                            ds_list_add(global.line_numbers, line_num);
                            ds_list_sort(global.line_numbers, true);
                            if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: added line number " + string(line_num));
                        } else if (dbg_on(DBG_FLOW)) {
                           if (dbg_on(DBG_FLOW)) show_debug_message("PASTE: updated existing line number " + string(line_num) + " (idx=" + string(idx) + ")");
                        }
                    }
                }
            }
        }

        basic_show_message("Program pasted successfully.");

        // One-shot: unbind after handling a paste so normal keys resume
        browser_paste_bind();
        global.__editor_html_paste_bound = false;
    };

    // Bind paste; some wrappers don’t return a bool to GML, so don’t trust the return value
    browser_paste_bind(_handler, _filter);
    global.__editor_html_paste_bound = true;

    // Match your existing UX/logging
    if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Bound. Click the game, then press Ctrl/Cmd+V.");
    basic_show_message("Paste ready — click the game, then press Ctrl+V (⌘V on Mac).");
}
// === END: editor_html_handle_paste_command ===


================================================================================

/// @file scripts/editor_html_save_program/editor_html_save_program.gml

/// @function editor_html_save_program
/// @desc HTML-only wrapper mirroring save_program()
/// Uses global current_filename (parity with desktop)
function editor_html_save_program() {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML save is only available in browser builds.");
        return false;
    }
    if (!variable_global_exists("current_filename") || string_length(current_filename) == 0) {
        show_error_message("NO FILENAME");
        return false;
    }
    return editor_html_save_program_as(current_filename);
}


================================================================================

/// @file scripts/editor_html_save_program_as/editor_html_save_program_as.gml

function editor_html_save_program_as(filename) {
    if (os_browser == browser_not_a_browser) {
        show_error_message("HTML save is only available in browser builds.");
        return false;
    }

    // Initialize the extension (safe to call each time; no-op if already inited)
    browser_file_tools_init();

    // --- Normalize filename (parity with desktop)
    filename = string_trim(filename);
    if (string_length(filename) == 0) { show_error_message("NO FILENAME PROVIDED"); return false; }
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename) - 2);
    }
    filename = string_replace_all(filename, "/",  "_");
    filename = string_replace_all(filename, "\\", "_");
    filename = string_replace_all(filename, "..", "_");
    filename = string_replace_all(filename, ".bas", "");
    filename = filename + ".bas";

    // --- Build program text
    var text = editor_html_build_program_text();
    if (string_length(text) == 0) {
        show_error_message("NOTHING TO SAVE — no program lines found");
        return false;
    }

    // --- Create byte buffer (CRLF preserved)
    var n = string_length(text);
    var buf = buffer_create(n, buffer_fixed, 1);
    for (var i = 1; i <= n; i++) {
        buffer_write(buf, buffer_u8, ord(string_char_at(text, i)));
    }
    buffer_seek(buf, buffer_seek_start, 0);

    // --- Call the YAL wrapper directly (wrapper is present in your build)
    browser_show_save_dialog(buf, filename, "text/plain; charset=utf-8", n);

    buffer_delete(buf);
    return true;
}


================================================================================

/// @file scripts/editor_html_save_selftest/editor_html_save_selftest.gml

/// @function editor_html_save_selftest()
function editor_html_save_selftest() {
    if (function_exists("browser_file_tools_init")) browser_file_tools_init();
    if (!function_exists("browser_show_save_dialog")) {
        show_error_message("Save dialog function not present.");
        return;
    }
    var s = "HELLO\r\n";
    var n = string_length(s);
    var b = buffer_create(n, buffer_fixed, 1);
    for (var i = 1; i <= n; i++) buffer_write(b, buffer_u8, ord(string_char_at(s, i)));
    buffer_seek(b, buffer_seek_start, 0);
    browser_show_save_dialog(b, "selftest.bas", "text/plain; charset=utf-8", n);
    buffer_delete(b);
    basic_show_message("Save self-test offered.");
}


================================================================================

/// @file scripts/editor_import_text_to_program/editor_import_text_to_program.gml

/// @function editor_import_text_to_program(_text)
/// @desc Parse plain text into numbered BASIC lines and import.
/// Lines in form "NNN CODE..."; a bare "NNN" deletes that line.
function editor_import_text_to_program(_text) {
    if (!is_string(_text)) return 0;

    // Normalize line endings
    var blob = string_replace_all(string_replace_all(_text, "\r\n", "\n"), "\r", "\n");

    var count = 0;
    var i = 1, len = string_length(blob), start = 1;
    while (i <= len + 1) {
        if (i > len || string_char_at(blob, i) == "\n") {
            var line = string_trim(string_copy(blob, start, i - start));
            if (line != "") {
                var sp = string_pos(" ", line);
                var ln_str = (sp > 0) ? string_copy(line, 1, sp - 1) : line;
                var code   = (sp > 0) ? string_trim(string_copy(line, sp + 1, string_length(line))) : "";
                var _ln = real(ln_str);
                if (ln_str != "" && is_real(_ln) && _ln > 0) {
                    if (code == "") {
                        // delete empty-numbered line
                        if (function_exists("delete_program_line")) delete_program_line(_ln);
                    } else {
                        if (function_exists("add_or_update_program_line")) add_or_update_program_line(_ln, code);
                    }
                    count++;
                }
            }
            start = i + 1;
        }
        i++;
    }
    return count;
}


================================================================================

/// @file scripts/evaluate_postfix/evaluate_postfix.gml

/// @script evaluate_postfix
/// @description Evaluate a postfix token array, with support for 1-D arrays.
/// Notes:
/// - Array tokens arrive as a single atom like "D(I)" because infix_to_postfix collapses NAME(...).
/// - We defensively avoid treating built-in functions as arrays (e.g., "INT(5)").
/// - Comma tokens are ignored completely.
/// - Returns the TOP of the stack (last pushed), else 0.

function evaluate_postfix(postfix) {
    var stack = [];
    if (dbg_on(DBG_PARSE)) show_debug_message("Evaluating postfix: " + string(postfix));

    for (var i = 0; i < array_length(postfix); i++) {
        var token = postfix[i];
        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Processing token [" + string(i) + "] → " + string(token));

        // Normalize once
        var trimmed     = string_trim(string(token));
        var token_upper = string_upper(trimmed);

        // -------------------------------------------------------
        // Ignore commas completely (arg separators, never values)
        // -------------------------------------------------------
        if (trimmed == ",") {
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Ignoring stray comma token");
            continue;
        }

        // -------------------------------------------------------
        // ARRAY READ SUPPORT (atom form: NAME(index_expr))
        // -------------------------------------------------------
        var openPos = string_pos("(", token_upper);
        if (openPos > 0 && string_char_at(token_upper, string_length(token_upper)) == ")") {
            var arrNameU   = string_copy(token_upper, 1, openPos - 1);
            var innerLen   = string_length(token) - openPos - 1;
            var idxTextRaw = string_copy(token, openPos + 1, innerLen);

            // MINIMAL CHANGE: also skip STRING$ here even if is_function() doesn't know it
            if (!is_function(arrNameU) && arrNameU != "STRING$") {
                var arrName = arrNameU; // arrays stored uppercase in helpers
                var idxText = string_trim(idxTextRaw);

                if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY]: Candidate '" + string(token) + "' → name='" + arrName + "', idxText='" + idxText + "'");

                var idxVal = basic_evaluate_expression_v2(idxText);
                if (!is_real(idxVal)) {
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY] ERROR: Index non-numeric from '" + idxText + "' → '" + string(idxVal) + "'. Pushing 0.");
                    array_push(stack, 0);
                    continue;
                }

                var arrVal = basic_array_get(arrName, idxVal); // your 1-based getter
                if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY]: " + arrName + "(" + string(idxVal) + ") → " + string(arrVal));
                array_push(stack, arrVal);
                continue;
            }
        }

        // -------------------------------------------------------
        // Numeric literal
        // -------------------------------------------------------
        if (is_numeric_string(trimmed)) {
            var num = real(trimmed);
            array_push(stack, num);
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed number → " + string(num));
            continue;
        }

        // -------------------------------------------------------
        // Quoted string literal
        // -------------------------------------------------------
        if (string_length(trimmed) >= 2
        &&  string_char_at(trimmed, 1) == "\""
        &&  string_char_at(trimmed, string_length(trimmed)) == "\"")
        {
            var str = string_copy(trimmed, 2, string_length(trimmed) - 2);
            str = string_replace_all(str, "\"\"", "\"");  // unescape "" -> "
            array_push(stack, str);
            if (dbg_on(DBG_FLOW)) if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed quoted string literal → " + str);
            continue;
        }

        // -------------------------------------------------------
        // Operators
        // -------------------------------------------------------
        if (is_operator(token_upper)) {
            if (array_length(stack) < 2) {
                if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX ERROR: Not enough operands for operator " + token_upper);
                return 0;
            }
            var b = array_pop(stack);
            var a = array_pop(stack);
            var result = 0;

            switch (token_upper) {
                case "+":  result = (is_string(a) || is_string(b)) ? string(a) + string(b) : a + b; break;
                case "-":
                    if (is_string(a)) a = real(a);
                    if (is_string(b)) b = real(b);
                    result = a - b; break;
                case "=":
                    if (is_string(a)) a = real(a);
                    if (is_string(b)) b = real(b);
                    result = (a == b) ? 1 : 0;
                    break;
                case "*":
                    if (is_string(a)) a = real(a);
                    if (is_string(b)) b = real(b);
                    result = a * b; break;
                case "/":
                    if (is_string(a)) a = real(a);
                    if (is_string(b)) b = real(b);
                    result = (b != 0) ? a / b : 0; break;

                case "\\": { // integer division → truncate toward ZERO
                    if (is_string(a) && is_numeric_string(a)) a = real(a);
                    if (is_string(b) && is_numeric_string(b)) b = real(b);

                    if (!is_real(a) || !is_real(b)) {
                        basic_syntax_error("Integer division '\\' expects numbers; got a=" + string(a) + ", b=" + string(b),
                            global.current_line_number, global.interpreter_current_stmt_index, "TYPE_MISMATCH");
                        result = 0;
                        break;
                    }
                    if (b == 0) {
                        basic_syntax_error("Division by zero in '\\'",
                            global.current_line_number, global.interpreter_current_stmt_index, "DIV_ZERO");
                        result = 0;
                        break;
                    }

                    var q = a / b;
                    q = (q >= 0) ? floor(q) : ceil(q); // trunc-to-zero
                    result = q;
                    break;
                }

                case "%":
                case "MOD":
                    if (is_string(a)) a = real(a);
                    if (is_string(b)) b = real(b);
                    result = a mod b; break;
                case "^":
                    if (is_string(a)) a = real(a);
                    if (is_string(b)) b = real(b);
                    result = power(a, b); break;
                default:
                    if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX WARNING: Unknown operator = " + token_upper + " → 0");
                    result = 0; break;
            }

            array_push(stack, result);
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Operator result (" + token_upper + ") = " + string(result));
            continue;
        }

        // -------------------------------------------------------
        // Functions (numeric + string)
        // -------------------------------------------------------
        if (is_function(token_upper) || token_upper == "STRING$") {
            token_upper = string_upper(string_trim(token));
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Dispatching function → '" + token_upper + "'");

            switch (token_upper) {

                // ---- Random
                case "RND1": {
                    var n = safe_real_pop(stack);
                    if (n <= 0) n = 1;
                    var r1;
                    if (n == 1) {
                        // Classic BASIC: RND(1) returns 0.0 to 0.999...
                        r1 = random(1);
                    } else {
                        // Integer range: RND(6) returns 1-6
                        r1 = irandom(n - 1) + 1;
                    }
                    array_push(stack, r1);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RND1(" + string(n) + ") → " + string(r1));
                    break;
                }

                case "RND2": {
                    var max_val_raw = array_pop(stack);
                    var min_val_raw = array_pop(stack);
                    var min_val, max_val;

                    if (is_real(min_val_raw)) {
                        min_val = min_val_raw;
                    } else if (ds_map_exists(global.basic_variables, min_val_raw) && is_real(global.basic_variables[? min_val_raw])) {
                        min_val = global.basic_variables[? min_val_raw];
                    } else {
                        min_val = undefined;
                    }

                    if (is_real(max_val_raw)) {
                        max_val = max_val_raw;
                    } else if (ds_map_exists(global.basic_variables, max_val_raw) && is_real(global.basic_variables[? max_val_raw])) {
                        max_val = global.basic_variables[? max_val_raw];
                    } else {
                        max_val = undefined;
                    }

                    if (!is_real(min_val) || !is_real(max_val)) {
                        basic_system_message("ERROR: RND(min,max) requires numeric arguments — got '" 
                            + string(min_val_raw) + "', '" + string(max_val_raw) + "'");
                        array_push(stack, 0);
                    } else {
                        var result = irandom_range(min_val, max_val);
                        array_push(stack, result);
                        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RND2(" + string(min_val) + "," + string(max_val) + ") → " + string(result));
                    }
                    break;
                }

                // ---- NEW: Zero-arg time/keyboard functions ----
                case "TIMER": {
                    var secs = floor(current_time / 1000); // ms → seconds since game start
                    array_push(stack, secs);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: TIMER → " + string(secs));
                    break;
                }
                case "TIME$": {
                    var dt  = date_current_datetime();
                    var hh  = date_get_hour(dt);
                    var mm  = date_get_minute(dt);
                    var ss  = date_get_second(dt);
                    var hhs = (hh < 10 ? "0" : "") + string(hh);
                    var mms = (mm < 10 ? "0" : "") + string(mm);
                    var sss = (ss < 10 ? "0" : "") + string(ss);
                    var out = hhs + ":" + mms + ":" + sss;
                    array_push(stack, out);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: TIME$ → " + out);
                    break;
                }
                case "DATE$": {
                    var dt2 = date_current_datetime();
                    var yy  = date_get_year(dt2);
                    var mo  = date_get_month(dt2);
                    var dd  = date_get_day(dt2);
                    var mos = (mo < 10 ? "0" : "") + string(mo);
                    var dds = (dd < 10 ? "0" : "") + string(dd);
                    var out2 = string(yy) + "-" + mos + "-" + dds;
                    array_push(stack, out2);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: DATE$ → " + out2);
                    break;
                }

                case "INKEY$": {
                    if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: Processing INKEY$ token");

                    if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
                        if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: creating global.inkey_queue");
                        global.inkey_queue = ds_queue_create();
                    }

                    var _res = "";
                    if (ds_queue_size(global.inkey_queue) > 0) {
                        var _ch = ds_queue_dequeue(global.inkey_queue);
                        if (is_real(_ch)) _ch = chr(_ch);
                        _res = string(_ch);
                        if (dbg_on(DBG_PARSE)) show_debug_message(
                            "INKEY$ function: Dequeued '" + _res + "', queue size now = " + string(ds_queue_size(global.inkey_queue))
                        );
                    } else {
                        if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: Queue empty → returning empty string");
                    }

                    if (dbg_on(DBG_PARSE)) {
                        var _len = string_length(_res);
                        var _a1  = (_len >= 1) ? ord(string_char_at(_res, 1)) : -1;
                        var _a2  = (_len >= 2) ? ord(string_char_at(_res, 2)) : -1;
                        if (dbg_on(DBG_FLOW)) show_debug_message("##INK## LEN=" + string(_len)
                            + " A1=" + string(_a1)
                            + " A2=" + string(_a2)
                            + " K$='" + _res + "'");
                    }

                    array_push(stack, _res);
                    break;
                }

                // ---- Math
                case "ABS": array_push(stack, abs(safe_real_pop(stack))); break;
                case "EXP": array_push(stack, exp(safe_real_pop(stack))); break;

                // Preserving your prior semantics: LOG & LOG10 both as base-10
                case "LOG":
                case "LOG10": {
                    var v = safe_real_pop(stack);
                    array_push(stack, (ln(v) / ln(10)));
                    break;
                }

                case "SGN": {
                    var vsgn = safe_real_pop(stack);
                    var sgnv = (vsgn > 0) - (vsgn < 0);
                    array_push(stack, sgnv);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: SGN(" + string(vsgn) + ") → " + string(sgnv));
                    break;
                }

                case "INT": array_push(stack, floor(safe_real_pop(stack))); break;
                case "SIN": array_push(stack, sin(safe_real_pop(stack)));   break;
                case "COS": array_push(stack, cos(safe_real_pop(stack)));   break;
                case "TAN": array_push(stack, tan(safe_real_pop(stack)));   break;

                // ---- String conversions
                case "STR$": {
                    var vstr = safe_real_pop(stack);
                    var s = string(vstr);
                    array_push(stack, s);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: STR$ → " + s);
                    break;
                }
                case "CHR$": {
                    var cv = safe_real_pop(stack);
                    var c  = chr(cv);
                    array_push(stack, c);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: CHR$ → " + c);
                    break;
                }

                // ---- String functions we added
                case "REPEAT$": {
                    var nrep = floor(safe_real_pop(stack));
                    var srep = string(array_pop(stack));
                    if (nrep < 0) nrep = 0;

                    var max_out = 65535;
                    var unit = max(1, string_length(srep));
                    if (unit * nrep > max_out) nrep = floor(max_out / unit);

                    var outrep = "";
                    repeat (nrep) outrep += srep;
                    array_push(stack, outrep);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: REPEAT$('"+srep+"', "+string(nrep)+") → len="+string(string_length(outrep)));
                    break;
                }

                case "LEFT$": {
                    var nleft = floor(safe_real_pop(stack));
                    var sleft = string(array_pop(stack));
                    if (nleft < 0) nleft = 0;

                    var outleft = (nleft <= 0) ? "" : string_copy(sleft, 1, nleft);
                    array_push(stack, outleft);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: LEFT$('"+sleft+"', "+string(nleft)+") → '"+outleft+"'");
                    break;
                }

                case "RIGHT$": {
                    var nright = floor(safe_real_pop(stack));
                    var sright = string(array_pop(stack));
                    if (nright < 0) nright = 0;

                    var lenr = string_length(sright);
                    var start = max(1, lenr - nright + 1);
                    var outright = (nright <= 0) ? "" : string_copy(sright, start, nright);
                    array_push(stack, outright);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RIGHT$('"+sright+"', "+string(nright)+") → '"+outright+"'");
                    break;
                }

                case "MID$": {
                    var lmid = floor(safe_real_pop(stack));
                    var smid = floor(safe_real_pop(stack));
                    var strm = string(array_pop(stack));

                    if (lmid < 0) lmid = 0;
                    if (smid < 1) smid = 1;

                    var outm = "";
                    if (lmid > 0 && smid <= string_length(strm)) {
                        outm = string_copy(strm, smid, lmid);
                    }
                    array_push(stack, outm);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: MID$('"+strm+"', "+string(smid)+", "+string(lmid)+") → '"+outm+"'");
                    break;
                }

                case "ASC": {
                    var s = string(array_pop(stack));            // ensure string
                    var r = (string_length(s) >= 1) ? ord(string_char_at(s, 1)) : 0;
                    array_push(stack, r);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: ASC('" + s + "') → " + string(r));
                    break;
                }

                // ---- NEW: STRING$(x, n) ----
                case "STRING$": {
                    // Postfix order from infix handler: push x, push n, then STRING$
                    var n = array_pop(stack);
                    var _x = array_pop(stack);

                    // normalize n
                    var count = max(0, floor(is_real(n) ? n : real(n)));

                    // determine a single character from _x
                    var ch;
                    if (is_string(_x)) {
                        ch = (string_length(_x) > 0) ? string_copy(_x, 1, 1) : " ";
                    } else {
                        var code = clamp(floor(real(_x)), 0, 255);
                        ch = chr(code);
                    }

                    var out = "";
                    repeat (count) out += ch;

                    array_push(stack, out);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: STRING$(" + string(x) + "," + string(count) + ") → len=" + string(string_length(out)));
                    break;
                }

                default:
                    if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX WARNING: Unknown function = " + token_upper + " — pushing last real as fallback");
                    array_push(stack, safe_real_pop(stack));
                    break;
            }

            continue;
        }

        // -------------------------------------------------------
        // Scalar variable load (string vars keep "", numeric vars coerce)
        // -------------------------------------------------------
        if (ds_map_exists(global.basic_variables, token_upper)) {
            var vv = global.basic_variables[? token_upper];

            if (string_char_at(token_upper, string_length(token_upper)) == "$") {
                if (is_undefined(vv)) vv = "";
                if (!is_string(vv))  vv = string(vv);
            } else {
                if (is_string(vv)) {
                    vv = is_numeric_string(vv) ? real(vv) : 0;
                } else if (!is_real(vv)) {
                    vv = 0;
                }
            }

            array_push(stack, vv);
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Loaded variable " + token_upper + " = " + string(vv));
            continue;
        }

        // -------------------------------------------------------
        // Fallback: push as string literal (unknown token)
        // -------------------------------------------------------
        array_push(stack, trimmed);
        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed fallback string → " + trimmed);
    }

    return (array_length(stack) > 0) ? stack[array_length(stack) - 1] : 0;
}


================================================================================

/// @file scripts/get_full_line_text/get_full_line_text.gml

// ===============================================
// FILE: scripts/get_full_line_text/get_full_line_text.gml
// NEW: Helper function to get complete line text
// ===============================================

/// @function get_full_line_text(editor_inst, row)
function get_full_line_text(editor_inst, row) {
    with (editor_inst) {
        if (ds_map_exists(extended_lines, row)) {
            return extended_lines[? row];
        }
        return screen_editor_get_row_text(id, row);
    }
}

================================================================================

/// @file scripts/get_precedence/get_precedence.gml

function get_precedence(op) {
switch (op) {
    case "=": case "<>": case "<": case ">": case "<=": case ">=": return 0;
    case "+": case "-": return 1;
    case "*": case "/": case "\\" : case "%": case "MOD": return 2;
    case "^": return 3;
    default: return 0;
}

}


================================================================================

/// @file scripts/get_save_directory/get_save_directory.gml

/// scripts/get_save_directory/get_save_directory.gml
function get_save_directory()
{
   // Check for HTML5/browser first - return empty string to skip file operations
   if (os_browser != browser_not_a_browser) {
       return ""; // HTML5 - no file system access
   }
   
   var base = "";
   
   // Handle desktop OS types
   if (os_type == os_windows) {
       var user = environment_get_variable("USERPROFILE");
       if (is_string(user) && string_length(user) > 0) {
           base = user + "\\Documents\\BasicInterpreter\\";
       }
   }
   else if (os_type == os_macosx || os_type == os_linux) {
       var home = environment_get_variable("HOME");
       if (is_string(home) && string_length(home) > 0) {
           base = home + "/Documents/BasicInterpreter/";
       }
   }
   else if (os_type == os_android) {
       base = "/storage/emulated/0/Documents/BasicInterpreter/";
   }
   else {
       // Unknown desktop OS - fallback to working directory
       base = working_directory;
   }
   
   // If env var resolution failed, fall back to working_directory
   if (!is_string(base) || string_length(base) == 0) {
       base = working_directory;
   }
   
   // Ensure trailing slash
   var last = string_copy(base, string_length(base), 1);
   if (last != "/" && last != "\\") {
       if (os_type == os_windows) base += "\\";
       else base += "/";
   }
   
   return base;
}

================================================================================

/// @file scripts/gm_receive_paste/gm_receive_paste.gml

/// scripts/gm_receive_paste.gml
function gm_receive_paste(_text) {
    global.import_text  = is_string(_text) ? _text : "";
    global.import_ready = (global.import_text != "");
    show_error_message("Import received."); // visible confirmation
}


================================================================================

/// @file scripts/handle_basic_command/handle_basic_command.gml

/// @function handle_basic_command(cmd, arg)
/// @description Routes BASIC commands (and multiple colon-separated statements) to the correct functions
function handle_basic_command(cmd, arg) {
    // Rebuild the full statement (so we catch any colons in the original)
    var full = string_trim(cmd + (string_length(arg) ? " " + arg : ""));

    // Split on unquoted, top-level colons.
    var parts = split_on_unquoted_colons(full);

    // Dispatch each sub-statement in turn
    for (var i = 0; i < array_length(parts); i++) {
        var stmt = string_trim(parts[i]);
        if (stmt == "") continue;

        if (dbg_on(DBG_FLOW)) show_debug_message("DISPATCH PART: " + stmt);

        // Strip any trailing REM (apostrophe handled inside)
        stmt = strip_basic_remark(stmt);

        // Pull off the verb vs. the rest
        var sp = string_pos(" ", stmt);
        var _verb, _rest;
        if (sp > 0) {
            _verb = string_upper(string_copy(stmt, 1, sp - 1));
            _rest = string_trim(string_copy(stmt, sp + 1, string_length(stmt)));
        } else {
            _verb = string_upper(stmt);
            _rest = "";
        }

           // Skip INKEY$ as command (handled as function in evaluate_postfix)
           if (_verb == "INKEY$") {
               if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Ignored as command, treated as function");
               continue;
           }


// ---------- SYNTAX GUARD: INKEY$ misuse (quote-aware) ----------
{
    var _src  = stmt;                      // stmt already had remarks stripped
    var _len  = string_length(_src);
    var _up   = string_upper(_src);

    var inq = false;       // inside "..."
    var i   = 1;
    var found_inkey = false;
    var eq_pos = 0;        // first '=' found outside quotes

    while (i <= _len) {
        var ch = string_char_at(_src, i);

        // Handle quotes and escaped quotes
        if (ch == "\"") {
            // Check for escaped quote "" inside strings
            if (i < _len && string_char_at(_src, i + 1) == "\"") {
                i += 2;    // skip escaped quote pair
                continue;
            }
            inq = !inq;    // toggle quote state
            i++;
            continue;
        }

        // Only process characters outside quotes
        if (!inq) {
            if (eq_pos == 0 && ch == "=") eq_pos = i;

            // Detect INKEY$ outside quotes - fixed the boundary check
            if (i + 5 <= _len && string_copy(_up, i, 6) == "INKEY$") {
                found_inkey = true;
                break;
            }
        }

        i++;
    }

    if (found_inkey) {
        // Allow only: LET ... = INKEY$  or implicit  NAME = INKEY$
        var implicit_assign = false;
        if (eq_pos > 0) {
            var lhs = string_trim(string_copy(_src, 1, eq_pos - 1));
            if (string_length(lhs) > 0) {
                var h  = string_upper(string_char_at(lhs, 1));
                var oc = ord(h);
                if (oc >= 65 && oc <= 90) implicit_assign = true;  // starts with A..Z
            }
        }

        if (!(_verb == "LET" || implicit_assign)) {
            basic_syntax_error(
                "INKEY$ may only appear on the right side of an assignment like  K$ = INKEY$",
                global.current_line_number,
                global.interpreter_current_stmt_index,
                "INKEY_MISUSE"
            );
            return;
        }
    }
}
// ---------- END SYNTAX GUARD ----------







// Guard: IF must contain THEN in the same statement
if (_verb == "IF" && string_pos("THEN", string_upper(_rest)) <= 0) {
    basic_syntax_error(
        "IF requires THEN",
        /* line_no */ undefined, // let basic_syntax_error compute via basic_current_line_no()
        /* stmt_idx */ global.interpreter_current_stmt_index,
		"IF REQUIRES THEN"
    );
    return;
}


        // === INLINE IF COLLAPSE (also catches malformed inline IF without THEN) ===
        if (_verb == "IF") {
            // Reconstruct the original physical line from the dispatcher’s position
            var line_idx   = global.interpreter_current_line_index; // set by Step
            var line_no    = global.line_list[| line_idx];
            var src_line   = ds_map_find_value(global.program_map, line_no);
            var parts_full = split_on_unquoted_colons(string_trim(src_line));

            // Build the remainder of this physical line from the current colon slot
            var p         = global.interpreter_current_stmt_index;  // set by Step
            var remainder = parts_full[p];
            for (var t = p + 1; t < array_length(parts_full); t++) {
                remainder += ":" + parts_full[t];
            }

            // Text after the "IF" keyword
            var after_if = string_trim(string_copy(remainder, 3, max(0, string_length(remainder) - 2)));
            var up_after = string_upper(after_if);

var has_then           = (string_pos("THEN", up_after) > 0);
var has_colon_tail     = (string_pos(":", remainder) > 0);
var has_action_no_then = (!has_then && string_length(after_if) > 0);

// Check if there's content after THEN
var has_content_after_then = false;
if (has_then) {
    var then_pos = string_pos("THEN", up_after);
    var after_then = string_trim(string_copy(after_if, then_pos + 4, string_length(after_if)));
    has_content_after_then = (string_length(after_then) > 0);
}

// Decide: inline vs. structured block IF…ENDIF
if (has_content_after_then || has_colon_tail || has_action_no_then) {
                // Inline: feed the whole thing to the inline handler
                var arg_full = remainder;
                var up_rem   = string_upper(string_trim(remainder));
                if (string_copy(up_rem, 1, 2) == "IF") {
                    arg_full = string_trim(string_copy(remainder, 3, string_length(remainder) - 2));
                }

                if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH (collapsed IF): IF | ARG: " + arg_full);
                basic_cmd_if_inline(arg_full);

                // If the inline handler halted with an error, don't synthesize a jump
                if (global.program_has_ended || !global.interpreter_running) {
                    break; // stop dispatching; Step will show the error/end screen
                }

                // Otherwise, consume the rest of this physical line so Step won’t re-run it
                global.interpreter_use_stmt_jump = true;
                global.interpreter_target_line   = line_idx;
                global.interpreter_target_stmt   = array_length(parts_full); // end-of-line slot
                break;
            }
            // Else fall-through to the structured IF handler below.
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH: " + _verb + " | ARG: " + _rest);

        switch (_verb) {
            
			case "PRINT":     
		    if (global.current_mode >= 1) {
		        basic_cmd_print_mode1(_rest); 
		    } else {
		        basic_cmd_print(_rest, global.current_line_number); 
		    }
		    break;
			
            case "LET":       basic_cmd_let(_rest); break;
            case "GOTO":      basic_cmd_goto(_rest); break;
            case "INPUT":     basic_cmd_input(_rest); break;
            case "COLOR":     basic_cmd_color(_rest); break;
			
			case "CLS":       
			    if (global.current_mode >= 1) {
			        basic_cmd_cls_mode1();
			    } else {
			        basic_cmd_cls(); 
			    }
			    break;

            // Structured control flow (multi-line)
            case "IF":        basic_cmd_if(_rest); break;
            case "ELSEIF":    basic_cmd_elseif(_rest); break;
            case "ELSE":      basic_cmd_else(); break;
            case "ENDIF":     basic_cmd_endif(); break;

            case "FOR":       basic_cmd_for(_rest); break;
            case "NEXT":      basic_cmd_next(_rest); break;
            case "WHILE":     basic_cmd_while(_rest); break;
            case "WEND":      basic_cmd_wend(); break;

            case "GOSUB":     basic_cmd_gosub(_rest); break;
            case "RETURN":    basic_cmd_return(); break;

            case "BGCOLOR":   basic_cmd_bgcolor(_rest); break;
            case "PAUSE":     basic_cmd_pause(); break;
            case "MODE":      basic_cmd_mode(_rest); break;
            case "CLSCHAR":   basic_cmd_clschar(_rest); break;
            case "PSET":      basic_cmd_pset(_rest); break;
            case "CHARAT":    basic_cmd_charat(_rest); break;
            case "PRINTAT":   basic_cmd_printat(_rest); break;
            case "FONT":      basic_cmd_font(_rest); break;
            case "DIM":       basic_cmd_dim(_rest); break; // 1-D arrays

            case "END":       basic_cmd_end(); break;

            case "REM":
                // no-op
                break;

            case "DATA":
                // Runtime no-op (DATA was harvested at load time)
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA (runtime): no-op");
                break;

            case "READ":      basic_cmd_read(_rest); break;
            case "RESTORE":   basic_cmd_restore(_rest); break;

			case "LOCATE":    basic_cmd_locate(_rest); break;
			case "SCROLL":    basic_cmd_scroll(_rest); break;

			case "SCREEN":    // This will be handled as a function in expressions
			case "POINT":     // This will be handled as a function in expressions  
			case "POS":       // This will be handled as a function in expressions
			case "CSRLIN":    // This will be handled as a function in expressions
			case "TAB":       // This will be handled in PRINT processing
			case "SPC":       // This will be handled in PRINT processing
			    break;
			
			case "FONTSET":  basic_cmd_fontset(_rest); 
			break;

			default:
			    // implicit LET?  e.g.  "X = 5"
			    if (string_pos("=", _verb + " " + _rest) > 0) {
			        basic_cmd_let(_verb + " " + _rest);
			    } else {
			        basic_syntax_error("Unknown command: " + _verb, 
			            global.current_line_number,
			            global.interpreter_current_stmt_index,
			            "UNKNOWN_COMMAND");
			    }
			    break;
        }
    }
}


================================================================================

/// @file scripts/handle_character_input/handle_character_input.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 // Functions for input handling
 function handle_character_input() {
    var key_string = keyboard_string;
    
    // Robust keyboard handling with fallback
    if (key_string != last_keyboard_string) {
        var new_chars = string_copy(key_string, string_length(last_keyboard_string) + 1, 
                                   string_length(key_string) - string_length(last_keyboard_string));
        
        // Filter out control characters and validate input
        var filtered_chars = "";
        for (var i = 1; i <= string_length(new_chars); i++) {
            var char = string_char_at(new_chars, i);
            var char_code = ord(char);
            // Accept printable ASCII characters (32-126)
            if (char_code >= 32 && char_code <= 126) {
                filtered_chars += char;
            }
        }
        
        if (filtered_chars != "") {
            current_input = string_insert(filtered_chars, current_input, cursor_pos + 1);
            cursor_pos += string_length(filtered_chars);
        }
        
        last_keyboard_string = key_string;
    }
    
    // Fallback: Direct key detection for special cases
  //  if (keyboard_check_pressed(vk_space)) {
        // Ensure space is captured even if keyboard_string fails
  //      if (string_char_at(current_input, cursor_pos + 1) != " ") {
   //         current_input = string_insert(" ", current_input, cursor_pos + 1);
   //         cursor_pos++;
   //     }
   // }
 }


================================================================================

/// @file scripts/handle_command/handle_command.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function handle_command(command) {
//	show_debug_message("HANDLE_COMMAND called with: " + string(command) + " - paste_manager_exists: " + string(instance_exists(obj_paste_manager)));
   
var original_command = string_trim(command);
    command = string_upper(original_command);
    
    // Split command from parameters to preserve case in filenames
    var space_pos = string_pos(" ", command);
    var cmd_word = "";
    var cmd_params = "";
    
    if (space_pos > 0) {
        cmd_word = string_copy(command, 1, space_pos - 1);
        cmd_params = string_trim(string_copy(original_command, space_pos + 1, string_length(original_command)));
    } else {
        cmd_word = command;
    }
    
    switch (cmd_word) {
        case "LIST":
            if (cmd_params == "") {
                list_program();
            } else {
                list_program_range(cmd_params);
            }
            break;
            
        case "RUN":
            run_program();
            break;
            
        case "NEW":
            new_program();
            break;
            
        case "SAVE":
            if (os_browser != browser_not_a_browser) {
                // HTML build → use browser_file_tools download dialog
                if (cmd_params == "") {
                    editor_html_save_program();
                } else {
                    editor_html_save_program_as(cmd_params);
                }
            } else {
                // Desktop build → use file system save
                if (cmd_params == "") {
                    save_program();
                } else {
                    save_program_as(cmd_params);
                }
            }
            break;

case "CHECK_SAVE_FUNCS":
{
    var s = "browser_show_save_dialog";
    var r = "browser_show_save_dialog_raw";
   if (dbg_on(DBG_FLOW)) show_debug_message("[CHECK] wrapper exists=" + string(function_exists(s)));
   if (dbg_on(DBG_FLOW)) show_debug_message("[CHECK] raw exists=" + string(function_exists(r)));
    break;
}


            
        case "LOAD":
            if (cmd_params == "") {
                show_error_message("FILENAME REQUIRED");
            } else {
                load_program_from(cmd_params);
            }
            break;

		
case "DIR":
    if (os_browser != browser_not_a_browser) {
        var p = string_trim(cmd_params);
        var P = string_upper(p);
        if (P == "" || P == "PROMPT") {
            editor_html_dir_prompt();
        } else if (P == "SHOW") {
            editor_html_dir_show();
        } else if (string_copy(P, 1, 4) == "OPEN") {
            var arg = string_trim(string_delete(p, 1, 4)); // after "OPEN"
            if (string_length(arg) == 0) {
                show_message("Usage: DIR OPEN <index|filename>");
            } else {
                editor_html_dir_open(arg);
            }
        } else if (P != "") {  // Only try to open if there's actually a parameter
            // convenience: if they pass a number or name directly
            editor_html_dir_open(p);
        }
        // Remove the bare else clause that was causing the double call
    } else {
        // Windows: your original code path
        if (cmd_params == "") {
            list_saved_programs();
        } else {
            list_saved_programs(); // preserve your param behavior
        }
    }
    break;

case "HELP":
	help_launch();
	break

case ":PASTE":
{
    // Desktop build: native clipboard
    if (os_browser == browser_not_a_browser) {
        editor_handle_paste_command();
        break;
    }

		editor_html_handle_paste_command();

   if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Bound. Click the game, then press Ctrl/Cmd+V.");
}
break;





	    case ":LOADURL":
	        // Expect the rest of the input line to be the URL
	        // If your parser provides 'args', use that. Otherwise, adapt to your arg var.
	        import_from_url(string_trim(args));
	        break;
		
		

		case "QUIT":	
		case "Q":
		quit_program()
		break;

        case "SCREENEDIT":
        case "SE":
            start_screen_editor();
            break;


			
        default:
            show_error_message("SYNTAX ERROR");
            break;
    }
 }

================================================================================

/// @file scripts/handle_inkey_input/handle_inkey_input.gml

// === 2A. Create this as a separate script file (handle_inkey_input.gml) ===
/// @function handle_inkey_input()
/// @description Handle INKEY$ input during pause
function handle_inkey_input() {
    // Only process if we're in INKEY$ mode
    if (!global.inkey_mode) return false;
    
    // Scan for any printable key press
    for (var key = 32; key <= 126; key++) { // printable ASCII range
        if (keyboard_check_pressed(key)) {
            var ch = chr(key);
            
            // Store the result
            global.basic_variables[? "__INKEY_RESULT"] = ch;
            
            // Resume program execution
            global.pause_in_effect = false;
            global.awaiting_input = false;
            global.input_target_var = "";
            global.pause_mode = false;
            global.input_expected = false;
            global.inkey_mode = false;
            
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Got keypress '" + ch + "' (code " + string(key) + "), resuming program");
            return true; // Input was handled
        }
    }
    
    // Handle special keys if needed
    if (keyboard_check_pressed(vk_enter)) {
        global.basic_variables[? "__INKEY_RESULT"] = chr(13);
        // Resume execution (same cleanup as above)
        global.pause_in_effect = false;
        global.awaiting_input = false;
        global.input_target_var = "";
        global.pause_mode = false;
        global.input_expected = false;
        global.inkey_mode = false;
        
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Got ENTER, resuming program");
        return true;
    }
    
    return false; // No input yet, keep waiting
}

================================================================================

/// @file scripts/handle_interpreter_character_input/handle_interpreter_character_input.gml

/// handle_interpreter_character_input(key)
/// Processes editor keystrokes while awaiting BASIC INPUT.
/// Assumes helpers basic_normvar(name) and basic_looks_numeric(s) exist,
/// and global.basic_variables (ds_map) is initialized.
function handle_interpreter_character_input(key) {
    // --- PRINTABLE ASCII (uses keyboard_lastchar) ---
    if (key >= 32 && key <= 126) {
        var ch = string(keyboard_lastchar); // ensure string
        if (string_length(ch) > 0) {
            global.interpreter_input = string_insert(ch, global.interpreter_input, global.interpreter_cursor_pos + 1);
            global.interpreter_cursor_pos += 1;
        }
        return;
    }

    // --- BACKSPACE ---
    if (key == vk_backspace) {
        if (global.interpreter_cursor_pos > 0) {
            // Delete the character just to the left of the cursor
            global.interpreter_input = string_delete(global.interpreter_input, global.interpreter_cursor_pos, 1);
            global.interpreter_cursor_pos -= 1;
        }
        return;
    }

    // --- SPACE ---
    if (key == vk_space) {
        global.interpreter_input = string_insert(" ", global.interpreter_input, global.interpreter_cursor_pos + 1);
        global.interpreter_cursor_pos += 1;
        return;
    }

    // --- LEFT ARROW ---
    if (key == vk_left) {
        if (global.interpreter_cursor_pos > 0) {
            global.interpreter_cursor_pos -= 1;
        }
        return;
    }

    // --- RIGHT ARROW ---
    if (key == vk_right) {
        if (global.interpreter_cursor_pos < string_length(global.interpreter_input)) {
            global.interpreter_cursor_pos += 1;
        }
        return;
    }

    // --- ENTER: finalize INPUT and resume execution ---
    if (key == vk_enter) {
        var raw = string_trim(string(global.interpreter_input));
        var k   = basic_normvar(global.input_target_var);

        // String var if the normalized name ends with '$'
        var ends_with_dollar = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");

        var val;
        if (ends_with_dollar) {
            // String variable: commit exactly what the user typed
            val = raw;
        } else {
            // Numeric variable: only accept numeric-looking input (prevents silent 0 bugs)
            if (basic_looks_numeric(raw)) {
                val = real(raw);
            } else {
                // Stay in input mode; do not commit or advance
                if (!is_undefined(global.DEBUG_INPUT) && global.DEBUG_INPUT) {
                    show_debug_message("[INPUT] Type mismatch for " + k + " got '" + raw + "'. Still waiting.");
                }
                return;
            }
        }

        // Store under canonical key
        global.basic_variables[? k] = val;

        if (!is_undefined(global.DEBUG_INPUT) && global.DEBUG_INPUT) {
            show_debug_message("[INPUT] commit " + k + " <= '" + string(val) + "'");
        }

        // --- Post-commit housekeeping (keep these consistent with your existing flow) ---
        // Clear the input buffer and cursor
        global.interpreter_input      = "";
        global.interpreter_cursor_pos = 0;

        // Clear input mode flags/targets
        global.awaiting_input   = false;
        global.input_target_var = "";

        // If you echo the entered line to your output, do it here (optional):
        // ds_list_add(global.output_lines, string(val));
        // ds_list_add(global.output_colors, global.current_draw_color);

        return;
    }

    // (Optional) HOME / END support
    // if (key == vk_home) { global.interpreter_cursor_pos = 0; return; }
    // if (key == vk_end)  { global.interpreter_cursor_pos = string_length(global.interpreter_input); return; }
}


================================================================================

/// @file scripts/handle_program_line/handle_program_line.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function handle_program_line(input_text) {
    var space_pos = string_pos(" ", input_text);
    var line_num = real(string_copy(input_text, 1, space_pos - 1));
    var code_content = string_copy(input_text, space_pos + 1, string_length(input_text));
    
    // If no code content, delete the line
    if (string_trim(code_content) == "") {
        delete_program_line(line_num);
    } else {
        add_or_update_program_line(line_num, code_content);
    }
    
    update_display();
 }

================================================================================

/// @file scripts/help_build_program/help_build_program.gml

/// help_build_program() - CORRECTED VERSION
function help_build_program() {
    // clear current program and line numbers
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // Work out how many topics we're going to list
    var topic_count = ds_list_size(global.help_topics);

    // Seed the runtime variable store
    if (!is_undefined(global.basic_variables)) {
        global.basic_variables[? "TOPIC_COUNT"] = topic_count;
    }

    var add = function(n, s) {
        ds_map_add(global.program_lines, n, s);
        ds_list_add(global.line_numbers, n);
    };

    // ==== BASIC "HELP BROWSER" PROGRAM ====
add(10,"REM NW-BASIC HELP SYSTEM - Clean Version (ASCII-safe)");
add(15,"HDR$ = \"\"             : REM avoid undefined var on first header call");
add(20,"CLS: COLOR YELLOW: HDR$=\"NW-BASIC HELP\": GOSUB 7000");
add(30,"PRINT \"Select a topic by number. 0 returns to editor.\"");
add(35,"REM -- Arrays must exist BEFORE we READ into them");
add(36,"DIM TOPIC$(32), TOPIC_START(32), TOPIC_LEN(32)");
add(37,"DIM SUB$(128), SUBTOPIC_OF(128), SUB_START(128), SUB_LEN(128)");
add(38,"DIM IDX(32)");
add(40,"GOSUB 9500   : REM Load data");
add(50,"REM --- MAIN MENU LOOP ---");
add(60,"CLS: HDR$=\"TOPICS - Select a topic (0=Exit)\": GOSUB 7000");
add(65,"PRINT");
add(70,"FOR I=1 TO TOPIC_COUNT: PRINT I; \") \"; TOPIC$(I): NEXT");
add(80,"PRINT");
add(90,"INPUT \"Topic (0=Exit): \", T");
add(100,"IF T=0 THEN END");
add(110,"IF T<1 OR T>TOPIC_COUNT THEN PRINT \"Invalid.\": GOTO 80");
add(120,"REM --- SUBTOPIC MENU LOOP ---");
add(130,"CLS: HDR$=\"TOPIC: \" + TOPIC$(T) + \"  (0=Back)\": GOSUB 7000");
add(140,"C=0");
add(150,"FOR I=1 TO SUB_COUNT");
add(160,"  IF SUBTOPIC_OF(I)=T THEN C=C+1: PRINT C; \") \"; SUB$(I): IDX(C)=I");
add(170,"NEXT");
add(180,"IF C=0 THEN PRINT \"(No subtopics)\": INPUT \"[ENTER]\", X$: GOTO 50");
add(190,"PRINT");
add(200,"INPUT \"Subtopic (0=Back): \",K");
add(210,"IF K=0 THEN GOTO 50");
add(220,"IF K<1 OR K>C THEN GOTO 190");
add(230,"REM --- SHOW CONTENT ---");
add(240,"I = IDX(K): S = SUB_START(I): N = SUB_LEN(I)");
add(250,"GOSUB 8000");
add(260,"GOTO 120");
add(6999,"REM ---- helpers ----");
add(7000,"REM Print a decorated header (no LEN, no REPEAT$)");
add(7005,"D$=\"\": FOR J=1 TO 40: D$=D$ + \"-\": NEXT");
add(7010,"PRINT D$");
add(7015,"IF HDR$ <> \"\" THEN PRINT HDR$");
add(7020,"PRINT D$");
add(7030,"RETURN");
add(8000,"REM --- CONTENT DISPLAY: seek once to first page, then stream N pages ---");
add(8010,"REM We want pages S..S+N-1. Land on page S once, then read forward.");
add(8030,"RESTORE");
add(8040,"READ TC, SC, PC");
add(8050,"FOR SKT = 1 TO TC: READ TMP$, TMP1, TMP2: NEXT SKT");
add(8060,"FOR SKS = 1 TO SC: READ TMP2$, TMP3, TMP4, TMP5: NEXT SKS");
add(8080,"FOR SK = 1 TO S - 1");
add(8090,"  READ L: FOR R = 1 TO L: READ D$: NEXT R");
add(8100,"NEXT SK");
add(8120,"FOR PP = 1 TO N");
add(8130,"  CLS");
add(8140,"  PRINT \"HELP: \"; SUB$(I)");
add(8150,"  HDR$ = \"TOPIC: \" + TOPIC$( SUBTOPIC_OF(I) ) + \"  (0=Back)\": GOSUB 7000");
add(8160,"  PRINT \"Page \"; PP; \" of \"; N");
add(8170,"  PRINT");
add(8180,"  READ L");
add(8190,"  FOR R = 1 TO L");
add(8200,"    READ D$: PRINT D$");
add(8210,"  NEXT R");
add(8220,"  PRINT");
add(8230,"  INPUT \"[ENTER=Next/Back]\", X$");
add(8240,"NEXT PP");
add(8250,"RETURN");
add(9500,"REM -- Load all data --");
add(9510,"RESTORE");
add(9520,"READ TOPIC_COUNT, SUB_COUNT, PAGE_COUNT");
add(9530,"FOR I=1 TO TOPIC_COUNT: READ TOPIC$(I), TOPIC_START(I), TOPIC_LEN(I): NEXT");
add(9550,"FOR I=1 TO SUB_COUNT: READ SUB$(I), SUBTOPIC_OF(I), SUB_START(I), SUB_LEN(I): NEXT");
add(9560,"RETURN");
add(9900,"DATA 9, 27, 38");
add(9910,"REM Topic data: name, start_page, length");
add(9920,"DATA \"Program Structure\", 1, 2");
add(9921,"DATA \"Variables & Data Types\", 3, 3");
add(9922,"DATA \"Input/Output\", 6, 4");
add(9923,"DATA \"Program Control\", 10, 5");
add(9924,"DATA \"MODE / Graphics\", 15, 5");
add(9925,"DATA \"Math & Random\", 20, 4");
add(9926,"DATA \"Strings\", 24, 3");
add(9927,"DATA \"Data & Arrays\", 27, 5");
add(9928,"DATA \"Editor & Files\", 32, 7");
add(9930,"REM Subtopic data: name, parent_topic, start_page, length");
add(9931,"DATA \"Line Numbers\", 1, 1, 1");
add(9932,"DATA \"Multiple Statements\", 1, 2, 1");
add(9933,"DATA \"LET & Types\", 2, 3, 1");
add(9934,"DATA \"Arrays (DIM)\", 2, 4, 2");
add(9935,"DATA \"PRINT\", 3, 6, 2");
add(9936,"DATA \"INPUT\", 3, 8, 1");
add(9937,"DATA \"CLS/Color\", 3, 9, 1");
add(9938,"DATA \"IF / ELSE / ENDIF\", 4, 10, 2");
add(9939,"DATA \"FOR/NEXT\", 4, 12, 1");
add(9940,"DATA \"WHILE/WEND\", 4, 13, 1");
add(9941,"DATA \"GOTO/GOSUB/RETURN\", 4, 14, 1");
add(9942,"DATA \"MODE 1 & Fonts\", 5, 15, 2");
add(9943,"DATA \"PRINTAT/CHARAT\", 5, 17, 2");
add(9944,"DATA \"CLSCHAR/SCROLL\", 5, 19, 1");
add(9945,"DATA \"Math & Trig\", 6, 20, 2");
add(9946,"DATA \"RND\", 6, 22, 1");
add(9947,"DATA \"Operators\", 6, 23, 1");
add(9948,"DATA \"Substring & Len\", 7, 24, 1");
add(9949,"DATA \"CHR$/ASC\", 7, 25, 1");
add(9950,"DATA \"Concatenation\", 7, 26, 1");
add(9951,"DATA \"DATA/READ/RESTORE\", 8, 27, 2");
add(9952,"DATA \"Named Streams\", 8, 29, 1");
add(9953,"DATA \"Arrays\", 8, 30, 2");
add(9954,"DATA \"Editor Commands\", 9, 32, 3");
add(9955,"DATA \"DIR Overlay\", 9, 35, 1");
add(9956,"DATA \"SAVE/LOAD\", 9, 36, 1");
add(9957,"DATA \"Shortcuts\", 9, 37, 2");
add(10000,"REM === Page 1: Program Structure / Line Numbers ===");
add(10010,"DATA 9");
add(10011,"DATA \"PROGRAM STRUCTURE\"");
add(10012,"DATA \"What: Programs are a list of numbered lines.\"");
add(10013,"DATA \"Syntax: 10 STATEMENT  : 20 STATEMENT\"");
add(10014,"DATA \"Type: 10 PRINT \"\"Hello\"\"  : 20 END\"");
add(10015,"DATA \"Gotchas: Use gaps 10,20,30 so you can insert.\"");
add(10016,"DATA \"Gotchas: A repeated number overwrites that line.\"");
add(10017,"DATA \"See also: Multiple Statements, GOTO, GOSUB\"");
add(10018,"DATA \"SCREENEDIT or SE = full screen editor\"");
add(10019,"DATA \"Use REM or ' to start a comment to end of line\"");
add(10020,"REM === Page 2: Program Structure / Multiple Statements ===");
add(10030,"DATA 7");
add(10031,"DATA \"PROGRAM STRUCTURE\"");
add(10032,"DATA \"What: Put several statements on one line.\"");
add(10033,"DATA \"Syntax: STAT : STAT : STAT\"");
add(10034,"DATA \"Type: 10 A=1: B=2: PRINT A+B\"");
add(10035,"DATA \"Gotchas: Keep lines short for readability.\"");
add(10036,"DATA \"See also: LET & Types, IF, FOR/NEXT\"");
add(10037,"DATA \"\"");
add(10040,"REM === Page 3: Variables & Data Types / LET & Types ===");
add(10050,"DATA 9");
add(10051,"DATA \"VARIABLES & TYPES\"");
add(10052,"DATA \"What: Store numbers or text in named variables.\"");
add(10053,"DATA \"Syntax: A=5  or  LET A=5  ;  N$=\"\"Name\"\"\"");
add(10054,"DATA \"Type: A=3: B=4: PRINT A+B   :  N$=\"\"Joe\"\"\"");
add(10055,"DATA \"Type: PRINT \"\"Hello, \"\" + N$\"");
add(10056,"DATA \"Gotchas: Names ending in $ are strings only.\"");
add(10057,"DATA \"Gotchas: Others are numeric; default is 0.\"");
add(10058,"DATA \"See also: Strings, PRINT\"");
add(10059,"DATA \"\"");
add(10060,"REM === Page 4: Variables & Data Types / Arrays (DIM) p1 ===");
add(10070,"DATA 9");
add(10071,"DATA \"ARRAYS (DIM) - Part 1\"");
add(10072,"DATA \"What: Store many values under one name.\"");
add(10073,"DATA \"Syntax: DIM A(10)  ;  DIM N$(5)\"");
add(10074,"DATA \"Type: DIM A(3): A(1)=10: A(2)=20: PRINT A(1)+A(2)\"");
add(10075,"DATA \"Type: DIM N$(2): N$(1)=\"\"OK\"\": PRINT N$(1)\"");
add(10076,"DATA \"Gotchas: Indexing is 1-based in this build.\"");
add(10077,"DATA \"Gotchas: Out of range gives 0 or empty string.\"");
add(10078,"DATA \"See also: Arrays p2, Data & Arrays\"");
add(10079,"DATA \"\"");
add(10080,"REM === Page 5: Variables & Data Types / Arrays (DIM) p2 ===");
add(10090,"DATA 8");
add(10091,"DATA \"ARRAYS (DIM) - Part 2\"");
add(10092,"DATA \"What: Use expressions for the index.\"");
add(10093,"DATA \"Type: I=3: DIM A(5): A(I-1)=7: PRINT A(2)\"");
add(10094,"DATA \"Type: DIM N$(3): N$(1)=\"\"A\"\": PRINT N$(1)\"");
add(10095,"DATA \"Gotchas: Arrays and scalars are distinct names.\"");
add(10096,"DATA \"Gotchas: Re-DIM by defining before use.\"");
add(10097,"DATA \"See also: Substring & LEN, Data & Arrays\"");
add(10098,"DATA \"\"");
add(10100,"REM === Page 6: Input/Output / PRINT p1 ===");
add(10110,"DATA 9");
add(10111,"DATA \"PRINT - Part 1\"");
add(10112,"DATA \"What: Show text or values on the screen.\"");
add(10113,"DATA \"Syntax: PRINT expr   ;   PRINT A;B   ;   PRINT A,B\"");
add(10114,"DATA \"Type: PRINT \"\"Hello\"\"   :   PRINT 1,2,3\"");
add(10115,"DATA \"Type: A=3: B=4: PRINT \"\"Sum=\"\";A+B\"");
add(10116,"DATA \"Output: 1       2       3\"");
add(10117,"DATA \"Gotchas: A trailing ; keeps the cursor on the line.\"");
add(10118,"DATA \"See also: PRINT p2, INPUT\"");
add(10119,"DATA \"\"");
add(10120,"REM === Page 7: Input/Output / PRINT p2 ===");
add(10130,"DATA 8");
add(10131,"DATA \"PRINT - Part 2\"");
add(10132,"DATA \"What: Format with strings for labels.\"");
add(10133,"DATA \"Type: PRINT \"\"A=\"\"+STR$(5)\"");
add(10134,"DATA \"Type: PRINT \"\"First\"\";: PRINT \"\" line\"\"\"");
add(10135,"DATA \"Gotchas: , uses tab columns; ; no spacing.\"");
add(10136,"DATA \"Gotchas: Use CHR$(13)+CHR$(10) for custom breaks.\"");
add(10137,"DATA \"See also: Strings, CHR$/ASC\"");
add(10138,"DATA \"\"");
add(10140,"REM === Page 8: Input/Output / INPUT ===");
add(10150,"DATA 8");
add(10151,"DATA \"INPUT\"");
add(10152,"DATA \"What: Ask the user for a number or text.\"");
add(10153,"DATA \"Syntax: INPUT \"\"Prompt: \"\", X   or   INPUT \"\"Name: \"\", N$\"");
add(10154,"DATA \"Type: INPUT \"\"Name: \"\", N$: PRINT \"\"Hello, \"\";N$\"");
add(10155,"DATA \"INKEY$ returns one key from the queue; \"\"\"\" if none\"");
add(10156,"DATA \"Gotchas: Use $ names for text; others are numeric.\"");
add(10157,"DATA \"Gotchas: Entering nothing keeps current value.\"");
add(10158,"DATA \"See also: PRINT, IF, Shortcuts\"");
add(10160,"REM === Page 9: Input/Output / CLS & Color ===");
add(10170,"DATA 8");
add(10171,"DATA \"CLS & COLOR\"");
add(10172,"DATA \"What: Clear the screen and set text color.\"");
add(10173,"DATA \"Syntax: CLS    ;   COLOR YELLOW\"");
add(10174,"DATA \"Type: CLS: COLOR YELLOW: PRINT \"\"Ready\"\"\"");
add(10175,"DATA \"Gotchas: Use a small set of named colors.\"");
add(10176,"DATA \"Gotchas: Clear before drawing a new view.\"");
add(10177,"DATA \"See also: MODE 1, PRINTAT\"");
add(10178,"DATA \"\"");
add(10180,"REM === Page 10: Program Control / IF-ELSE-ENDIF p1 ===");
add(10190,"DATA 9");
add(10191,"DATA \"IF / ELSE / ENDIF - Part 1\"");
add(10192,"DATA \"What: Run code only when a test is true.\"");
add(10193,"DATA \"Syntax:\"");
add(10194,"DATA \"IF A>0 THEN\"");
add(10195,"DATA \"  PRINT \"\"POSITIVE\"\"\"");
add(10196,"DATA \"ELSE\"");
add(10197,"DATA \"  PRINT \"\"NON-POSITIVE\"\"\"");
add(10198,"DATA \"ENDIF\"");
add(10199,"DATA \"\"");
add(10200,"REM === Page 11: Program Control / IF-ELSE-ENDIF p2 ===");
add(10210,"DATA 7");
add(10211,"DATA \"IF / ELSE / ENDIF - Part 2\"");
add(10212,"DATA \"What: Single-line IF for short actions.\"");
add(10213,"DATA \"Type: IF A=0 THEN PRINT \"\"ZERO\"\"\"");
add(10214,"DATA \"Gotchas: Use parentheses to group tests.\"");
add(10215,"DATA \"Gotchas: Strings compare with = and <>.\"");
add(10216,"DATA \"See also: FOR/NEXT, WHILE/WEND\"");
add(10217,"DATA \"\"");
add(10220,"REM === Page 12: Program Control / FOR-NEXT ===");
add(10230,"DATA 8");
add(10231,"DATA \"FOR / NEXT\"");
add(10232,"DATA \"What: Repeat a block a set number of times.\"");
add(10233,"DATA \"Syntax: FOR I=start TO end [STEP s] ... NEXT\"");
add(10234,"DATA \"Type: FOR I=1 TO 5: PRINT I: NEXT\"");
add(10235,"DATA \"Type: FOR T=10 TO 0 STEP -2: PRINT T: NEXT\"");
add(10236,"DATA \"Gotchas: Do not change I inside the loop.\"");
add(10237,"DATA \"See also: WHILE/WEND, IF\"");
add(10238,"DATA \"\"");
add(10240,"REM === Page 13: Program Control / WHILE-WEND ===");
add(10250,"DATA 6");
add(10251,"DATA \"WHILE / WEND\"");
add(10252,"DATA \"What: Repeat while a condition is true.\"");
add(10253,"DATA \"Syntax: WHILE cond: ... : WEND\"");
add(10254,"DATA \"Type: A=3: WHILE A>0: PRINT A: A=A-1: WEND\"");
add(10255,"DATA \"Gotchas: Ensure progress to avoid an infinite loop.\"");
add(10256,"DATA \"\"");
add(10260,"REM === Page 14: Program Control / GOTO-GOSUB-RETURN ===");
add(10270,"DATA 8");
add(10271,"DATA \"GOTO / GOSUB / RETURN\"");
add(10272,"DATA \"What: Jump or call a subroutine by line number.\"");
add(10273,"DATA \"Type: 100 GOSUB 900 : PRINT \"\"Back\"\" : END\"");
add(10274,"DATA \"Type: 900 PRINT \"\"Hi\"\": RETURN\"");
add(10275,"DATA \"Gotchas: RETURN goes to the line after GOSUB.\"");
add(10276,"DATA \"Gotchas: Use small helpers; avoid deep nesting.\"");
add(10277,"DATA \"See also: Line Numbers, IF\"");
add(10278,"DATA \"\"");
add(10280,"REM === Page 15: MODE / Graphics / MODE1 & Fonts p1 ===");
add(10290,"DATA 8");
add(10291,"DATA \"MODE 1 & FONTS - Part 1\"");
add(10292,"DATA \"What: Character grid display with sprite fonts.\"");
add(10293,"DATA \"Syntax: FONT \"\"DEFAULT_16\"\"\"");
add(10294,"DATA \"Type: FONT \"\"DEFAULT_16\"\": PRINT \"\"Hello\"\"\"");
add(10295,"DATA \"Gotchas: Tile size sets columns and rows.\"");
add(10296,"DATA \"Gotchas: Keep a consistent font for readability.\"");
add(10297,"DATA \"See also: PRINTAT/CHARAT\"");
add(10298,"DATA \"\"");
add(10300,"REM === Page 16: MODE / Graphics / MODE1 & Fonts p2 ===");
add(10310,"DATA 7");
add(10311,"DATA \"MODE 1 & FONTS - Part 2\"");
add(10312,"DATA \"What: Pick a tile size for your layout.\"");
add(10313,"DATA \"Guide: 16x16 is readable; 8x8 fits more text.\"");
add(10314,"DATA \"Tip: Test on your target window size.\"");
add(10315,"DATA \"Tip: Use headers and spacing to reduce clutter.\"");
add(10316,"DATA \"See also: PRINTAT/CHARAT, CLSCHAR/SCROLL\"");
add(10317,"DATA \"\"");
add(10320,"REM === Page 17: MODE / Graphics / PRINTAT-CHARAT p1 ===");
add(10330,"DATA 8");
add(10331,"DATA \"PRINTAT / CHARAT - Part 1\"");
add(10332,"DATA \"What: Draw at a grid position.\"");
add(10333,"DATA \"Syntax: PRINTAT x,y,\"\"Text\"\"\"");
add(10334,"DATA \"Syntax: CHARAT x,y,code[,fg[,bg]]\"");
add(10335,"DATA \"Type: PRINTAT 1,1,\"\"TOP\"\"\"");
add(10336,"DATA \"Type: CHARAT 10,5,45  ' draw '-'\"");
add(10337,"DATA \"See also: MODE 1, CLSCHAR/SCROLL\"");
add(10338,"DATA \"\"");
add(10340,"REM === Page 18: MODE / Graphics / PRINTAT-CHARAT p2 ===");
add(10350,"DATA 7");
add(10351,"DATA \"PRINTAT / CHARAT - Part 2\"");
add(10352,"DATA \"Tip: To center: start=(cols-LEN)/2 (manual).\"");
add(10353,"DATA \"Tip: Redraw only the parts that change.\"");
add(10354,"DATA \"Tip: Keep a cursor state if you blink text.\"");
add(10355,"DATA \"Tip: Use constants for colors and codes.\"");
add(10356,"DATA \"See also: MODE 1, DIR Overlay\"");
add(10357,"DATA \"\"");
add(10360,"REM === Page 19: MODE / Graphics / CLSCHAR-SCROLL ===");
add(10370,"DATA 7");
add(10371,"DATA \"CLSCHAR / SCROLL\"");
add(10372,"DATA \"What: Fill the screen or move text rows.\"");
add(10373,"DATA \"Syntax: CLSCHAR code[,fg[,bg]]\"");
add(10374,"DATA \"Syntax: SCROLL dir[,rows]\"");
add(10375,"DATA \"Tip: Use SCROLL for pager effects.\"");
add(10376,"DATA \"See also: PRINTAT, Page Reader\"");
add(10377,"DATA \"\"");
add(10380,"REM === Page 20: Math & Random / Math & Trig p1 ===");
add(10390,"DATA 8");
add(10391,"DATA \"MATH & TRIG - Part 1\"");
add(10392,"DATA \"What: Common numeric functions.\"");
add(10393,"DATA \"Funcs: ABS, INT, SGN, EXP, LOG\"");
add(10394,"DATA \"Funcs: SIN, COS, TAN   (radians)\"");
add(10395,"DATA \"Type: PRINT ABS(-3), INT(3.9)\"");
add(10396,"DATA \"Tip: Use parentheses for clarity.\"");
add(10397,"DATA \"See also: Operators, RND\"");
add(10398,"DATA \"\"");
add(10400,"REM === Page 21: Math & Random / Math & Trig p2 ===");
add(10410,"DATA 7");
add(10411,"DATA \"MATH & TRIG - Part 2\"");
add(10412,"DATA \"What: More math helpers and tips.\"");
add(10413,"DATA \"Type: PRINT SGN(-5), EXP(1)\"");
add(10414,"DATA \"Tip: Compare floats with a small tolerance.\"");
add(10415,"DATA \"Tip: Use MOD for wrap-around indices.\"");
add(10416,"DATA \"See also: RND, Operators\"");
add(10417,"DATA \"\"");
add(10420,"REM === Page 22: Math & Random / RND ===");
add(10430,"DATA 7");
add(10431,"DATA \"RND\"");
add(10432,"DATA \"What: Random number generator.\"");
add(10433,"DATA \"Type: PRINT RND()         ' 0.0..1.0\"");
add(10434,"DATA \"Type: PRINT RND(6)       ' 1..6\"");
add(10435,"DATA \"Type: PRINT RND(2,5)     ' 2..5\"");
add(10436,"DATA \"See also: Math & Trig, Operators\"");
add(10437,"DATA \"\"");
add(10440,"REM === Page 23: Math & Random / Operators ===");
add(10450,"DATA 7");
add(10451,"DATA \"OPERATORS\"");
add(10452,"DATA \"What: + - * /  \\  MOD  ^  and comparisons.\"");
add(10453,"DATA \"Type: PRINT 3+4*2, 7 MOD 5, 5^2\"");
add(10454,"DATA \"Tip: '\\' is integer divide; trunc toward zero.\"");
add(10455,"DATA \"Tip: Use parentheses to control order.\"");
add(10456,"DATA \"See also: Math & Trig\"");
add(10457,"DATA \"\"");
add(10460,"REM === Page 24: Strings / Substring & LEN ===");
add(10470,"DATA 8");
add(10471,"DATA \"STRINGS - Substrings\"");
add(10472,"DATA \"What: Slice parts of a string.\"");
add(10473,"DATA \"Syntax: LEFT$(S$,N), RIGHT$(S$,N), MID$(S$,s,l)\"");
add(10474,"DATA \"Type: S$=\"\"HELLO\"\": PRINT LEFT$(S$,2)   ' HE\"");
add(10475,"DATA \"Type: PRINT MID$(S$,2,3)               ' ELL\"");
add(10476,"DATA \"Note: LEN is not provided in this build.\"");
add(10477,"DATA \"See also: CHR$/ASC, Concatenation, REPEAT$\"");
add(10478,"DATA \"\"");
add(10480,"REM === Page 25: Strings / CHR$ & ASC ===");
add(10490,"DATA 7");
add(10491,"DATA \"STRINGS - CHR$ & ASC\"");
add(10492,"DATA \"What: Convert between codes and characters.\"");
add(10493,"DATA \"Type: PRINT CHR$(65)      ' A\"");
add(10494,"DATA \"Type: PRINT ASC(\"\"A\"\")     ' 65\"");
add(10495,"DATA \"Tip: Useful for line chars or input parsing.\"");
add(10496,"DATA \"See also: Substrings, Concatenation\"");
add(10497,"DATA \"\"");
add(10500,"REM === Page 26: Strings / Concatenation ===");
add(10510,"DATA 8");
add(10511,"DATA \"STRINGS - Concatenation, semicolon or +\"");
add(10512,"DATA \"What: Join strings with +.\"");
add(10513,"DATA \"Type: NAME$=\"\"Ada\"\": PRINT \"\"Hi, \"\"+NAME$\"");
add(10514,"DATA \"Type: PRINT \"\"A=\"\" + STR$(3)\"");
add(10515,"DATA \"Type: PRINT REPEAT$(\"\"-\"\",5) ' -----\"");
add(10516,"DATA \"Semicolon = no line feed after string\"");
add(10517,"DATA \"Tip: Build long lines piece by piece.\"");
add(10518,"DATA \"See also: PRINT, Substrings, REPEAT$\"");
add(10520,"REM === Page 27: Data & Arrays / DATA-READ-RESTORE p1 ===");
add(10530,"DATA 8");
add(10531,"DATA \"DATA / READ / RESTORE - Part 1\"");
add(10532,"DATA \"What: Store constants in the code and read them.\"");
add(10533,"DATA \"Syntax: DATA ...  ;  READ A,B$  ;  RESTORE\"");
add(10534,"DATA \"Type: RESTORE: READ N$,X: PRINT N$,X\"");
add(10535,"DATA \"Type: DATA \"\"OK\"\", 42\"");
add(10536,"DATA \"Tip: Keep tables grouped at the end.\"");
add(10537,"DATA \"See also: Named Streams, Arrays\"");
add(10538,"DATA \"\"");
add(10540,"REM === Page 28: Data & Arrays / DATA-READ-RESTORE p2 ===");
add(10550,"DATA 8");
add(10551,"DATA \"DATA / READ / RESTORE - Part 2\"");
add(10552,"DATA \"What: Seek by rewinding then skipping blocks.\"");
add(10553,"DATA \"Step 1: RESTORE\"");
add(10554,"DATA \"Step 2: READ past headers and tables\"");
add(10555,"DATA \"Step 3: Skip pages by count to your target\"");
add(10556,"DATA \"This help program uses that exact pattern.\"");
add(10557,"DATA \"See also: Page Reader code path\"");
add(10558,"DATA \"\"");
add(10560,"REM === Page 29: Data & Arrays / Named Streams ===");
add(10570,"DATA 7");
add(10571,"DATA \"NAMED DATA STREAMS\"");
add(10572,"DATA \"What: Keep multiple logical DATA streams.\"");
add(10573,"DATA \"Syntax: RESTORE but no line #;   READ ...\"");
add(10574,"DATA \"\"");
add(10575,"DATA \"Use: Separate content tables by purpose.\"");
add(10576,"DATA \"See also: DATA/READ/RESTORE\"");
add(10577,"DATA \"\"");
add(10580,"REM === Page 30: Data & Arrays / Arrays topic p1 ===");
add(10590,"DATA 7");
add(10591,"DATA \"ARRAYS - Topic (Part 1)\"");
add(10592,"DATA \"What: Use arrays for menus and listings.\"");
add(10593,"DATA \"Type: DIM IDX(32): IDX(1)=7: PRINT IDX(1)\"");
add(10594,"DATA \"Tip: 1-based loops pair well with arrays.\"");
add(10595,"DATA \"Tip: Always check user input bounds.\"");
add(10596,"DATA \"See also: Arrays p2, INPUT\"");
add(10597,"DATA \"\"");
add(10600,"REM === Page 31: Data & Arrays / Arrays topic p2 ===");
add(10610,"DATA 7");
add(10611,"DATA \"ARRAYS - Topic (Part 2)\"");
add(10612,"DATA \"What: Store records in parallel arrays.\"");
add(10613,"DATA \"Type: DIM A(3),B$(3): A(1)=10: B$(1)=\"\"OK\"\"\"");
add(10614,"DATA \"\"");
add(10615,"DATA \"\"");
add(10616,"DATA \"See also: Data & Arrays\"");
add(10617,"DATA \"\"");
add(10620,"REM === Page 32: Editor & Files / Editor Commands p1 ===");
add(10630,"DATA 8");
add(10631,"DATA \"EDITOR COMMANDS - Part 1\"");
add(10632,"DATA \"What: Basic editor actions.\"");
add(10633,"DATA \"Type: LIST   : RUN   : NEW   : SAVE \"\"NAME\"\"\"");
add(10634,"DATA \"Use: COPY then :PASTE to move blocks of code\"");
add(10635,"DATA \"Use: DIR overlay to pick files\"");
add(10636,"DATA \"Tip: Keep frequent saves and backups.\"");
add(10637,"DATA \"See also: Shortcuts, DIR Overlay\"");
add(10638,"DATA \"\"");
add(10640,"REM === Page 33: Editor & Files / Editor Commands p2 ===");
add(10650,"DATA 7");
add(10651,"DATA \"EDITOR COMMANDS - Part 2\"");
add(10652,"DATA \"What: Edit by line number; retype to replace.\"");
add(10653,"DATA \"Use: LIST to view lines; NEW clears program\"");
add(10654,"DATA \"Use: RUN to execute; ESC to stop\"");
add(10655,"DATA \"Tip: Save often with SAVE \"\"NAME\"\"\"");
add(10656,"DATA \"SCREENEDIT or SE to load full screen editor.\"");
add(10657,"DATA \"See also: SAVE/LOAD\"");
add(10660,"REM === Page 34: Editor & Files / Editor Commands p3 ===");
add(10670,"DATA 7");
add(10671,"DATA \"EDITOR COMMANDS - Part 3\"");
add(10672,"DATA \"What: Debugging tips.\"");
add(10673,"DATA \"Use: Console logs for tracing (HTML)\"");
add(10674,"DATA \"Use: RUN to Run Program, ESC to stop\"");
add(10675,"DATA \"\"");
add(10676,"DATA \"See also: Shortcuts\"");
add(10677,"DATA \"\"");
add(10680,"REM === Page 35: Editor & Files / DIR Overlay ===");
add(10690,"DATA 7");
add(10691,"DATA \"DIR OVERLAY\"");
add(10692,"DATA \"What: Pick files from a directory overlay.\"");
add(10693,"DATA \"Keys: Arrows to move, ENTER select, ESC cancel\"");
add(10694,"DATA \"Tip: Pause editor input while overlay is open.\"");
add(10695,"DATA \"Tip: Validate names and paths.\"");
add(10696,"DATA \"See also: SAVE/LOAD\"");
add(10697,"DATA \"NOTE: Currently some oddities 9 Sept 2025\"");
add(10700,"REM === Page 36: Editor & Files / SAVE-LOAD ===");
add(10710,"DATA 8");
add(10711,"DATA \"SAVE / LOAD\"");
add(10712,"DATA \"What: Save a program and load it later.\"");
add(10713,"DATA \"Type: SAVE \"\"DEMO\"\"   :   LOAD \"\"DEMO\"\"\"");
add(10714,"DATA \"Tip: Avoid spaces or odd characters in \"");
add(10715,"DATA \"names.\"");
add(10716,"DATA \"Tip: Confirm overwrite; keep versions.\"");
add(10717,"DATA \"Tip: Consider auto-save on run or exit.\"");
add(10718,"DATA \"See also: Editor Commands, DIR Overlay\"");
add(10720,"REM === Page 37: Editor & Files / Shortcuts p1 ===");
add(10730,"DATA 7");
add(10731,"DATA \"SHORTCUTS - Part 1\"");
add(10732,"DATA \"F5 Dumps program to Console (HTML); ESC = STOP\"");
add(10733,"DATA \"Ctrl+C Copy   ;   Ctrl+V Paste (browser perms)\"");
add(10734,"DATA \"Command: HELP to open this help\"");
add(10735,"DATA \"Tip: Show hints in the status bar.\"");
add(10736,"DATA \"SE short for SCREENEDIT; Full screen editor\"");
add(10737,"DATA \"See also: Shortcuts p2\"");
add(10740,"REM === Page 38: Editor & Files / Shortcuts p2 ===");
add(10750,"DATA 7");
add(10751,"DATA \"SHORTCUTS - Part 2\"");
add(10752,"DATA \"Tips: Keep lines short; use gaps 10,20,30\"");
add(10753,"DATA \"Tips: Label output: PRINT \"\"A=\"\" ; A\"");
add(10754,"DATA \"Tips: Use comments with REM or '\"");
add(10755,"DATA \"Tips: Re-run often; save before big edits\"");
add(10756,"DATA \"See also: Editor Commands\"");
add(10757,"DATA \"\"");

}

================================================================================

/// @file scripts/help_build_topics/help_build_topics.gml

/// Build/refresh the in-memory help topics tree
function help_build_topics() {
    // Initialize help_state if it doesn't exist
    if (!variable_global_exists("help_state")) {
        global.help_state = { built: false };
    }
    
    // Initialize or recreate list
    if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }

    // ==== Topics ====
    
    // Topic 1: Editor Commands
    var t1 = { title: "Editor Commands", subs: [] };
    array_push(t1.subs, { 
        title: "RUN / NEW / CLEAR / LIST", 
        lines: [
            "RUN - Execute the current BASIC program.",
            "NEW or CLEAR - Remove all lines from memory.",
            "LIST [start-end] - Show program lines.",
            "F5 - Dump listing to console."
        ]
    });
    array_push(t1.subs, { 
        title: "FILES: SAVE / LOAD / DIR", 
        lines: [
            "SAVE \"name\" - Adds .BAS, writes to Documents/BasicInterpreter.",
            "LOAD \"name\" - Loads program.",
            "DIR - Interactive browser (arrows, Enter, D/X delete, ESC quit)."
        ]
    });
    ds_list_add(global.help_topics, t1);

    // Topic 2: Language Basics
    var t2 = { title: "Language Basics", subs: [] };
    array_push(t2.subs, { 
        title: "Lines, Variables, PRINT", 
        lines: [
            "Lines run in numeric order unless redirected.",
            "Numeric vars: A, X1; Strings: NAME$; Arrays: DIM A(10).",
            "PRINT text or values; ; keeps the cursor on the line."
        ]
    });
    array_push(t2.subs, { 
        title: "INPUT / INKEY$", 
        lines: [
            "INPUT prompts and waits; assigns to variable.",
            "INKEY$ returns last key (\"\" when none).",
            "Extended keys return 2-char sequences."
        ]
    });
    ds_list_add(global.help_topics, t2);

    // Topic 3: Control Flow
    var t3 = { title: "Control Flow", subs: [] };
    array_push(t3.subs, { 
        title: "IF / ELSE / ENDIF", 
        lines: [
            "Inline IF: IF X=1 THEN PRINT \"HI\"",
            "Block IF ... ELSE ... ENDIF is supported."
        ]
    });
    array_push(t3.subs, { 
        title: "FOR / NEXT, WHILE / WEND", 
        lines: [
            "FOR I=1 TO 10 [STEP S] ... NEXT",
            "WHILE condition ... WEND"
        ]
    });
    ds_list_add(global.help_topics, t3);

    // Topic 4: MODE 1 (Tile) Basics
    var t4 = { title: "MODE 1 (Tile) Basics", subs: [] };
    array_push(t4.subs, { 
        title: "PRINTAT / CHARAT / PSET", 
        lines: [
            "PRINTAT x,y,\"TEXT\"[,FG,BG]",
            "CHARAT x,y,code[,FG,BG] places a tile/char.",
            "PSET x,y,code[,FG,BG,BG] shorthand."
        ]
    });
    // Topic 5: Math & Random
    var t5 = { title: "Math & Random", subs: [] };
    array_push(t5.subs, { 
        title: "Math Functions", 
        lines: [
            "ABS, INT, SGN, EXP, LOG, LOG10",
            "SIN, COS, TAN (work in radians)",
            "^ for exponentiation",
            "Standard operator precedence"
        ]
    });
    array_push(t5.subs, { 
        title: "Random Numbers", 
        lines: [
            "RND(6) returns 1 to 6",
            "RND(1,10) returns range 1 to 10", 
            "RND or RND(1) returns 0 to 1"
        ]
    });
    ds_list_add(global.help_topics, t5);

    // Topic 6: Strings
    var t6 = { title: "Strings", subs: [] };
    array_push(t6.subs, { 
        title: "String Functions", 
        lines: [
            "LEFT$, RIGHT$, MID$ for substrings",
            "LEN for string length",
            "CHR$(65) converts to \"A\"",
            "ASC(\"A\") converts to 65"
        ]
    });
    ds_list_add(global.help_topics, t6);

    // Topic 7: Data & Arrays  
    var t7 = { title: "Data & Arrays", subs: [] };
    array_push(t7.subs, { 
        title: "DATA/READ/RESTORE", 
        lines: [
            "DATA statement stores values",
            "READ loads into variables", 
            "RESTORE resets to start",
            "Named streams: DATA @name: values"
        ]
    });
    array_push(t7.subs, { 
        title: "Arrays", 
        lines: [
            "DIM A(10) creates array 0 to 10",
            "Use in loops: FOR I=0 TO 10",
            "Multi-dimensional: DIM A(5,5)",
            "Dynamic sizing: DIM A(X+5)"
        ]
    });
    ds_list_add(global.help_topics, t7);

    // Topic 8: Input/Output
    var t8 = { title: "Input/Output", subs: [] };
    array_push(t8.subs, { 
        title: "PRINT Variations", 
        lines: [
            "PRINT X prints value and newline",
            "PRINT X; keeps cursor on line",
            "PRINT X,Y,Z uses tab columns",
            "PRINT without args = blank line"
        ]
    });
    array_push(t8.subs, { 
        title: "INPUT and Keys", 
        lines: [
            "INPUT \"Prompt: \",VAR waits for input",
            "INKEY$ returns last key pressed",
            "CLS clears screen",
            "COLOR FG,BG sets colors"
        ]
    });
    ds_list_add(global.help_topics, t8);

    // Topic 9: Editor & Files
    var t9 = { title: "Editor & Files", subs: [] };
    array_push(t9.subs, { 
        title: "File Operations", 
        lines: [
            "SAVE \"filename\" saves program",
            "LOAD \"filename\" loads program",
            "DIR opens file browser",
            "Drag & drop .BAS files to load"
        ]
    });
    array_push(t9.subs, { 
        title: "Editor Commands", 
        lines: [
            "LIST shows program lines",
            "RUN executes program",
            "NEW or CLEAR erases program",
            "F5 dumps to console"
        ]
    });
    ds_list_add(global.help_topics, t9);

    global.help_state.built = true;
}

================================================================================

/// @file scripts/help_launch/help_launch.gml

/// help_launch()
function help_launch() {
    // Always build the help topics to ensure they're current
    help_build_topics();
    
    // Save current program state
    help_snapshot_program();
    
    // Build the help browser program
    help_build_program();
    
    // Set help active flag
    global.help_active = true;
    
    // Initialize BASIC variables if they don't exist
    if (!variable_global_exists("basic_variables")) {
        global.basic_variables = ds_map_create();
    }
    
    // Set the help done flag to false initially
    global.basic_variables[? "HELP_DONE"] = 0;
    
    // Launch the interpreter with the help program
    run_program();
}

================================================================================

/// @file scripts/help_restore_program/help_restore_program.gml

/// help_restore_program()
function help_restore_program() {
    if (!variable_global_exists("help_snapshot_lines")) return;

    // wipe current
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // restore
    var key = ds_map_find_first(global.help_snapshot_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.help_snapshot_lines, key);
        ds_map_add(global.program_lines, key, val);
        key = ds_map_find_next(global.help_snapshot_lines, key);
    }
    for (var i = 0; i < ds_list_size(global.help_snapshot_nums); i++) {
        ds_list_add(global.line_numbers, ds_list_find_value(global.help_snapshot_nums, i));
    }

    // clean snapshot
    ds_map_destroy(global.help_snapshot_lines);
    ds_list_destroy(global.help_snapshot_nums);
    global.help_snapshot_lines = undefined;
    global.help_snapshot_nums  = undefined;
}



================================================================================

/// @file scripts/help_snapshot_program/help_snapshot_program.gml

/// help_snapshot_program()
function help_snapshot_program() {
    // destroy any old snapshot
    if (variable_global_exists("help_snapshot_lines") && ds_exists(global.help_snapshot_lines, ds_type_map)) {
        ds_map_destroy(global.help_snapshot_lines);
    }
    if (variable_global_exists("help_snapshot_nums") && ds_exists(global.help_snapshot_nums, ds_type_list)) {
        ds_list_destroy(global.help_snapshot_nums);
    }

    // deep copy maps/lists you mutate during load/run
    global.help_snapshot_lines = ds_map_create();
    var key = ds_map_find_first(global.program_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.program_lines, key);
        ds_map_add(global.help_snapshot_lines, key, val);
        key = ds_map_find_next(global.program_lines, key);
    }

    global.help_snapshot_nums = ds_list_create();
    for (var i = 0; i < ds_list_size(global.line_numbers); i++) {
        ds_list_add(global.help_snapshot_nums, ds_list_find_value(global.line_numbers, i));
    }
}



================================================================================

/// @file scripts/import_from_url/import_from_url.gml

/// @function import_from_url(_url)
/// @desc Fetch text at URL, then import into the editor as numbered lines.
function import_from_url(_url) {
    if (!is_string(_url) || _url == "") {
        show_error_message("Usage: :LOADURL <http(s)://...>");
        return;
    }
    if (!variable_global_exists("http_tags")) global.http_tags = ds_map_create();

    var req = http_get(_url);
    // Store a tag so we know why this request happened
    ds_map_replace(global.http_tags, req, ":LOADURL");
   if (dbg_on(DBG_FLOW)) show_debug_message("[LOADURL] GET -> " + _url + " (req=" + string(req) + ")");
}


================================================================================

/// @file scripts/infix_to_postfix/infix_to_postfix.gml

/// @script infix_to_postfix
// === BEGIN: infix_to_postfix ===
function infix_to_postfix(tokens) {
    if (dbg_on(DBG_PARSE)) show_debug_message("Converting to postfix: " + string(tokens));

    var output = [];
    var stack  = [];

    // Local helper: safe uppercase
    var _TOKU = function(_t) { return string_upper(string(_t)); };

    // Local helper: append array contents to another array
    var _push_all = function(_dst, _src) {
        for (var __i = 0; __i < array_length(_src); __i++) {
            array_push(_dst, _src[__i]);
        }
    };

    // Local helper: which functions are truly zero-arg
    var _is_zero_arg_fn = function(_name) {
        var n = string_upper(_name);
        return (n == "TIMER" || n == "TIME$" || n == "DATE$" || n == "INKEY$");
    };

    // Local helper: explicitly treat STRING$ as a function
    var _is_STRING_fn = function(_name) {
        return string_upper(string(_name)) == "STRING$";
    };

    for (var i = 0; i < array_length(tokens); i++) {
        var t  = tokens[i];        // raw token
        if (t == ",") {
            if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Skipping comma token");
            continue;
        }

        var tu = _TOKU(t);

        // ==========================================================
        // 1) ARRAY READ COLLAPSE
        // ==========================================================
        if (is_string(t)) {
            var first = string_char_at(t, 1);
            var can_be_name = is_letter(first);

            if (can_be_name
            &&  i + 1 < array_length(tokens)
            &&  tokens[i + 1] == "("
            && !(is_function(t) || _is_STRING_fn(t))) // NEW: also skip STRING$
            {
                var _depth   = 0;
                var j       = i + 1;
                var inner   = "";
                var matched = false;

                if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Candidate for array collapse → '" + string(t) + "' followed by '('");

                while (j < array_length(tokens)) {
                    var tk = tokens[j];
                    if (tk == "(") {
                        _depth++;
                        if (_depth > 1) inner += tk;
                    } else if (tk == ")") {
                        _depth--;
                        if (_depth == 0) { matched = true; break; }
                        inner += tk;
                    } else {
                        inner += tk;
                    }
                    j++;
                }

                if (matched) {
                    var collapsed = string(t) + "(" + inner + ")";
                    array_push(output, collapsed);
                    if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Collapsed array read token → '" + collapsed + "' (consumed through index " + string(j) + ")");
                    i = j;
                    continue;
                } else {
                    if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: WARNING — unmatched '(' after '" + string(t) + "'. Not collapsing.");
                }
            }
        }

        // ==========================================================
        // 2) NUMERIC LITERAL
        // ==========================================================
        if (is_numeric_string(t)) {
            array_push(output, t);
            if (dbg_on(DBG_PARSE)) show_debug_message("Added number to output: " + string(t));
            continue;
        }

        // ==========================================================
        // 3) KNOWN VARIABLE
        // ==========================================================
        if (ds_map_exists(global.basic_variables, tu)) {
            array_push(output, tu);
            if (dbg_on(DBG_PARSE)) show_debug_message("Added variable name to output: " + tu);
            continue;
        }

        // ==========================================================
        // 4) OPEN PAREN
        // ==========================================================
        if (t == "(") {
            array_push(stack, t);
            if (dbg_on(DBG_PARSE)) show_debug_message("Pushed '(' onto operator stack");
            continue;
        }

        // ==========================================================
        // 5) CLOSE PAREN
        // ==========================================================
        if (t == ")") {
            while (array_length(stack) > 0 && stack[array_length(stack) - 1] != "(") {
                var popped_close = array_pop(stack);
                array_push(output, popped_close);
                if (dbg_on(DBG_PARSE)) show_debug_message("Popped '" + string(popped_close) + "' from stack to output (closing ')')");
            }
            if (array_length(stack) > 0 && stack[array_length(stack) - 1] == "(") {
                array_pop(stack);
                if (dbg_on(DBG_PARSE)) show_debug_message("Discarded matching '(' from stack");
            } else {
                if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: WARNING — stray ')' with no matching '('");
            }
            continue;
        }

        // ==========================================================
        // 6) OPERATORS
        // ==========================================================
        if (is_operator(t)) {
            if (dbg_on(DBG_PARSE)) show_debug_message("Found operator: " + string(t));
            while (array_length(stack) > 0) {
                var top = stack[array_length(stack) - 1];
                if (is_operator(top) && (
                    get_precedence(top) > get_precedence(t) ||
                    (get_precedence(top) == get_precedence(t) && !is_right_associative(t))
                )) {
                    var popped_op = array_pop(stack);
                    array_push(output, popped_op);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Popped higher/equal precedence operator '" + string(popped_op) + "' to output");
                } else {
                    break;
                }
            }
            array_push(stack, t);
            if (dbg_on(DBG_PARSE)) show_debug_message("Pushed operator '" + string(t) + "' onto stack");
            continue;
        }

        // ==========================================================
        // 7) FUNCTIONS
        // ==========================================================
        if (is_function(t) || _is_STRING_fn(t)) {
            var fn_name = tu;

            // ... [unchanged existing handlers] ...

            // STRING$(x, n) — 2 args
            if (fn_name == "STRING$"
            &&  i + 5 < array_length(tokens)
            &&  tokens[i + 1] == "("
            &&  tokens[i + 3] == ","
            &&  tokens[i + 5] == ")")
            {
                var sa1 = tokens[i + 2];
                var sa2 = tokens[i + 4];
                array_push(output, sa1);
                array_push(output, sa2);
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("Processed STRING$(x,n): args = " + string(sa1) + ", " + string(sa2));
                i += 5;
                continue;
            }

            // ... [rest of your handlers: MID$, LEFT$/RIGHT$, fallback, etc.] ...
        }

        // ==========================================================
        // 8) UNKNOWN TOKEN
        // ==========================================================
        if (dbg_on(DBG_PARSE)) show_debug_message("Unknown token, adding to output: " + string(t));
        array_push(output, t);
    }

    // ==========================================================
    // Drain operator stack
    // ==========================================================
    while (array_length(stack) > 0) {
        var tail = array_pop(stack);
        array_push(output, tail);
        if (dbg_on(DBG_PARSE)) show_debug_message("Drained operator stack → appended '" + string(tail) + "'");
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("Final postfix: " + string(output));
    return output;
}
// === END: infix_to_postfix ===


================================================================================

/// @file scripts/inkey_capture_keys/inkey_capture_keys.gml

// FILE: scripts/inkey_capture_keys.gml
// FUNCTION: inkey_capture_keys
// PURPOSE: Feed the INKEY$ queue with a single key per frame.
// POLICY:
//   - Block capture while BASIC INPUT is active (awaiting_input = true)
//     UNLESS we are in an INKEY$ modal wait (inkey_waiting = true).
//   - During INKEY$ modal wait, keep capturing so the state machine can unblock.
//   - Otherwise capture printable ASCII (32..126) and (optionally) touch on Android.

function inkey_capture_keys() {
    /// inkey_capture_keys()

    // --- INPUT/INKEY arbitration guard -------------------------------------
    // Block capture only when INPUT is live and we are NOT in a modal INKEY wait.
    var _block_capture = false;

    if (variable_global_exists("awaiting_input") && global.awaiting_input) {
        var _inkey_waiting = (variable_global_exists("inkey_waiting") && global.inkey_waiting);
        if (!_inkey_waiting) {
            _block_capture = true;  // INPUT owns the keyboard; don't feed INKEY$ queue
        }
    }

    if (_block_capture) {
		//TEMPORARY: REMOVE WHEN TESTING INKEY$
        //if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: blocked (awaiting_input && !inkey_waiting)");
        exit;
    }
    // -----------------------------------------------------------------------

    // Initialize queue if not exists (use your current global.__inkey_queue)
    if (!ds_exists(global.__inkey_queue, ds_type_queue)) {
        global.__inkey_queue = ds_queue_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Initialized global.__inkey_queue");
    }

    // --- Scan for one printable key (ASCII 32..126) per frame ---------------
    for (var key = 32; key <= 126; key++) {
        if (keyboard_check_pressed(key)) {
            var ch = chr(key);
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Key " + string(key) + " pressed, char='" + ch + "'");

            // Limit queue length to 10 (same policy as before)
            if (ds_queue_size(global.__inkey_queue) < 10) {
                ds_queue_enqueue(global.__inkey_queue, ch);
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: '" + ch + "' queued. Size=" + string(ds_queue_size(global.__inkey_queue)));
            } else {
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Queue full (10), skipped '" + ch + "'");
            }
            break; // capture at most one key per frame
        }
    }

    // --- Optional: map simple touch regions to WASD on Android --------------
    if (os_type == os_android) {
        var w = display_get_width();
        var h = display_get_height();
        if (device_mouse_check_button_pressed(0, mb_left)) {
            var mx = device_mouse_x(0);
            var my = device_mouse_y(0);
            var ch2 = "";

            // Quadrant-ish mapping (center bands) → W/A/S/D
            if (my < h * 0.5 && mx > w * 0.25 && mx < w * 0.75) ch2 = "W";
            else if (my > h * 0.5 && mx > w * 0.25 && mx < w * 0.75) ch2 = "S";
            else if (mx < w * 0.5 && my > h * 0.25 && my < h * 0.75) ch2 = "A";
            else if (mx > w * 0.5 && my > h * 0.25 && my < h * 0.75) ch2 = "D";

            if (ch2 != "" && ds_queue_size(global.__inkey_queue) < 10) {
                ds_queue_enqueue(global.__inkey_queue, ch2);
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Touch→'" + ch2 + "', queued. Size=" + string(ds_queue_size(global.__inkey_queue)));
            }
        }
    }
}


================================================================================

/// @file scripts/insert_line_number_ordered/insert_line_number_ordered.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function insert_line_number_ordered(new_line_num) {
    var size = ds_list_size(global.line_numbers);
    var inserted = false;
    
    for (var i = 0; i < size; i++) {
        if (ds_list_find_value(global.line_numbers, i) > new_line_num) {
            ds_list_insert(global.line_numbers, i, new_line_num);
            inserted = true;
            break;
      }
    }
    
    if (!inserted) {
        ds_list_add(global.line_numbers, new_line_num);
    }
 }

================================================================================

/// @file scripts/interpreter_cmd_print/interpreter_cmd_print.gml

/// @function interpreter_cmd_print(argument)
/// @description Handles the BASIC PRINT command.
/// @param arg - The string argument from the BASIC code

function interpreter_cmd_print(arg) {
    // Remove surrounding double quotes if present
    if (string_length(arg) >= 2 &&
        string_char_at(arg, 1) == "\"" &&
        string_char_at(arg, string_length(arg)) == "\"") {
        arg = string_copy(arg, 2, string_length(arg) - 2);
    }

    ds_list_add(output_lines, arg);
}


================================================================================

/// @file scripts/is_function/is_function.gml

/// @script is_function
// === BEGIN: is_function ===
function is_function(t) {
    var fn = string_upper(string_trim(t));
    return  fn == "RND"    // your original BASIC call
         || fn == "RND1"   // internal 1-arg postfix token
         || fn == "RND2"   // internal 2-arg postfix token
         || fn == "STR$"
         || fn == "CHR$"
         || fn == "LEFT$"
         || fn == "RIGHT$"
         || fn == "MID$"
         || fn == "ABS"
         || fn == "INT"
         || fn == "EXP"
         || fn == "LOG"
         || fn == "LOG10"
         || fn == "SGN"
         || fn == "SIN"
         || fn == "COS"
         || fn == "TAN"
         || fn == "REPEAT$"
         || fn == "TIMER"
         || fn == "TIME$"
         || fn == "DATE$"
         || fn == "INKEY$"
         || fn == "ASC";   // <-- added
}
// === END: is_function ===


================================================================================

/// @file scripts/is_function_token/is_function_token.gml

/// @function is_function_token(token)
/// @description Checks if a given token is a recognized BASIC function.
/// @param {string} token The token to check.
/// @returns {boolean} True if it's a function, false otherwise.
function is_function_token(token) {
    var upper_token = string_upper(token);
    // Add more functions here as you implement them in evaluate_postfix
    return upper_token == "RND" || upper_token == "ABS";
}

================================================================================

/// @file scripts/is_letter/is_letter.gml

function is_letter(ch) {
    var o = ord(string_upper(ch));
    return (o >= 65 && o <= 90);
}




================================================================================

/// @file scripts/is_letter_or_digit/is_letter_or_digit.gml

function is_letter_or_digit(ch) {
    return is_letter(ch) || (ord(ch) >= 48 && ord(ch) <= 57);
}

================================================================================

/// @file scripts/is_line_number/is_line_number.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_line_number(str) {
    // Check if string contains only digits
    if (string_length(str) == 0) return false;
    
    for (var i = 1; i <= string_length(str); i++) {
        var char = string_char_at(str, i);
        if (char < "0" || char > "9") return false;
    }
    
    // Convert to number and validate range
    var line_num = real(str);
    return (line_num >= 1 && line_num <= 65535);
 }

================================================================================

/// @file scripts/is_numeric_string/is_numeric_string.gml

function is_numeric_string(str) {
    if (string_length(str) == 0) return false;

    // Allow negative sign
    if (string_char_at(str, 1) == "-") {
        str = string_copy(str, 2, string_length(str));
        if (string_length(str) == 0) return false; // <- Add this
    }

    var dot_count = 0;
    for (var i = 1; i <= string_length(str); i++) {
        var c = string_char_at(str, i);
        if (c == ".") {
            dot_count++;
            if (dot_count > 1) return false;
        }
        else if (ord(c) < ord("0") || ord(c) > ord("9")) {
            return false;
        }
    }

    return true;
}


================================================================================

/// @file scripts/is_operator/is_operator.gml

function is_operator(op) {
    return (op == "+" || op == "-" || op == "*" || op == "/" || op == "\\" || op == "^" || 
            op == "%" || string_upper(op) == "MOD" ||
        op == "=" || op == "<>" || op == "<" || op == ">" || op == "<=" || op == ">=");
}

================================================================================

/// @file scripts/is_quoted_string/is_quoted_string.gml

function is_quoted_string(str) {
    return (string_length(str) >= 2 &&
            string_char_at(str, 1) == "\"" &&
            string_char_at(str, string_length(str)) == "\"");
}


================================================================================

/// @file scripts/is_right_associative/is_right_associative.gml

function is_right_associative(op) {
    return (op == "^");
}


================================================================================

/// @file scripts/is_valid_line_number/is_valid_line_number.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function is_valid_line_number(line_num) {
    return (line_num >= 1 && line_num <= global.config[? "max_line_number"]);
 }


================================================================================

/// @file scripts/list_program/list_program.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function list_program() {
    display_start_line = 0;
    update_display();
 }
 function list_program_range(range) {
    // Parse range like "10-50" or single number "10"
    var dash_pos = string_pos("-", range);
    if (dash_pos > 0) {
        var start_line = real(string_copy(range, 1, dash_pos - 1));
        var end_line = real(string_copy(range, dash_pos + 1, string_length(range)));
        list_between_lines(start_line, end_line);
    } else {
        var single_line = real(range);
        list_single_line(single_line);
    }
 }

================================================================================

/// @file scripts/list_saved_programs/list_saved_programs.gml

/// scripts/list_saved_programs/list_saved_programs.gml
function list_saved_programs()
{
    var ed = instance_find(obj_editor, 0);
    if (ed == noone) { if (dbg_on(DBG_IO)) show_debug_message("[DIR] no obj_editor instance"); return; }

    if (!variable_instance_exists(ed, "dir_listing"))          ed.dir_listing = [];
    if (!variable_instance_exists(ed, "showing_dir_overlay"))  ed.showing_dir_overlay = false;

    var save_dir = get_save_directory();
    if (!is_string(save_dir) || string_length(save_dir) == 0) save_dir = working_directory;
    if (!directory_exists(save_dir)) directory_create(save_dir);

    // Persist save dir for actions
    ed.dir_save_dir = save_dir;

    // Build listing (.bas only)
    ed.dir_listing = [];
    var mask = save_dir + "*.bas";
    var fname = file_find_first(mask, 0); // IMPORTANT: 0 = no attribute filter
    var count = 0;
    while (fname != "") {
        array_push(ed.dir_listing, fname);
        count += 1;
        fname = file_find_next();
    }
    file_find_close();
    if (count == 0) array_push(ed.dir_listing, "No .bas files found.");

    // Initialize overlay state (ASCII UI)
    ed.dir_sel                 = 0;           // selected row (0-based in view)
    ed.dir_page                = 0;           // current page (0-based)
    ed.dir_page_size           = 1;           // will be recomputed in Draw each frame
    ed.dir_sorted_by           = "name";      // future use: "name"|"date"|"size"
    ed.dir_filter              = "";          // future filter text
    ed.dir_preview_on          = false;       // optional preview pane toggle
    ed.dir_confirm_active      = false;       // delete confirm modal
    ed.dir_confirm_index       = -1;          // which file index is pending delete
    ed.dir_mouse_hover_row     = -1;          // hover state (optional)
    ed.dir_mouse_hover_action  = "";          // ""|"load"|"del"

    ed.showing_dir_overlay = true;

    if (dbg_on(DBG_IO)) show_debug_message("[DIR] open path=" + save_dir + " files=" + string(count));
}


================================================================================

/// @file scripts/load_program_from/load_program_from.gml

function load_program_from(filename)
{
    // Normalize input
    filename = string_trim(filename);
    if (string_length(filename) == 0) {
        basic_show_error_message("NO FILENAME PROVIDED");
        return;
    }
    // Strip quotes if present
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename) - 2);
    }
    // Add .bas if missing
    var ext = string_lower(string_copy(filename, string_length(filename) - 3, 4));
    if (ext != ".bas") {
        filename += ".bas";
    }

    // Build full path from the same directory used by SAVE
    var file_path = get_save_directory() + filename;

    if (!file_exists(file_path)) {
        basic_show_error_message("FILE NOT FOUND: " + filename);
        return;
    }

    // Clear current program (your function should reset global.program_lines etc.)
    new_program();

    var file = file_text_open_read(file_path);
    if (file == -1) {
        basic_show_error_message("COULD NOT OPEN FILE: " + filename);
        return;
    }

    // Read file line-by-line
    while (!file_text_eof(file)) {
        var line = file_text_read_string(file);
        file_text_readln(file); // consume newline
        line = string_trim(line);

        if (string_length(line) == 0) {
            continue; // skip empties
        }

        // Split on first space to detect a numeric line number
        var sp = string_pos(" ", line);
        if (sp <= 0) {
            // No space → treat as free text; assign a synthetic line number by asking your helper,
            // or just skip if you strictly require numeric lines. Here we skip to keep behavior predictable.
            continue;
        }

        var line_num_str = string_copy(line, 1, sp - 1);
        var code_content = string_copy(line, sp + 1, string_length(line) - sp);
        var line_num = real(line_num_str);

        // Use your existing validation helpers
        if (is_line_number(line_num_str) && is_valid_line_number(line_num)) {
            // Store into your canonical container and order list
            ds_map_set(global.program_lines, line_num, code_content);
            insert_line_number_ordered(line_num);
        }
    }

    file_text_close(file);
    current_filename = filename;
    basic_show_message("LOADED: " + filename);
    update_display();
}


================================================================================

/// @file scripts/load_program_from_path/load_program_from_path.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function load_program_from_path(file_path, filename) {
    if (!file_exists(file_path)) {
        show_error_message("DRAG FILE NOT FOUND");
        return;
    }
    
    try {
        save_undo_state();
        new_program_without_undo();
        
        var file = file_text_open_read(file_path);
        while (!file_text_eof(file)) {
            var line = file_text_read_string(file);
            file_text_readln(file);
            
            if (string_trim(line) != "") {
                var space_pos = string_pos(" ", line);
                if (space_pos > 0) {
                    var line_num_str = string_copy(line, 1, space_pos - 1);
					                    var line_num = real(line_num_str);
                    var code_content = string_copy(line, space_pos + 1, string_length(line));
                    
                    if (is_line_number(line_num_str) && is_valid_line_number(line_num)) {
                        ds_map_set(global.program_lines, line_num, code_content);
                        insert_line_number_ordered(line_num);
                    }
                }
            }
        }
        file_text_close(file);
        current_filename = filename;
        basic_show_message("LOADED via DRAG: " + filename);
        update_display();
    } catch (e) {
        show_error_message("DRAG LOAD ERROR");
    }
 }

================================================================================

/// @file scripts/load_program_json/load_program_json.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function load_program_json(filename) {
    var file_path = working_directory + filename + ".json";
    
    if (!file_exists(file_path)) {
        show_error_message("JSON FILE NOT FOUND");
        return;
    }
    
    try {
        var file = file_text_open_read(file_path);
        var json_string = file_text_read_string(file);
        file_text_close(file);
        
        var loaded_map = json_decode(json_string);
        
        new_program();
        ds_map_copy(global.program_lines, loaded_map);
        
        // Rebuild line numbers list
        var key = ds_map_find_first(global.program_lines);
        while (!is_undefined(key)) {
            insert_line_number_ordered(real(key));
            key = ds_map_find_next(global.program_lines, key);
        }
        
        ds_map_destroy(loaded_map);
        basic_show_message("LOADED JSON: " + filename);
        update_display();
    } catch (e) {
        show_error_message("JSON LOAD ERROR");
    }
 }

================================================================================

/// @file scripts/mode1_get_char/mode1_get_char.gml

/// @function mode1_get_char(col, row)
/// @description Get character at grid position
function mode1_get_char(col, row) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return 32;
    
    var cols = 40;
    var rows = 25;
    
    if (col < 0 || col >= cols || row < 0 || row >= rows) {
        return 32; // Return space for out of bounds
    }
    
    var i = col + row * cols;
    return grid_obj.grid[i].char;
}

================================================================================

/// @file scripts/mode1_get_color/mode1_get_color.gml

/// @function mode1_get_color(col, row)
/// @description Get foreground color at grid position  
function mode1_get_color(col, row) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return c_white;
    
    var cols = 40;
    var rows = 25;
    
    if (col < 0 || col >= cols || row < 0 || row >= rows) {
        return c_white; // Return white for out of bounds
    }
    
    var i = col + row * cols;
    return grid_obj.grid[i].fg;
}

================================================================================

/// @file scripts/mode1_grid_clear/mode1_grid_clear.gml

// FILE: scripts/mode1_grid_clear.gml
// FUNCTION: mode1_grid_clear(char_index)
// CHANGE: Remove 15x18 constants; iterate over actual grid

/// @param char_index
function mode1_grid_clear(char_index) {
    var cols = grid_cols;
    var rows = grid_rows;

    for (var row = 0; row < rows; row++) {
        for (var col = 0; col < cols; col++) {
            var i = row * cols + col;
            grid[i].char = char_index;
            grid[i].fg = c_white;
            grid[i].bg = c_black;
        }
    }
}


================================================================================

/// @file scripts/mode1_grid_fill/mode1_grid_fill.gml


/// @param char_index
/// @param fg_color
/// @param bg_color
function mode1_grid_fill(char_index, fg_color, bg_color) {
    for (var i = 0; i < array_length(grid); i++) {
        grid[i].char = char_index;
        grid[i].fg = fg_color;
        grid[i].bg = bg_color;
    }
}


================================================================================

/// @file scripts/mode1_grid_set/mode1_grid_set.gml

/// @function mode1_grid_set(x, y, ch, fg, bg)
/// @desc Update a grid cell with char + optional fg/bg colors
function mode1_grid_set(_x, _y, _char, _fg, _bg) {
    var grid_obj = instance_find(obj_mode1_grid, 0);
    if (!instance_exists(grid_obj)) return;

    var cols = grid_obj.grid_cols;
    var rows = grid_obj.grid_rows;
    if (_x < 0 || _x >= cols || _y < 0 || _y >= rows) return;

    var idx = _x + _y * cols;
    var cell = grid_obj.grid[idx];

    // Always set the glyph
    cell.char = _char;

    // Only change colors if the caller supplied them
    if (_fg != undefined) cell.fg = _fg;
    if (_bg != undefined) cell.bg = _bg;

    grid_obj.grid[idx] = cell;
}


================================================================================

/// @file scripts/mode1_scroll_grid/mode1_scroll_grid.gml

/// @function mode1_scroll_grid(grid_obj, direction, amount)
/// @description Scroll the grid contents in specified direction
function mode1_scroll_grid(grid_obj, direction, amount) {
    if (!instance_exists(grid_obj)) return;
    
    var cols = 40;
    var rows = 25;
    amount = clamp(amount, 1, rows);
    
    if (dbg_on(DBG_FLOW)) show_debug_message("GRID SCROLL: " + direction + " by " + string(amount));
    
    with (grid_obj) {
        switch (string_upper(direction)) {
            case "UP":
                // Move all rows up, fill bottom with spaces
                for (var row = 0; row < rows - amount; row++) {
                    for (var col = 0; col < cols; col++) {
                        var src_i = col + (row + amount) * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                }
                // Clear bottom rows
                for (var row = rows - amount; row < rows; row++) {
                    for (var col = 0; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "DOWN":
                // Move all rows down, fill top with spaces
                for (var row = rows - 1; row >= amount; row--) {
                    for (var col = 0; col < cols; col++) {
                        var src_i = col + (row - amount) * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                }
                // Clear top rows
                for (var row = 0; row < amount; row++) {
                    for (var col = 0; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "LEFT":
                // Move all columns left, fill right with spaces
                for (var row = 0; row < rows; row++) {
                    for (var col = 0; col < cols - amount; col++) {
                        var src_i = (col + amount) + row * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                    // Clear right columns
                    for (var col = cols - amount; col < cols; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            case "RIGHT":
                // Move all columns right, fill left with spaces
                for (var row = 0; row < rows; row++) {
                    for (var col = cols - 1; col >= amount; col--) {
                        var src_i = (col - amount) + row * cols;
                        var dst_i = col + row * cols;
                        grid[dst_i] = grid[src_i];
                    }
                    // Clear left columns
                    for (var col = 0; col < amount; col++) {
                        var i = col + row * cols;
                        grid[i] = { char: 32, fg: c_white, bg: c_black };
                    }
                }
                break;
                
            default:
                if (dbg_on(DBG_FLOW)) show_debug_message("SCROLL: Unknown direction: " + direction);
                break;
        }
    }
}

================================================================================

/// @file scripts/navigate_history_down/navigate_history_down.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function navigate_history_down() {
	 if (global.justreturned == 1) return; // 🛑 Block history on return
	 
    if (global.history_index != -1) {
        global.history_index++;
        if (global.history_index >= ds_list_size(global.input_history)) {
            global.history_index = -1;
            current_input = "";
        } else {
            current_input = ds_list_find_value(global.input_history, global.history_index);
        }
        cursor_pos = string_length(current_input);
    }
 }

================================================================================

/// @file scripts/navigate_history_up/navigate_history_up.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function navigate_history_up() {
	
	if (global.justreturned == 1) return; // 🛑 Block history on return
	
    if (ds_list_size(global.input_history) > 0) {
        if (global.history_index == -1) {
            global.history_index = ds_list_size(global.input_history) - 1;
        } else {
            global.history_index = max(0, global.history_index - 1);
        }
        current_input = ds_list_find_value(global.input_history, global.history_index);
        cursor_pos = string_length(current_input);
    }
 }

================================================================================

/// @file scripts/new_program/new_program.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function new_program() {
    // Save state for undo before clearing
    if (ds_list_size(global.line_numbers) > 0) {
        save_undo_state();
    }
    
    ds_map_clear(global.program_lines);
    ds_list_clear(global.line_numbers);
    current_filename = "";
    display_start_line = 0;
    update_display();
    basic_show_message("NEW PROGRAM");
 }

================================================================================

/// @file scripts/new_program_without_undo/new_program_without_undo.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function new_program_without_undo() {
    ds_map_clear(global.program_lines);
    ds_list_clear(global.line_numbers);
    current_filename = "";
    display_start_line = 0;
 }

================================================================================

/// @file scripts/parse_data_value/parse_data_value.gml

/// @func parse_data_value(raw)
/// @desc Convert a DATA token to a GML value:
///       - Quoted -> string with "" -> " unescaped
///       - Else   -> real(number) if numeric, otherwise keep as string (tolerant)
function parse_data_value(raw) {
    var s = string_trim(raw);
    var L = string_length(s);

    // Quoted string
    if (L >= 2 && string_char_at(s, 1) == "\"" && string_char_at(s, L) == "\"") {
        var inner = string_copy(s, 2, L - 2);
        inner = string_replace_all(inner, "\"\"", "\""); // unescape doubled quotes
        if (dbg_on(DBG_FLOW)) show_debug_message("parse_data_value: STRING → \"" + inner + "\" from " + s);
        return inner;
    }

    // Try numeric
    var n = real(s);
    if (string(n) == s || is_real(n)) {
        // Note: GML will give us 0 for non-numeric too; we try a tighter check:
        // If s contains any alpha (not e/E for exponent), treat as string.
        var _has_alpha = false;
        for (var i = 1; i <= L; i++) {
            var ch = string_char_at(s, i);
            if ( (ch >= "A" && ch <= "Z") || (ch >= "a" && ch <= "z") ) {
                if (ch != "E" && ch != "e") { _has_alpha = true; break; }
            }
        }
        if (!_has_alpha) {
            if (dbg_on(DBG_FLOW)) show_debug_message("parse_data_value: NUMBER → " + string(n) + " from " + s);
            return n;
        }
    }

    // Fallback: keep as literal string (lets users store symbolic tokens)
    if (dbg_on(DBG_FLOW)) show_debug_message("parse_data_value: FALLBACK STRING → \"" + s + "\"");
    return s;
}


================================================================================

/// @file scripts/paste_line/paste_line.gml

/// @function paste_line(index, text)
/// @description Called by JavaScript for each line of pasted text
function paste_line(index, text) {
    ds_list_add(paste_buffer, string(text));
   if (dbg_on(DBG_FLOW)) show_debug_message("PASTE_MANAGER: Received line " + string(index) + ": " + string_copy(string(text), 1, 50) + "...");
}

================================================================================

/// @file scripts/pm_paste_handler/pm_paste_handler.gml

/// pm_paste_handler(data, name, type)
function pm_paste_handler(_data, _name, _type) {
    // Text if name is undefined
    if (is_undefined(_name)) {
        if (is_string(_data) && string_length(_data) > 0) {
            pm_receive_text(_data);
        } else {
           if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Text handler: empty or non-string payload.");
        }
    } else {
        // You pasted a file; ignore for now (or handle base64 here)
       if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] File paste ignored: " + string(_name) + " (" + string(_type) + ")");
    }

    // Unbind so we don't keep intercepting Ctrl/Cmd+V forever
    var _bind = asset_get_index("browser_paste_bind");
    if (_bind != -1) script_execute(_bind);
}


================================================================================

/// @file scripts/pm_receive_text/pm_receive_text.gml

/// pm_receive_text(text)
function pm_receive_text(_text) {
    // Compatibility shim for legacy script calling
    var text_in = _text;
    if (is_undefined(text_in)) {
        if (argument_count > 0) text_in = argument0; else text_in = "";
    }

   if (dbg_on(DBG_FLOW)) show_debug_message("[pm_receive_text] got len=" + string(is_string(text_in) ? string_length(text_in) : -1));
    if (!is_string(text_in) || string_length(text_in) <= 0) return 0;

    var t = string(text_in);
    t = string_replace_all(t, "\r\n", "\n");
    t = string_replace_all(t, "\r",   "\n");

    var arr = string_split(t, "\n");
    var count = 0;
    var auto_num = 10;

    for (var i = 0; i < array_length(arr); i++) {
        var raw = string_trim(arr[i]);
        if (raw == "") continue;

        // Treat a leading '+' as decoration (strip it)
        if (string_length(raw) >= 2 && string_char_at(raw, 1) == "+") {
            raw = string_delete(raw, 1, 1);
            raw = string_trim(raw);
        }

        var sp   = string_pos(" ", raw);
        var head = (sp > 0) ? string_copy(raw, 1, sp - 1) : raw;

        if (string_length(head) > 0 && is_real(real(head))) {
            var num  = real(head);
            var code = (sp > 0) ? string_trim(string_copy(raw, sp + 1, string_length(raw))) : "";
            if (function_exists(paste_line)) paste_line(num, code);
        } else {
            if (function_exists(paste_line)) paste_line(auto_num, raw);
            auto_num += 10;
        }
        count++;
    }

    if (instance_exists(obj_paste_manager)) with (obj_paste_manager) {
        _pm_msg = "Imported " + string(count) + " line(s).";
        _pm_msg_ttl = 180;
        _pm_visible = false;
    }

   if (dbg_on(DBG_FLOW)) show_debug_message("[pm_receive_text] imported lines=" + string(count));
    return count;
}


================================================================================

/// @file scripts/process_input_line/process_input_line.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function process_input_line(input_text) {
    // Trim whitespace
    input_text = string_trim(input_text);
    
    if (input_text == "") return;
    
    // Check if line starts with a number
    var first_space = string_pos(" ", input_text);
    var potential_line_num = "";
    
    if (first_space > 0) {
        potential_line_num = string_copy(input_text, 1, first_space - 1);
    } else {
        potential_line_num = input_text;
    }
    
    // Check if it's a valid line number
    if (is_line_number(potential_line_num)) {
        handle_program_line(input_text);
    } else {
        handle_command(input_text);
    }
 }

================================================================================

/// @file scripts/quit_program/quit_program.gml

function quit_program()
{
	game_end();
}


================================================================================

/// @file scripts/refresh_current_line_display/refresh_current_line_display.gml

// ===============================================
// FILE: scripts/refresh_current_line_display/refresh_current_line_display.gml
// NEW: Helper function to update display for current line
// ===============================================

/// @function refresh_current_line_display(editor_inst)
function refresh_current_line_display(editor_inst) {
    with (editor_inst) {
        var full_text = get_full_line_text(id, cursor_y);
        var display_text = string_copy(full_text, horizontal_offset + 1, screen_cols);
        
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Refreshing display - full_text='" + full_text + "', display='" + display_text + "', h_offset=" + string(horizontal_offset));
        
        // Clear the row
        screen_editor_clear_row(id, cursor_y);
        
        // Display the visible portion
        for (var i = 1; i <= string_length(display_text); i++) {
            var ch = string_char_at(display_text, i);
            screen_editor_set_char_at(id, i - 1, cursor_y, ord(ch));
        }
    }
}

================================================================================

/// @file scripts/reset_interpreter_state/reset_interpreter_state.gml

function reset_interpreter_state() {
    global.interpreter_running = false;
    global.program_has_ended = false;
    global.awaiting_input = false;
    global.pause_in_effect = false;
    global.pause_mode = false;
    global.input_expected = false;
    global.interpreter_input = "";
    global.interpreter_cursor_pos = 0;
    global.last_interpreter_string = "";
    
    // Reset mode if needed
    if (global.current_mode != 0) {
        global.current_mode = 0;
        room_goto(rm_basic_interpreter);
    }
    
    // Clear any program execution state
    ds_stack_clear(global.gosub_stack);
    ds_stack_clear(global.for_stack);
    ds_stack_clear(global.while_stack);
	// Clear INKEY$ queue
    if (ds_exists(global.__inkey_queue, ds_type_queue)) {
    ds_queue_clear(global.__inkey_queue);
    if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ RESET: Cleared global.__inkey_queue");
   }
}

================================================================================

/// @file scripts/resolve_basic_value/resolve_basic_value.gml

function resolve_basic_value(key) {
    var k = basic_normvar(key); // normalize before lookup
    return ds_map_exists(global.basic_variables, k)
        ? global.basic_variables[? k]
        : real(key);             // keep your original fallback
}


================================================================================

/// @file scripts/run_program/run_program.gml

function run_program() {
    if (dbg_on(DBG_FLOW)) show_debug_message("RUN_PROGRAM START - color is: " + string(global.current_draw_color));
	// Always remember where we launched from (editor room)
	global.editor_return_room = rm_editor;

    // ── Guard: no program ────────────────────────────────────────────────
    if (!ds_exists(global.line_numbers, ds_type_list) || ds_list_size(global.line_numbers) == 0) {
        show_error_message("NO PROGRAM");
        return;
    }

    // ── Sync editor → runtime structures used by interpreter/validator ──
    // program_map (lineNo -> code)
    if (!ds_exists(global.program_map, ds_type_map)) {
        global.program_map = ds_map_create();
    } else {
        ds_map_clear(global.program_map);
    }
    ds_map_copy(global.program_map, global.program_lines);

    // line_list (sorted list of line numbers)
    if (!ds_exists(global.line_list, ds_type_list)) {
        global.line_list = ds_list_create();
    } else {
        ds_list_clear(global.line_list);
    }
    for (var _i = 0; _i < ds_list_size(global.line_numbers); _i++) {
        ds_list_add(global.line_list, global.line_numbers[| _i]);
    }
    ds_list_sort(global.line_list, true);

    // (Optional archival copies)
    if (!ds_exists(global.basic_program, ds_type_map)) {
        global.basic_program = ds_map_create();
    } else {
        ds_map_clear(global.basic_program);
    }
    ds_map_copy(global.basic_program, global.program_lines);

    if (!variable_global_exists("basic_line_numbers") || !ds_exists(global.basic_line_numbers, ds_type_list)) {
        global.basic_line_numbers = ds_list_create();
    } else {
        ds_list_clear(global.basic_line_numbers);
    }
    ds_list_copy(global.basic_line_numbers, global.line_numbers);

    // ── Make sure output buffers exist BEFORE validation (errors print into them) ──
    if (!is_real(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)) {
        global.output_lines = ds_list_create();
    }
    if (!is_real(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        global.output_colors = ds_list_create();
    }

    // Per-run flag (safe init)
    if (is_undefined(global._syntax_error_just_emitted)) global._syntax_error_just_emitted = false;
    global._syntax_error_just_emitted = false;

    // ── Build helpers that validators/dispatchers rely on ─────────────────
    build_data_streams();     // harvest DATA / prep READ/RESTORE
    build_if_block_map();     // multi-line IF/ELSE structure
    if (dbg_on(DBG_FLOW)) show_debug_message("IF-block map built (" + string(ds_map_size(global.if_block_map)) + " blocks)");

    // ── VALIDATE: visible errors + correct room ───────────────────────────
    // Assumes basic_validate_program() exists.
    if (!basic_validate_program()) {
        // Validator already printed a visible error & set end flags.
        // Ensure the user can see it.
        if (room != rm_basic_interpreter) room_goto(rm_basic_interpreter);
        return;
    }

    // ── Clean start: clear output buffers for a fresh run ─────────────────
    ds_list_clear(global.output_lines);
    ds_list_clear(global.output_colors);
    global.print_line_buffer = "";

    // ── Interpreter state ─────────────────────────────────────────────────
    global.interpreter_input    = "";
    global.awaiting_input       = false;
    global.input_target_var     = "";
    global.interpreter_running  = true;
    global.program_has_ended    = false;

    global.pause_in_effect      = false;
    global.pause_mode           = false;
    global.input_expected       = false;

    global.inkey_mode           = false;
    global.inkey_waiting        = false;
    global.inkey_captured       = "";
    global.inkey_target_var     = "";

    // Set draw color for this run (your existing choice)
    global.current_draw_color = make_color_rgb(255, 191, 64); // Amber

    // Line navigation
    global.interpreter_current_line_index = 0;
    global.interpreter_next_line          = -1;
    global.interpreter_use_stmt_jump      = false;
    global.interpreter_target_line        = -1;
    global.interpreter_target_stmt        = 0;
    global.interpreter_resume_stmt_index  = 0;
    global.current_line_number            = (ds_list_size(global.line_list) > 0)
                                           ? (global.line_list[| 0]) : -1;

    // Where to return when done
    global.editor_return_room = room;

    // Go to interpreter room (only if not already there)
    if (room != rm_basic_interpreter) room_goto(rm_basic_interpreter);
}


================================================================================

/// @file scripts/safe_real_pop/safe_real_pop.gml

function safe_real_pop(stack) {
    if (array_length(stack) < 1) return 1;

    var raw = array_pop(stack);

    // Pass through real values
    if (is_real(raw)) return raw;

    // Try to convert string safely
    var str = string(raw);
    var tryval = real(str);

    if (is_nan(tryval)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("? safe_real_pop: Cannot convert '" + string(raw) + "' to number. Returning 0.");
        return 0;
    }

    // Handle invalid conversions like real("RND:")
    if (!is_numeric_string(str)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("? POSTFIX ERROR: Cannot convert to number: '" + str + "'");
        return 1; // or return 0 if you prefer a neutral fallback
    }

    return tryval;
}


================================================================================

/// @file scripts/save_program/save_program.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function save_program() {
    if (current_filename == "") {
        show_error_message("NO FILENAME");
        return;
    }
    save_program_as(current_filename);
 }

================================================================================

/// @file scripts/save_program_as/save_program_as.gml

/// scripts/save_program/save_program.gml
/// Robust save: finds program lines from several common containers and writes them.
/// Logs exactly what was written (count + source), so we can confirm why a file went empty.

function save_program_as(filename)
{
    // --- Normalize filename
    filename = string_trim(filename);
    if (string_length(filename) == 0) { show_error_message("NO FILENAME PROVIDED"); return; }
    if (string_char_at(filename, 1) == "\"" && string_char_at(filename, string_length(filename)) == "\"") {
        filename = string_copy(filename, 2, string_length(filename)-2);
    }
    filename = string_replace_all(filename, "/", "_");
    filename = string_replace_all(filename, "\\", "_");
    filename = string_replace_all(filename, "..", "_");
    filename = string_replace_all(filename, ".bas", "");

    // --- Resolve save directory (desktop-first)
    var save_dir = get_save_directory();
    if (!is_string(save_dir) || string_length(save_dir) == 0) {
        save_dir = working_directory;
        var _last = string_copy(save_dir, string_length(save_dir), 1);
        if (_last != "/" && _last != "\\") save_dir += (os_type == os_windows) ? "\\" : "/";
       if (dbg_on(DBG_FLOW)) show_debug_message("FALLBACK save_dir -> '" + save_dir + "'");
    }
    if (os_type == os_windows || os_type == os_macosx || os_type == os_linux) {
        if (!directory_exists(save_dir)) directory_create(save_dir);
        if (!directory_exists(save_dir)) { show_error_message("COULD NOT CREATE SAVE FOLDER:\n" + string(save_dir)); return; }
    }

    var save_path = save_dir + filename + ".bas";
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE -> " + save_path);

    // --- Collect lines from likely sources
    var lines_list = ds_list_create(); // will hold strings to write, in order
    var source_used = "NONE";
    var ed = instance_find(obj_editor, 0);

    if (ed != noone) {
        // 1) obj_editor.program_lines (array)
        if (variable_instance_exists(ed, "program_lines") && is_array(ed.program_lines)) {
            for (var i = 0; i < array_length(ed.program_lines); i++) {
                ds_list_add(lines_list, string(ed.program_lines[i]));
            }
            if (ds_list_size(lines_list) > 0) source_used = "obj_editor.program_lines (array)";
        }

        // 2) obj_editor.program_lines (ds_list)
        if (source_used == "NONE" && variable_instance_exists(ed, "program_lines") &&
            ds_exists(ed.program_lines, ds_type_list)) {
            var n = ds_list_size(ed.program_lines);
            for (var j = 0; j < n; j++) {
                ds_list_add(lines_list, string(ds_list_find_value(ed.program_lines, j)));
            }
            if (n > 0) source_used = "obj_editor.program_lines (ds_list)";
        }

/// >>> INSERT START: 2c) obj_editor.program_lines (ds_map) <<<
        if (source_used == "NONE" && variable_instance_exists(ed, "program_lines") &&
            ds_exists(ed.program_lines, ds_type_map)) {

            // Gather keys
            var epl_keys = ds_list_create();
            var epl_k = ds_map_find_first(ed.program_lines);
            while (epl_k != undefined) {
                ds_list_add(epl_keys, epl_k);
                epl_k = ds_map_find_next(ed.program_lines, epl_k);
            }

            // Sort numerically if keys are numbers
            var epl_numeric = true;
            for (var ei = 0; ei < ds_list_size(epl_keys); ei++) {
                if (!is_real(ds_list_find_value(epl_keys, ei))) { epl_numeric = false; break; }
            }
            if (epl_numeric) ds_list_sort(epl_keys, true); // ascending

            // Emit "lineNum content" in key order
            for (var ej = 0; ej < ds_list_size(epl_keys); ej++) {
                var _ln  = ds_list_find_value(epl_keys, ej);
                var _val = ds_map_find_value(ed.program_lines, _ln);
                ds_list_add(lines_list, string(_ln) + " " + string(_val));
            }

            if (ds_list_size(lines_list) > 0) {
                source_used = "obj_editor.program_lines (ds_map)";
                if (dbg_on(DBG_IO)) show_debug_message("SAVE: pulled " + string(ds_list_size(lines_list)) + " lines from obj_editor.program_lines (map)");
            }
            ds_list_destroy(epl_keys);
        }
        /// <<< INSERT END <<<




        // 3) Common ds_map containers keyed by line numbers (we’ll join "lineNum + space + content")
        if (source_used == "NONE") {
            var map_names = [
                "program_map", "program_lines_map", "basic_program",
                "lines_map", "line_store", "program"
            ];
            for (var m = 0; m < array_length(map_names); m++) {
                var nm = map_names[m];
                if (variable_instance_exists(ed, nm) && ds_exists(ed[? nm], ds_type_map)) {
                    // Gather keys
                    var keys = ds_list_create();
                    var k = ds_map_find_first(ed[? nm]);
                    while (k != undefined) {
                        ds_list_add(keys, k);
                        k = ds_map_find_next(ed[? nm], k);
                    }
                    // Sort numerically if keys look like numbers
                    // (GameMaker sorts as strings; so we’ll bubble minimal numeric ordering)
                    var numeric = true;
                    for (var t = 0; t < ds_list_size(keys); t++) {
                        if (!is_real(ds_list_find_value(keys, t))) { numeric = false; break; }
                    }
                    if (numeric) ds_list_sort(keys, true); // ascending

                    // Emit "lineNum content" in key order
                    for (var t2 = 0; t2 < ds_list_size(keys); t2++) {
                        var _ln = ds_list_find_value(keys, t2);
                        var val = ds_map_find_value(ed[? nm], _ln);
                        // if val already includes line number, this will double it; but that’s rare.
                        ds_list_add(lines_list, string(_ln) + " " + string(val));
                    }
                    if (ds_list_size(lines_list) > 0) {
                        source_used = "obj_editor." + nm + " (ds_map)";
                        ds_list_destroy(keys);
                        break;
                    }
                    ds_list_destroy(keys);
                }
            }
        }
    }

    // 4) Global fallbacks
    if (source_used == "NONE" && variable_global_exists("program_lines")) {
        if (is_array(global.program_lines)) {
            for (var g1 = 0; g1 < array_length(global.program_lines); g1++) {
                ds_list_add(lines_list, string(global.program_lines[g1]));
            }
            if (ds_list_size(lines_list) > 0) source_used = "global.program_lines (array)";
        } else if (ds_exists(global.program_lines, ds_type_list)) {
            var gn = ds_list_size(global.program_lines);
            for (var g2 = 0; g2 < gn; g2++) {
                ds_list_add(lines_list, string(ds_list_find_value(global.program_lines, g2)));
            }
            if (gn > 0) source_used = "global.program_lines (ds_list)";
        }
    }
	
	/// >>> INSERT START: support global.program_lines when it's a MAP <<<
    if (source_used == "NONE" && variable_global_exists("program_lines") && ds_exists(global.program_lines, ds_type_map)) {
        var gpl_keys = ds_list_create();
        var gpl_k = ds_map_find_first(global.program_lines);
        while (gpl_k != undefined) {
            ds_list_add(gpl_keys, gpl_k);
            gpl_k = ds_map_find_next(global.program_lines, gpl_k);
        }
        // numeric-sort keys if they’re numbers
        var gpl_numeric = true;
        for (var gpi = 0; gpi < ds_list_size(gpl_keys); gpi++) {
            if (!is_real(ds_list_find_value(gpl_keys, gpi))) { gpl_numeric = false; break; }
        }
        if (gpl_numeric) ds_list_sort(gpl_keys, true);

        for (var gpj = 0; gpj < ds_list_size(gpl_keys); gpj++) {
            var gln  = ds_list_find_value(gpl_keys, gpj); // line number
            var gval = ds_map_find_value(global.program_lines, gln); // code
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        if (ds_list_size(lines_list) > 0) {
            source_used = "global.program_lines (ds_map)";
            if (dbg_on(DBG_IO)) show_debug_message("SAVE: pulled " + string(ds_list_size(lines_list)) + " lines from global.program_lines (map)");
        }
        ds_list_destroy(gpl_keys);
    }
    /// <<< INSERT END <<<
	
    if (source_used == "NONE" && variable_global_exists("program_map") && ds_exists(global.program_map, ds_type_map)) {
        var gkeys = ds_list_create();
        var gk = ds_map_find_first(global.program_map);
        while (gk != undefined) { ds_list_add(gkeys, gk); gk = ds_map_find_next(global.program_map, gk); }
        var gnum = true;
        for (var gg = 0; gg < ds_list_size(gkeys); gg++) if (!is_real(ds_list_find_value(gkeys, gg))) { gnum = false; break; }
        if (gnum) ds_list_sort(gkeys, true);
        for (var gh = 0; gh < ds_list_size(gkeys); gh++) {
            var gln = ds_list_find_value(gkeys, gh);
            var gval = ds_map_find_value(global.program_map, gln);
            ds_list_add(lines_list, string(gln) + " " + string(gval));
        }
        if (ds_list_size(lines_list) > 0) source_used = "global.program_map (ds_map)";
        ds_list_destroy(gkeys);
    }

    // --- Diagnostics before writing
    var total = ds_list_size(lines_list);
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE SOURCE -> " + source_used + " | lines=" + string(total));
    if (total > 0) {
        // show first couple lines for verification
        var preview_max = min(3, total);
        for (var pv = 0; pv < preview_max; pv++) {
           if (dbg_on(DBG_FLOW)) show_debug_message("LINE[" + string(pv) + "] -> " + string(ds_list_find_value(lines_list, pv)));
        }
    }

    // --- Open file and write
    var fh = file_text_open_write(save_path);
    if (fh < 0) { show_error_message("COULD NOT OPEN FILE FOR WRITE:\n" + filename + ".bas"); ds_list_destroy(lines_list); return; }

    for (var w = 0; w < total; w++) {
        file_text_write_string(fh, string(ds_list_find_value(lines_list, w)));
        file_text_writeln(fh); // newline
    }
    file_text_close(fh);

    var exists_after = file_exists(save_path);
   if (dbg_on(DBG_FLOW)) show_debug_message("SAVE EXISTS AFTER -> " + string(exists_after));

    if (total == 0) {
        show_error_message("NOTHING TO SAVE — no program lines found");
    } else if (!exists_after) {
        show_error_message("SAVE REPORTED OK BUT FILE NOT FOUND:\n" + save_path);
    } else if (ed != noone && variable_instance_exists(ed, "status_message")) {
        ed.status_message = "FILE SAVED: " + filename + ".bas (" + string(total) + " lines)";
    }

    ds_list_destroy(lines_list);
}


================================================================================

/// @file scripts/save_program_json/save_program_json.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function save_program_json(filename) {
    try {
        var save_data = ds_map_create();
        ds_map_copy(save_data, global.program_lines);
        
        var json_string = json_encode(save_data);
        var file_path = working_directory + filename + ".json";
        var file = file_text_open_write(file_path);
        file_text_write_string(file, json_string);
        file_text_close(file);
        
        ds_map_destroy(save_data);
        basic_show_message("SAVED: " + filename + " (JSON)");
    } catch (e) {
        show_error_message("JSON SAVE ERROR");
    }
 }

================================================================================

/// @file scripts/save_undo_state/save_undo_state.gml

function save_undo_state() {
    // Placeholder for undo system
    // Eventually, you could push a copy of global.program_lines to a stack
	/// TODO: Implement undo functionality for BASIC editor
/// --------------------------------------------------
/// This function should snapshot the current program state so it can be restored later via an "UNDO" command.
/// A stack-based approach is recommended, where each saved state is pushed onto a list (e.g., global.undo_stack).
///
/// Suggested structure per snapshot:
/// - A ds_map with keys like "global.program_lines", "global.line_numbers", and optionally "cursor_pos"
/// - Each key maps to a *copy* (not a reference) of the original ds_map or ds_list
///
/// Pseudocode for future implementation:
/// ```gml
/// var snapshot = ds_map_create();
/// ds_map_add_list(snapshot, "global.line_numbers", ds_list_copy(global.line_numbers));
/// ds_map_add_map(snapshot, "global.program_lines", ds_map_copy(global.program_lines));
/// ds_stack_push(global.undo_stack, snapshot);
/// ```
///
/// Don't forget to:
/// - Create `global.undo_stack` once during initialization (e.g., in obj_globals)
/// - Clean up with `ds_map_destroy()` and `ds_list_destroy()` when popping or discarding states
///
/// For now, this is a placeholder to suppress runtime errors.

}


================================================================================

/// @file scripts/screen_editor_clear_row/screen_editor_clear_row.gml

// ===============================================
// FILE: scripts/screen_editor_clear_row/screen_editor_clear_row.gml
// NEW: Helper function to clear a display row
// ===============================================

/// @function screen_editor_clear_row(editor_inst, _row)
function screen_editor_clear_row(editor_inst, _row) {
    with (editor_inst) {
        if (_row < 0 || _row >= screen_rows) return;
        for (var _x = 0; _x < screen_cols; _x++) {
            screen_editor_set_char_at(id, _x, _row, ord(" "));
        }
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cleared row " + string(_row));
    }
}

================================================================================

/// @file scripts/screen_editor_commit_row/screen_editor_commit_row.gml

// FILE: scripts/screen_editor_commit_row/screen_editor_commit_row.gml
/// @function screen_editor_commit_row(editor_inst, _row)
function screen_editor_commit_row(editor_inst, _row) {
    with (editor_inst) {
        var line_text = string_trim(screen_editor_get_row_text(id, _row));
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Committing row " + string(_row) + ": '" + line_text + "'");
        
        if (line_text == "") return;
        
        // Check for EXIT command
        if (string_upper(line_text) == "EXIT") {
            screen_editor_exit(id);
            return;
        }
        
        // Parse line number and code
        var space_pos = string_pos(" ", line_text);
        var line_num_str = "";
        var code = "";
        
        if (space_pos > 0) {
            line_num_str = string_copy(line_text, 1, space_pos - 1);
            code = string_trim(string_copy(line_text, space_pos + 1, string_length(line_text)));
        } else {
            line_num_str = line_text;
        }
        
        // Check if it's a valid line number
        var line_num = real(line_num_str);
        if (line_num_str != "" && is_real(line_num) && line_num > 0) {
            if (code == "") {
                // Delete line
                delete_program_line(line_num);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Deleted line " + string(line_num));
            } else {
                // Add/update line
                add_or_update_program_line(line_num, code);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Added/updated line " + string(line_num) + ": " + code);
            }
        }
    }
}

================================================================================

/// @file scripts/screen_editor_commit_row_extended/screen_editor_commit_row_extended.gml

// ===============================================
// FILE: scripts/screen_editor_commit_row_extended/screen_editor_commit_row_extended.gml
// NEW: Modified commit function that accepts full line text
// ===============================================

/// @function screen_editor_commit_row_extended(editor_inst, _row, line_text)
function screen_editor_commit_row_extended(editor_inst, _row, line_text) {
    with (editor_inst) {
        var trimmed_text = string_trim(line_text);
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Committing row " + string(_row) + ": '" + trimmed_text + "'");
        
        if (trimmed_text == "") return;
        
        if (string_upper(trimmed_text) == "EXIT") {
            screen_editor_exit(id);
            return;
        }
        
        var space_pos = string_pos(" ", trimmed_text);
        var line_num_str = "";
        var code = "";
        
        if (space_pos > 0) {
            line_num_str = string_copy(trimmed_text, 1, space_pos - 1);
            code = string_trim(string_copy(trimmed_text, space_pos + 1, string_length(trimmed_text)));
        } else {
            line_num_str = trimmed_text;
        }
        
        var line_num = real(line_num_str);
        if (line_num_str != "" && is_real(line_num) && line_num > 0) {
            if (code == "") {
                delete_program_line(line_num);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Deleted line " + string(line_num));
            } else {
                add_or_update_program_line(line_num, code);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Added/updated line " + string(line_num) + ": " + code);
            }
        }
    }
}

================================================================================

/// @file scripts/screen_editor_display_line/screen_editor_display_line.gml

/// @function screen_editor_display_line(editor_inst, line_text, screen_row)
function screen_editor_display_line(editor_inst, line_text, screen_row) {
    with (editor_inst) {
        // Clear the row first
        for (var clear_x = 0; clear_x < screen_cols; clear_x++) {
            screen_editor_set_char_at(id, clear_x, screen_row, ord(" "));
        }
        
        // Apply horizontal offset only to cursor line
        var display_text = line_text;
        if (screen_row == cursor_y && horizontal_offset > 0) {
            display_text = string_copy(line_text, horizontal_offset + 1, screen_cols);
        }
        
        // Display the text
        var text_len = min(string_length(display_text), screen_cols);
        for (var j = 1; j <= text_len; j++) {
            var ch = string_char_at(display_text, j);
            screen_editor_set_char_at(id, j - 1, screen_row, ord(ch));
        }
        
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Displayed line " + string(screen_row) + 
                          (screen_row == cursor_y ? " (with offset " + string(horizontal_offset) + ")" : " (no offset)"));
    }
}

================================================================================

/// @file scripts/screen_editor_exit/screen_editor_exit.gml

function screen_editor_exit(editor_inst) {
    with (editor_inst) {
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Exiting screen editor");
        global.screen_edit_mode = false;
        
        // CRITICAL: Clear keyboard_string to prevent leakage to obj_editor
        keyboard_string = "";
       if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Cleared keyboard_string");
        
        instance_destroy();
    }
}

================================================================================

/// @file scripts/screen_editor_get_char_at/screen_editor_get_char_at.gml

// FILE: scripts/screen_editor_get_char_at/screen_editor_get_char_at.gml
/// @function screen_editor_get_char_at(editor_inst, _x, _y)
function screen_editor_get_char_at(editor_inst, _x, _y) {
    with (editor_inst) {
        if (_x < 0 || _x >= screen_cols || _y < 0 || _y >= screen_rows) return ord(" ");
        var idx = _y * screen_cols + _x;
        return screen_buffer[idx];
    }
}

================================================================================

/// @file scripts/screen_editor_get_row_text/screen_editor_get_row_text.gml

// FILE: scripts/screen_editor_get_row_text/screen_editor_get_row_text.gml
/// @function screen_editor_get_row_text(editor_inst, _row)
function screen_editor_get_row_text(editor_inst, _row) {
    with (editor_inst) {
        if (_row < 0 || _row >= screen_rows) return "";
        
        var text = "";
        var last_non_space = -1;
        
        for (var _x = 0; _x < screen_cols; _x++) {
            var ch = chr(screen_editor_get_char_at(id, _x, _row));
            text += ch;
            if (ch != " ") last_non_space = _x;
        }
        
        return (last_non_space >= 0) ? string_copy(text, 1, last_non_space + 1) : "";
    }
}

================================================================================

/// @file scripts/screen_editor_load_program/screen_editor_load_program.gml

// FILE: scripts/screen_editor_load_program/screen_editor_load_program.gml
/// @function screen_editor_load_program(editor_inst)
function screen_editor_load_program(editor_inst) {
    with (editor_inst) {
        //show_debug_message("SCREEN_EDITOR: Loading program to screen (scroll_offset=" + string(scroll_offset) + ")");
        
        // Clear screen first
        for (var i = 0; i < array_length(screen_buffer); i++) {
            screen_buffer[i] = ord(" ");
        }
        
        // Load program lines with scroll offset
        var total_lines = ds_list_size(global.line_numbers);
        var screen_row = 0;
        
        // Start from scroll_offset instead of 0
		for (var i = scroll_offset; i < total_lines && screen_row < screen_rows; i++) {
		    var line_num = ds_list_find_value(global.line_numbers, i);
		    var code = ds_map_find_value(global.program_lines, line_num);
		    var line_text = string(line_num) + " " + code;
    
		    // Apply horizontal offset ONLY to the current cursor line
		    var display_text = line_text;
		if (screen_row == cursor_y && horizontal_offset > 0) {
		    // Only scroll the line where the cursor currently is
		    display_text = string_copy(line_text, horizontal_offset + 1, screen_cols);
		    //show_debug_message("SCREEN_EDITOR: Applying h_offset=" + string(horizontal_offset) + " to cursor line " + string(cursor_y));
		}
            
		// Place line text on screen
		var text_len = min(string_length(display_text), screen_cols);  // Use display_text
		for (var j = 1; j <= text_len; j++) {
		    var ch = string_char_at(display_text, j);  // Use display_text
		    screen_editor_set_char_at(id, j - 1, screen_row, ord(ch));
		}
            
            screen_row++;
        }
        
        //show_debug_message("SCREEN_EDITOR: Loaded " + string(screen_row) + " lines starting from offset " + string(scroll_offset));
    }
}

================================================================================

/// @file scripts/screen_editor_set_char_at/screen_editor_set_char_at.gml

// FILE: scripts/screen_editor_set_char_at/screen_editor_set_char_at.gml
/// @function screen_editor_set_char_at(editor_inst, _x, _y, _char)
function screen_editor_set_char_at(editor_inst, _x, _y, _char) {
    with (editor_inst) {
        if (_x < 0 || _x >= screen_cols || _y < 0 || _y >= screen_rows) return;
        var idx = _y * screen_cols + _x;
        screen_buffer[idx] = _char;
        //show_debug_message("SCREEN_EDITOR: Set char '" + chr(_char) + "' at (" + string(_x) + "," + string(_y) + ")");
    }
}

================================================================================

/// @file scripts/Script149/Script149.gml



================================================================================

/// @file scripts/Script160/Script160.gml



================================================================================

/// @file scripts/Script161/Script161.gml



================================================================================

/// @file scripts/Script163/Script163.gml



================================================================================

/// @file scripts/set_color_scheme/set_color_scheme.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function set_color_scheme(scheme) {
    scheme = string_upper(scheme);
    switch (scheme) {
        case "GREEN":
            keyword_color = c_lime;
            text_color = c_green;
            number_color = c_yellow;
            break;
        case "BLUE":
            keyword_color = c_cyan;
            text_color = c_blue;
            number_color = c_white;
            break;
        case "AMBER":
            keyword_color = c_orange;
            text_color = c_yellow;
            number_color = c_white;
            break;
        default:
            show_error_message("UNKNOWN COLOR SCHEME");
            return;
    }
    basic_show_message("COLOR SCHEME: " + scheme);
    update_display();
 }

================================================================================

/// @file scripts/set_full_line_text/set_full_line_text.gml

// ===============================================
// FILE: scripts/set_full_line_text/set_full_line_text.gml  
// NEW: Helper function to store complete line text
// ===============================================

/// @function set_full_line_text(editor_inst, row, text)
function set_full_line_text(editor_inst, row, text) {
    with (editor_inst) {
        if (string_length(text) > screen_cols) {
            extended_lines[? row] = text;
           if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Stored extended line " + string(row) + ": '" + text + "'");
        } else {
            // Remove from extended storage if line is now short
            if (ds_map_exists(extended_lines, row)) {
                ds_map_delete(extended_lines, row);
               if (dbg_on(DBG_FLOW)) show_debug_message("SCREEN_EDITOR: Removed extended line " + string(row) + " (now fits on screen)");
            }
        }
    }
}

================================================================================

/// @file scripts/show_current_colors/show_current_colors.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_current_colors() {
    basic_show_message("CURRENT SCHEME - USE: COLOR GREEN/BLUE/AMBER");
 }

================================================================================

/// @file scripts/show_error_message/show_error_message.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_error_message(error) {
    basic_show_message("?" + error);
 }

================================================================================

/// @file scripts/show_stat_message/show_stat_message.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function show_stat_message(msg) {
    message_text = msg;
    message_timer = 120; // Show for 2 seconds at 60 FPS
 }

================================================================================

/// @file scripts/split_on_unquoted_colons/split_on_unquoted_colons.gml

/// @function split_on_unquoted_colons(line)
/// @description Split a line on top-level colons, ignoring any inside "quoted strings"
function split_on_unquoted_colons(line) {
    var parts = [];
    var buf    = "";
    var inStr  = false;
    var len    = string_length(line);
    for (var i = 1; i <= len; i++) {
        var ch = string_char_at(line, i);
        if (ch == "\"") {
            // toggle string state and keep the quote
            inStr = !inStr;
            buf  += ch;
        }
        else if (ch == ":" && !inStr) {
            // top-level colon → break here
            array_push(parts, buf);
            buf = "";
        }
        else {
            buf += ch;
        }
    }
    // push whatever’s left
    array_push(parts, buf);
    return parts;
}


================================================================================

/// @file scripts/split_on_unquoted_commas/split_on_unquoted_commas.gml

/// @func split_on_unquoted_commas(s)
/// @desc Split a string on commas that are OUTSIDE quotes (and outside parentheses),
///       mirroring your colon-splitter behavior. Keeps empty fields trimmed out.
///       Examples:
///         split_on_unquoted_commas("1,2,\"a,b\",3") -> ["1","2","\"a,b\"","3"]
///         split_on_unquoted_commas("A(1,2),B")      -> ["A(1,2)","B"]
function split_on_unquoted_commas(s) {
    var parts = [];
    if (s == undefined) return parts;

    var L = string_length(s);
    var in_q = false;
    var _depth = 0;     // parentheses depth for safety (DATA can contain A(…), keep it intact)
    var start = 1;

    for (var i = 1; i <= L; i++) {
        var ch = string_char_at(s, i);

        if (ch == "\"") {
            // Handle doubled quotes "" inside strings -> treat as escaped, stay in same quote state
            var nxt = (i < L) ? string_char_at(s, i + 1) : "";
            if (in_q && nxt == "\"") { i++; continue; }
            in_q = !in_q;
            continue;
        }

        if (!in_q) {
            if (ch == "(") { _depth++; continue; }
            if (ch == ")") { _depth = max(0, _depth - 1); continue; }
            if (ch == "," && _depth == 0) {
                var seg = string_trim(string_copy(s, start, i - start));
                if (seg != "") parts[array_length(parts)] = seg;
                start = i + 1;
            }
        }
    }

    // tail
    var tail = string_trim(string_copy(s, start, L - start + 1));
    if (tail != "") parts[array_length(parts)] = tail;

    if (dbg_on && is_undefined(dbg_on) == false) {} // no-op to avoid warnings if dbg_on is macro
    if (dbg_on(DBG_FLOW)) show_debug_message("split_on_unquoted_commas('" + s + "') -> " + string(parts));

    return parts;
}


================================================================================

/// @file scripts/split_on_unquoted_semicolons/split_on_unquoted_semicolons.gml

function split_on_unquoted_semicolons(s) {
    var result = [];
    var current = "";
    var in_string = false;
    for (var i = 1; i <= string_length(s); i++) {
        var c = string_char_at(s, i);
        if (c == "\"") in_string = !in_string;
        if (c == ";" && !in_string) {
            array_push(result, string_trim(current));
            current = "";
        } else {
            current += c;
        }
    }
    if (string_length(current) > 0) array_push(result, string_trim(current));
    return result;
}


================================================================================

/// @file scripts/start_screen_editor/start_screen_editor.gml

// FILE: scripts/start_screen_editor/start_screen_editor.gml
/// @function start_screen_editor()
/// @description Launch the full-screen C64-style editor

function start_screen_editor() {
   if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: start_screen_editor called");
    
    if (global.screen_edit_mode) {
       if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: Screen editor already active");
        basic_show_message("Screen editor already active");
        return;
    }
    
   if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND: Setting screen_edit_mode = true and creating obj_screen_editor");
    global.screen_edit_mode = true;
    instance_create_layer(0, 0, "Instances", obj_screen_editor);
    
    basic_show_message("Entering screen edit mode...");
}

================================================================================

/// @file scripts/string_is_number/string_is_number.gml

/// @function string_is_number(str)
/// @desc Returns true if the input string can be safely converted to a number.
/// @param {string} str - The string to check
function string_is_number(str) {
    if (is_real(str)) return true; // Already a number
    var trimmed = string_trim(str);
    if (trimmed == "") return false;

    var dot_found = false;
    var start = 1;

    // Allow for optional leading minus sign
    if (string_char_at(trimmed, 1) == "-") {
        if (string_length(trimmed) == 1) return false;
        start = 2;
    }

    for (var i = start; i <= string_length(trimmed); i++) {
        var ch = string_char_at(trimmed, i);
        if (ch >= "0" && ch <= "9") continue;
        else if (ch == ".") {
            if (dot_found) return false; // only one dot allowed
            dot_found = true;
        } else {
            return false;
        }
    }

    return true;
}


================================================================================

/// @file scripts/strip_basic_remark/strip_basic_remark.gml

/// Remove single quote comments, unless inside double quotes
function strip_basic_remark(arg) {
    var len = string_length(arg);
    var inside_string = false;

    for (var i = 1; i <= len; i++) {
        var c = string_char_at(arg, i);

        if (c == "\"") {
            inside_string = !inside_string;
        }
        else if (c == "'" && !inside_string) {
            // Found unquoted remark start – strip everything after
            return string_trim(string_copy(arg, 1, i - 1));
        }
    }

    // No unquoted remark found – return original
    return arg;
}


================================================================================

/// @file scripts/toggle_syntax_highlighting/toggle_syntax_highlighting.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function toggle_syntax_highlighting() {
    syntax_highlighting = !syntax_highlighting;
    basic_show_message("SYNTAX HIGHLIGHTING: " + (syntax_highlighting ? "ON" : "OFF"));
    update_display();
 }


================================================================================

/// @file scripts/tokenize_expression/tokenize_expression.gml

function tokenize_expression(expr) {
    var tokens = [];
    var i = 1;
    while (i <= string_length(expr)) {
        var ch = string_char_at(expr, i);

        if (ch == " " || ch == "\t") {
            i++;
            continue;
        }

        if (ch == "+" || ch == "-" || ch == "*" || ch == "/" || ch == "^" || ch == "(" || ch == ")") {
            array_push(tokens, ch);
            i++;
        }
        else if (ord(ch) >= 48 && ord(ch) <= 57) {
            var num = "";
            while (i <= string_length(expr) && (ord(string_char_at(expr, i)) >= 48 && ord(string_char_at(expr, i)) <= 57)) {
                num += string_char_at(expr, i);
                i++;
            }
            array_push(tokens, num);
        }
        else if (is_letter(ch)) {
            var ident = "";
            while (i <= string_length(expr) && (is_letter_or_digit(string_char_at(expr, i)))) {
                ident += string_char_at(expr, i);
                i++;
            }
            if (string_char_at(expr, i) == "(") {
                array_push(tokens, ident); // Function name
            } else {
                array_push(tokens, ident); // Variable
            }
        }
        else if (ch == ",") {
            array_push(tokens, ",");
            i++;
        }
        else {
            if (dbg_on(DBG_FLOW)) show_debug_message("Unknown character in expression: " + ch);
            i++;
        }
    }

    return tokens;
}



================================================================================

/// @file scripts/update_display/update_display.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
 function update_display() {
    // This will be called in the Draw event
 }
 

================================================================================
