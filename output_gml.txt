/// @file objects/obj_basic_interpreter/Create_0.gml

/// @event obj_basic_interpreter/Create

    global.debug_mask        = DBG_ALL;//0;//DBG_ALL;   // start verbose; you can trim later
    global.dbg_frame_quota   = 0;      // 1200 is ~20 logs per ms at 60fps is ok; tune as needed
    global.dbg_frame_count   = 0;
    global.dbg_dropped_count = 0;

// Set the current draw color
global.current_draw_color = global.basic_text_color;

// Use the shared global data structures
global.program_map  = global.basic_program; // optional if you're not modifying
global.line_list    = global.basic_line_numbers;

// Interpreter control variables
line_index = 0;                         // current line being executed
font_height = 16;

current_input = "";
cursor_pos = 0;
last_keyboard_string = "";

global.interpreter_current_line_index = 0;
global.interpreter_next_line = -1;

// Local list to hold current run if needed
interpreter_current_program = ds_list_create(); // OK to keep local

basic_run_to_console_flag = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
    global.help_topics = ds_list_create();
} else {
    ds_list_clear(global.help_topics);
}

// PRINT tab stop width (classic BASIC style)
if (is_undefined(global.print_zone)) global.print_zone = 14;




================================================================================

/// @file objects/obj_basic_interpreter/Step_0.gml

/// @event obj_basic_interpreter/Step
// ==============================
// obj_basic_interpreter → Step Event
// ==============================

// (Optional debug tap)
// if (keyboard_check_pressed(vk_enter)) {
//     show_debug_message("ENTER pressed - pause_in_effect: " + string(global.pause_in_effect) +
//                        ", awaiting_input: " + string(global.awaiting_input) +
//                        ", pause_mode: " + string(global.pause_mode));
// }

// ---------- Feed INKEY$ queue once per frame ----------
// (The function itself arbitrates INPUT vs. INKEY modal wait.)
inkey_capture_keys();

global.dbg_frame_count = 0;
if (global.dbg_dropped_count > 0) {
    if (dbg_on(DBG_PERF)) show_debug_message("DBG: dropped " + string(global.dbg_dropped_count) + " lines this frame");
    global.dbg_dropped_count = 0;
}

// ==============================
// Sort program lines in ascending order
// ==============================
if (ds_exists(global.line_list, ds_type_list)) {
    ds_list_sort(global.line_list, true);
}

// ==============================
// === Program Ended: Wait for user action ===
// ==============================
if (global.program_has_ended) {
    if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
    if (keyboard_check_pressed(vk_pagedown)) {
        var font_height = string_height("A");
        var visible_lines = floor(room_height / font_height) - 2;
        var total_lines = ds_list_size(global.output_lines);
        global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines - visible_lines));
    }

    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {

        // ==== INSERTED HELP RESTORE HOOK ====
        if (variable_global_exists("help_active") && global.help_active) {
            help_restore_program();   // puts the user's code back
            global.help_active = false;
        }
        // ==== END INSERT ====

        global.program_has_ended = false;
        global.current_mode = 0;

        var _ret = variable_global_exists("editor_return_room")
               ? global.editor_return_room
               : room_first; // fallback if something goes weird

        room_goto(_ret);
    }
    return;
}


// ==============================
// INPUT mode (line editor) routing — keep your working flow
// ==============================
if (global.awaiting_input) {
    if (global.pause_mode) {
        if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: ENTER/ESC detected, resuming...");
            global.awaiting_input   = false;
            global.pause_mode       = false;
            global.pause_in_effect  = false;
            global.input_target_var = "";
            global.interpreter_input = "";
            global.interpreter_resume_stmt_index = global.interpreter_current_stmt_index + 1;
        }
    } else {
        for (var _k = 32; _k <= 126; _k++) if (keyboard_check_pressed(_k)) handle_interpreter_character_input(_k);
        if (keyboard_check_pressed(vk_enter))     handle_interpreter_character_input(vk_enter);
        if (keyboard_check_pressed(vk_backspace)) handle_interpreter_character_input(vk_backspace);
    }
    return;
}

// ==============================
// INKEY$ modal wait handler (blocking GET-style)
// Armed by LET when RHS is pure INKEY$ (your basic_cmd_let should set:
//   global.inkey_waiting = true; global.pause_in_effect = true;)
// This handler captures ONE key, stashes it, and lets the same LET re-run next frame.
// ==============================
if (global.inkey_waiting) {
    // If we ALREADY have a captured char, DO NOT pause or return here.
    // Let the interpreter proceed so LET ... = INKEY$ can commit and clear flags.
    if (string_length(global.inkey_captured) > 0) {
        global.pause_in_effect = false; // allow interpreter to advance
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: resume for commit (cached='" + global.inkey_captured + "')");
        // NOTE: NO 'return' here — fall through to the interpreter loop
    } else {
        // Try to obtain exactly one key this frame
        var _ch = "";

        // Prefer queued key captured by inkey_capture_keys()
        if (ds_exists(global.__inkey_queue, ds_type_queue) && ds_queue_size(global.__inkey_queue) > 0) {
            _ch = ds_queue_dequeue(global.__inkey_queue);
            if (is_real(_ch)) _ch = chr(_ch);
        }

        // Fallback: direct pressed-edge scan this frame
        if (_ch == "") {
            for (var _kc = 32; _kc <= 126; _kc++) {
                if (keyboard_check_pressed(_kc)) { _ch = chr(_kc); break; }
            }
        }

        if (_ch != "") {
            // Stash and allow interpreter to proceed THIS frame to re-run LET
            global.inkey_captured  = string(_ch);
            global.pause_in_effect = false;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: captured '" + global.inkey_captured + "', resuming for commit");
            // NOTE: NO 'return' here — fall through to the interpreter loop
        } else {
            // Nothing yet: keep interpreter paused and try again next frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY WAIT: still waiting for key");
            return; // only return when we truly don't have a key this frame
        }
    }
}

// ==============================
// Synchronize for structured IF…ELSE handling
// ==============================
global.interpreter_current_line_index = line_index;

// ==============================
// Handle Jumps (prefer legacy line jump)
// ==============================
if (global.interpreter_next_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: legacy line jump wins → line=" + string(global.interpreter_next_line));
    line_index = global.interpreter_next_line;
    global.interpreter_current_line_index = global.interpreter_next_line;
    global.interpreter_resume_stmt_index = 0;

    // Clear any stale statement-level jump
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line   = -1;
    global.interpreter_target_stmt   = 0;

    global.interpreter_next_line = -1;
} else if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
    if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: using statement-level jump → line=" + string(global.interpreter_target_line) + ", stmt=" + string(global.interpreter_target_stmt));
    line_index = global.interpreter_target_line;
    global.interpreter_current_line_index = global.interpreter_target_line;
    global.interpreter_resume_stmt_index = max(0, global.interpreter_target_stmt);
    global.interpreter_use_stmt_jump = false;
    global.interpreter_target_line = -1;
    global.interpreter_target_stmt = 0;
    global.interpreter_next_line = -1;
}

// ==============================
// End of Program Check
// ==============================
if (line_index >= ds_list_size(global.line_list)) {
    global.interpreter_running = false;
}

// ==============================
// Execute BASIC Line
// ==============================
if (line_index < ds_list_size(global.line_list)) {
    var line_number = ds_list_find_value(global.line_list, line_index);
    var code        = ds_map_find_value(global.program_map, line_number);

    var trimmed = string_trim(code);
    var parts   = split_on_unquoted_colons(trimmed);

    global.current_line_number = line_number;
    if (dbg_on(DBG_FLOW)) show_debug_message("Running line " + string(line_number));

    var _start_stmt = 0;
    if (global.interpreter_resume_stmt_index > 0) {
        _start_stmt = global.interpreter_resume_stmt_index;
        if (dbg_on(DBG_FLOW)) show_debug_message("Resuming at statement index " + string(_start_stmt)
            + " on line " + string(line_number));
        global.interpreter_resume_stmt_index = 0;
    }

    for (var p = _start_stmt; p < array_length(parts); p++) {
        var stmt = string_trim(parts[p]);
        if (stmt == "") continue;

        var sp2  = string_pos(" ", stmt);
        var cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        var arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        // REM / apostrophe: stop the physical line
        if (cmd2 == "REM" || string_char_at(stmt, 1) == "'") {
            if (dbg_on(DBG_FLOW)) {
                show_debug_message("REM/' : stop parsing remainder of line "
                    + string(line_number) + " at part " + string(p) + "/"
                    + string(array_length(parts) - 1));
            }
            break;
        }

        // Strip inline remark then recompute verb/arg
        stmt = strip_basic_remark(stmt);
        sp2  = string_pos(" ", stmt);
        cmd2 = (sp2 > 0) ? string_upper(string_copy(stmt, 1, sp2 - 1)) : string_upper(stmt);
        arg2 = (sp2 > 0) ? string_trim(string_copy(stmt, sp2 + 1, string_length(stmt))) : "";

        global.interpreter_current_stmt_index = p;

        if (dbg_on(DBG_FLOW)) show_debug_message("Command: " + cmd2 + " | Arg: " + arg2);
        handle_basic_command(cmd2, arg2);

        // If a pause was armed (e.g., modal INKEY$), stop RIGHT HERE
        if (global.pause_in_effect) {
            global.interpreter_resume_stmt_index = p; // retry this colon slot next frame
            if (dbg_on(DBG_FLOW)) show_debug_message("PAUSE: engaged during statement; will retry stmt index " + string(p) + " next frame");
            break;
        }

        // Prefer legacy line jump; clear stale stmt-level flags
        if (global.interpreter_next_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for LEGACY LINE jump");
            global.interpreter_use_stmt_jump = false;
            global.interpreter_target_line   = -1;
            global.interpreter_target_stmt   = 0;
            break;
        }
        if (global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0) {
            if (dbg_on(DBG_FLOW)) show_debug_message("IFJUMP: breaking line loop for STATEMENT-LEVEL jump request");
            break;
        }
    }

    // If no jump requested and NOT paused, advance to next line
    if (!(global.interpreter_use_stmt_jump && global.interpreter_target_line >= 0)
     && !(global.interpreter_next_line >= 0)
     && !global.pause_in_effect) {
        line_index++;
    }
} else {
    global.interpreter_running = false;
}

// ==============================
// Escape Returns to Editor
// ==============================
if (keyboard_check_pressed(vk_escape)) {
    global.current_mode = 0;
    room_goto(global.editor_return_room);
}

// ==============================
// F5 Dumps BASIC to Console
// ==============================
if (keyboard_check_released(vk_f5) && basic_run_to_console_flag == false) {
    basic_run_to_console_flag = true;
    basic_run_to_console();
}

// ==============================
// Manual Scroll (Always Available)
// ==============================
if (keyboard_check_pressed(vk_pageup))   global.scroll_offset = max(global.scroll_offset - 1, 0);
if (keyboard_check_pressed(vk_pagedown)) {
    var font_height2 = string_height("A");
    var visible_lines2 = floor(room_height / font_height2) - 2;
    var total_lines2 = ds_list_size(global.output_lines) + (global.awaiting_input ? 1 : 0);
    global.scroll_offset = min(global.scroll_offset + 1, max(0, total_lines2 - visible_lines2));
}

// (Legacy path retained; harmless with new flow)
if (global.pause_in_effect && global.inkey_mode) {
    handle_inkey_input();
}
// === END: obj_basic_interpreter.Step ===


================================================================================

/// @file objects/obj_globals/Create_0.gml

/// @event obj_globals/Create
// obj_globals → Create Event



var save_dir = get_save_directory();
if (save_dir != "") {
    if (!directory_exists(save_dir)) {
        directory_create(save_dir);
    }
}

//global.debug_mask = DBG_ALL;// allow all debug;
global.debug_mask = 0; //No Debug

global.dbg_dropped_count = 0;

global.justreturned = 0;
global.program_filename = "";
global.username = "";
global.editor_spawned = false;

// Program and source management
global.program_lines = ds_map_create();
global.basic_program = ds_map_create();
global.program_map  = ds_map_create();

// Line tracking
global.line_list    = ds_list_create();
global.line_numbers = ds_list_create();
global.undo_stack = ds_list_create();
global.output_lines = ds_list_create();
global.output_colors = ds_list_create();
global.input_history = ds_list_create();

// Interpreter control stacks
global.gosub_stack = ds_stack_create();
global.for_stack   = ds_stack_create();
global.while_stack = ds_stack_create();
global.history_index = -1;

// IF…ELSE block handling
global.if_block_map = ds_map_create();
global.if_stack     = ds_stack_create();

// Spawn the editor after globals are ready
instance_create_layer(0, 0, "Instances", obj_editor);

// Initialize variable store
if (!variable_global_exists("basic_variables")) {
    global.basic_variables = ds_map_create();
}

// Output buffer
global.print_line_buffer = "";

// Color settings
global.basic_text_color = make_color_rgb(255, 191, 64);
global.current_draw_color = c_green;
global.background_draw_color = c_black;
global.background_draw_enabled = false;

// Input / Pause
global.awaiting_input = false;
global.input_target_var = "";
global.interpreter_input = "";
global.interpreter_cursor_pos = 0;
global.interpreter_running = false;
global.last_interpreter_string = "";
global.program_has_ended = false;
global.pause_in_effect = false;
global.input_expected = false;
global.pause_mode = false;

// Scrolling control
global.scroll_offset = 0;
global.scroll_lock = false;

// Named colors
global.colors = ds_map_create();
global.colors[? "RED"]     = c_red;
global.colors[? "GREEN"]   = c_green;
global.colors[? "BLUE"]    = c_blue;
global.colors[? "CYAN"]    = c_teal;
global.colors[? "MAGENTA"] = c_fuchsia;
global.colors[? "YELLOW"]  = c_yellow;
global.colors[? "WHITE"]   = c_white;
global.colors[? "BLACK"]   = c_black;
global.colors[? "GRAY"]    = c_gray;
global.colors[? "ORANGE"]  = c_orange;
global.colors[? "LIME"]    = c_lime;
global.colors[? "NAVY"] = make_color_rgb(0, 0, 128);
global.colors[? "DKGRAY"] = make_color_rgb(64, 64, 64);

// MODE control
global.current_mode = 0; // 0 = Text, 1 = Tile graphics, 2 = Pixel graphics
global.mode_rooms = ds_map_create();
global.mode_rooms[? 0] = rm_basic_interpreter; // Text
global.mode_rooms[? 1] = rm_mode1_graphics;    // Tile graphics
global.mode_rooms[? 2] = rm_mode2_pixel;       // Pixel graphics

// MODE 1 sprite sheet container
// FONT registry for MODE 1
global.font_sheets = ds_map_create();

// Base character sheet
ds_map_add(global.font_sheets, "DEFAULT", spr_charactersheet);

// Special 32×32 or alt glyphs
ds_map_add(global.font_sheets, "SPECIAL", spr_charactersheet_special);

// 16×16 set
ds_map_add(global.font_sheets, "16x16", spr_charactersheet_16x16);
ds_map_add(global.font_sheets, "16x16_SPECIAL", spr_charactersheet_16x16_special);

// 8×8 set
ds_map_add(global.font_sheets, "8x8", spr_charactersheet_8x8);
ds_map_add(global.font_sheets, "DEFAULT_32", spr_charactersheet);
ds_map_add(global.font_sheets, "DEFAULT_16", spr_charactersheet_16x16);
ds_map_add(global.font_sheets, "DEFAULT_8",  spr_charactersheet_8x8);

ds_map_add(global.font_sheets, "SPECIAL_16", spr_charactersheet_16x16_special);

// Initialize active sheet
global.mode1_active_sprite   = global.font_sheets[? "DEFAULT_32"];
global.mode1_active_font_key = "DEFAULT_32";
global.mode1_cell_px         = 32;

global.active_font_name = "DEFAULT";
global.active_font_sprite = global.font_sheets[? global.active_font_name];

global.grid_refresh_needed = false;
global.grid_refresh_char = 32;

global.basic_arrays = ds_map_create(); // name (string) → ds_list

global.interpreter_target_line = -1;
global.interpreter_target_stmt = 0;
global.interpreter_use_stmt_jump = false;
global.interpreter_resume_stmt_index = 0;

global.interpreter_current_stmt_index = 0;

global.config = ds_map_create();
global.config[? "max_line_number"] = 65535;
global.config[? "max_history_size"] = 50;


// === DATA/READ globals ===
// Create once; the builder will clear/reuse it each run.
if (!variable_global_exists("data_streams") || !ds_exists(global.data_streams, ds_type_map)) {
    global.data_streams = ds_map_create();
    if (dbg_on(DBG_FLOW)) show_debug_message("globals: created global.data_streams");
}


if (!variable_global_exists("__inkey_queue")) {
    global.__inkey_queue = ds_queue_create();
}

global.inkey_mode = false; 
global.pause_in_effect = false; 
global.inkey_waiting    = false;
global.inkey_captured   = "";
global.inkey_target_var = "";
global.interpreter_current_line_index = 0; 

// Archival copy of line numbers used by run_program
global.basic_line_numbers = ds_list_create();
global._syntax_error_just_emitted = false;

// optional, if you use these
global._validator_header_emitted = false;
global._abort_after_validation   = false;

// Where to return when leaving the interpreter
global.editor_return_room = room; // whatever room the editor lives in at startup

global.config[? "show_error_hints"] = true; // show compact help lines under syntax errors

global.screen_edit_mode = false; //for scree editing
if (dbg_on(DBG_FLOW)) show_debug_message("GLOBALS: screen_edit_mode initialized to false");


/// Put near your other globals the first time you use them:
if (!variable_global_exists("__html_dir_opening")) global.__html_dir_opening = false;
if (!variable_global_exists("__html_dir_open_time")) global.__html_dir_open_time = 0;

if (!variable_global_exists("DEBUG_INPUT")) global.DEBUG_INPUT = false;

if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }
	
global.print_zone = 14; // width
global.print_tab_mode = 1; 
// 0 = zones (BASIC default), 1 = fixed-width tabs


================================================================================

/// @file scripts/basic_assign_to_array/basic_assign_to_array.gml

/// Helper function to assign values to arrays  (BASIC is 1-based; ds_list is 0-based)
function basic_assign_to_array(varName, val) {
    // Parse "NAME(idx)" from something like "HOLD(POS)" or "TOPIC$(I)"
    var open_paren  = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
if (open_paren <= 0 || close_paren <= open_paren) {
    basic_syntax_error(
        "Invalid array syntax: " + varName,
        global.current_line_number,
        global.interpreter_current_stmt_index,
        "ARRAY_SYNTAX"    );
    return;
    }

    var arrayName = string_trim(string_copy(varName, 1, open_paren - 1));
    var indexExpr = string_trim(string_copy(varName, open_paren + 1, close_paren - open_paren - 1));

    // Normalize array symbol (stored uppercase etc.)
    var normalizedArrayName = basic_normvar(arrayName);

    // Evaluate index expression (BASIC semantics → 1-based index)
    var indexTokens  = basic_tokenize_expression_v2(indexExpr);
    var indexPostfix = infix_to_postfix(indexTokens);
    var indexVal     = evaluate_postfix(indexPostfix);

    // BASIC arrays are 1-based. Convert to 0-based for ds_list.
    var idx1 = max(1, floor(real(indexVal))); // 1..∞ (clamp at 1 so we never write at <1)
    var idx0 = idx1 - 1;                      // 0..∞ for ds_list

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("ARRAY ASSIGN: Array='" + normalizedArrayName +
            "' idx1=" + string(idx1) + " (idx0=" + string(idx0) + ") Value='" + string(val) + "'");
    }

    // Ensure container exists
    if (!ds_map_exists(global.basic_arrays, normalizedArrayName)) {
        global.basic_arrays[? normalizedArrayName] = ds_list_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: Created new array '" + normalizedArrayName + "'");
    }
    var arrayList = global.basic_arrays[? normalizedArrayName];

    // Grow list up to idx0
    while (ds_list_size(arrayList) <= idx0) {
        ds_list_add(arrayList, 0); // default filler
    }

    // Decide storage type from trailing $
    var is_string_array = (string_length(normalizedArrayName) > 0) &&
                          (string_char_at(normalizedArrayName, string_length(normalizedArrayName)) == "$");

    if (is_string_array) {
        ds_list_replace(arrayList, idx0, string(val));
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: " + normalizedArrayName + "[" + string(idx1) + "] = '" + string(val) + "' (string)");
    } else {
        var numVal = is_real(val) ? val : (basic_looks_numeric(string(val)) ? real(val) : 0);
        ds_list_replace(arrayList, idx0, numVal);
        if (dbg_on(DBG_FLOW)) show_debug_message("ARRAY ASSIGN: " + normalizedArrayName + "[" + string(idx1) + "] = " + string(numVal) + " (numeric)");
    }
}


================================================================================

/// @file scripts/basic_cmd_else/basic_cmd_else.gml

/// @script basic_cmd_else
/// @description Handle ELSE in a structured IF…ELSEIF…ELSE…ENDIF
function basic_cmd_else() {
    if (dbg_on(DBG_FLOW)) show_debug_message("ELSE START");

    // Guard: IF stack must exist and be non-empty
    if (!ds_exists(global.if_stack, ds_type_stack) || ds_stack_size(global.if_stack) == 0) {
        if (dbg_on(DBG_FLOW)) show_debug_message("?ELSE ERROR: ELSE without matching IF (empty IF stack)");
        return;
    }

    // Pull current IF frame (map id)
    var frame_id = ds_stack_top(global.if_stack);
    if (!ds_exists(frame_id, ds_type_map)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("?ELSE ERROR: IF frame missing/invalid map");
        return;
    }

    // Read state with safe defaults
    var taken   = ds_map_exists(frame_id, "takenBranch") ? (frame_id[? "takenBranch"]) : false;
    var endifIx = ds_map_exists(frame_id, "endifIndex")  ? (frame_id[? "endifIndex"])  : -1;

    var current_index = global.interpreter_current_line_index;

    if (taken) {
        // Already ran IF or an ELSEIF → skip ELSE body to ENDIF (if known)
        if (endifIx >= 0) {
            global.interpreter_next_line = endifIx;
            if (dbg_on(DBG_FLOW)) show_debug_message("ELSE skipping to ENDIF at index " + string(endifIx));
        } else {
            // Fallback: advance one line if ENDIF index unknown
            global.interpreter_next_line = current_index + 1;
            if (dbg_on(DBG_FLOW)) show_debug_message("ELSE: no ENDIF index; advancing to " + string(global.interpreter_next_line));
        }
    } else {
        // No branch taken yet → execute ELSE body
        ds_map_replace(frame_id, "takenBranch", true);
        global.interpreter_next_line = current_index + 1;
        if (dbg_on(DBG_FLOW)) show_debug_message("ELSE entering branch at index " + string(global.interpreter_next_line));
    }
}


================================================================================

/// @file scripts/basic_cmd_for/basic_cmd_for.gml

/// @function basic_cmd_for(arg) 
/// @description Parses and handles BASIC FOR loop initialization (spacing-tolerant; optional STEP)
function basic_cmd_for(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Entering handler with argument: '" + string(arg) + "'");

    // 1) Parse "VAR = start TO end [STEP step]"
    var raw   = string_trim(string(arg));
    var eqpos = string_pos("=", raw);
    if (eqpos <= 0) {
        basic_syntax_error("FOR missing '=' - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var varname = string_upper(string_trim(string_copy(raw, 1, eqpos - 1)));
    if (varname == "") {
        basic_syntax_error("FOR missing variable name before '='",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var rhs = string_trim(string_copy(raw, eqpos + 1, string_length(raw) - eqpos));

    // find TO
    var to_at = -1;
    for (var p = 1; p <= string_length(rhs) - 1; p++) {
        if (string_upper(string_copy(rhs, p, 2)) == "TO") { to_at = p; break; }
    }
    if (to_at < 0) {
        basic_syntax_error("FOR missing TO - use FOR I=1 TO 10",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_SYNTAX");
        return;
    }

    var start_expr = string_trim(string_copy(rhs, 1, to_at - 1));
    var after_to   = string_trim(string_copy(rhs, to_at + 2, string_length(rhs) - (to_at + 1)));
    if (start_expr == "" || after_to == "") {
        basic_system_message("SYNTAX ERROR IN FOR (incomplete expressions): " + raw);
        global.interpreter_running = false;
        return;
    }

    // optional STEP
    var step_expr = "1";
    var to_expr   = after_to;

    var step_at = -1;
    for (var q = 1; q <= string_length(after_to) - 3; q++) {
        if (string_upper(string_copy(after_to, q, 4)) == "STEP") { step_at = q; break; }
    }
    if (step_at > 0) {
        to_expr   = string_trim(string_copy(after_to, 1, step_at - 1));
        step_expr = string_trim(string_copy(after_to, step_at + 4, string_length(after_to) - (step_at + 3)));
        if (step_expr == "") step_expr = "1";
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Header pieces → var='" + varname
        + "' | start='" + start_expr + "' | to='" + to_expr + "' | step='" + step_expr + "'");

    // 2) Evaluate start, to, step
    var start_tokens  = basic_tokenize_expression_v2(start_expr);
    var start_postfix = infix_to_postfix(start_tokens);
    var start_val     = evaluate_postfix(start_postfix);

    var to_val_eval   = basic_evaluate_expression_v2(to_expr);
    var step_val_eval = basic_evaluate_expression_v2(step_expr);

    // --- SAFE RESOLUTION: only accept string if it's a variable name; never call real() on text ---
    if (is_string(to_val_eval)) {
        var key_to = string_upper(string_trim(to_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_to)) {
            to_val_eval = global.basic_variables[? key_to];
        } else {
            basic_syntax_error("FOR ... TO must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_RANGE");
            return;
        }
    }
    if (is_string(step_val_eval)) {
        var key_step = string_upper(string_trim(step_expr));
        if (!is_undefined(global.basic_variables) && ds_map_exists(global.basic_variables, key_step)) {
            step_val_eval = global.basic_variables[? key_step];
        } else {
            // if user wrote STEP "" or a non-var string, reject
            basic_syntax_error("FOR ... STEP must be numeric or a numeric variable",
                global.current_line_number, global.interpreter_current_stmt_index, "FOR_STEP");
            return;
        }
    }

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Eval → start=" + string(start_val)
        + " | to(eval)=" + string(to_val_eval) + " [raw='" + to_expr + "']"
        + " | step(eval)=" + string(step_val_eval) + " [raw='" + step_expr + "']");

    // 3) Initialize loop var
    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }
    global.basic_variables[? varname] = start_val;
    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Initialized variable " + varname + " = " + string(start_val));

    // 4) Push frame (legacy + inline stmt coordinates)
    var legacy_return_line = line_index;
    var loop_line_idx = line_index;
    var loop_stmt_idx = -1;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        loop_stmt_idx = global.interpreter_current_stmt_index + 1;
    }

    if (!ds_exists(global.for_stack, ds_type_stack)) {
        global.for_stack = ds_stack_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Safety — created global.for_stack");
    }

    var frame = {
        varname     : varname,
        to          : to_val_eval,
        step        : step_val_eval,
        to_raw      : to_expr,       // keep raw for dynamic re-eval in NEXT
        step_raw    : step_expr,     // keep raw for dynamic re-eval in NEXT
        return_line : legacy_return_line,
        loop_line   : loop_line_idx,
        loop_stmt   : loop_stmt_idx
    };
    ds_stack_push(global.for_stack, frame);

    if (dbg_on(DBG_FLOW)) show_debug_message("FOR: Pushed frame → {var=" + varname
        + ", to=" + string(to_val_eval)
        + ", step=" + string(step_val_eval)
        + ", return_line=" + string(legacy_return_line)
        + ", loop=(" + string(loop_line_idx) + "," + string(loop_stmt_idx) + ")}");
}


================================================================================

/// @file scripts/basic_cmd_gosub/basic_cmd_gosub.gml

/// @script basic_cmd_gosub
function basic_cmd_gosub(arg) {
    var raw = string_trim(arg);
    var colonPos = string_pos(":", raw);
    if (colonPos > 0) raw = string_trim(string_copy(raw, 1, colonPos - 1));
    var target = real(raw);

    // Ensure gosub stack exists
    if (!ds_exists(global.gosub_stack, ds_type_stack)) {
        global.gosub_stack = ds_stack_create();
    }

    // === CHANGE: capture statement-level resume point on this same line ===
    var resume_stmt = 0;
    if (variable_global_exists("interpreter_current_stmt_index")) {
        resume_stmt = global.interpreter_current_stmt_index + 1;  // next stmt on this line
    }
    var frame = {
        kind: "stmt",                 // mark as statement-level resume
        line_index: line_index,       // current line index
        stmt_index: resume_stmt       // next statement to run on return
    };
    ds_stack_push(global.gosub_stack, frame);

    // Jump to target line
    global.interpreter_next_line = -1;
    var listSize = ds_list_size(global.line_list);
    for (var i = 0; i < listSize; i++) {
        if (ds_list_find_value(global.line_list, i) == target) {
            global.interpreter_next_line = i;
            break;
        }
    }
    if (global.interpreter_next_line == -1) {
        basic_syntax_error("GOSUB target line not found: " + string(target),
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_TARGET");
        return;
    }
}


================================================================================

/// @file scripts/basic_cmd_let/basic_cmd_let.gml

/// === BEGIN: basic_cmd_let ===
/// LET handler with modal INKEY$ support and array handling
function basic_cmd_let(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("LET: Raw input: '" + arg + "'");

    // Split "NAME = EXPR"
    var eq = string_pos("=", arg);
    if (eq <= 0) {
        basic_syntax_error("LET requires '='", /*line*/ undefined, global.interpreter_current_stmt_index, "LET_MISSING_EQUALS");
        return;
    }

    var varName = string_trim(string_copy(arg, 1, eq - 1));
    var exprStr = string_trim(string_copy(arg, eq + 1, string_length(arg) - eq));

    if (dbg_on(DBG_FLOW)) {
        show_debug_message("LET: Parsed variable name: '" + varName + "'");
        show_debug_message("LET: Parsed expression    : '" + exprStr + "'");
    }

    // ---------- MODAL INKEY$: pure RHS detection ----------
    var expr_uc = string_upper(exprStr);
    var is_pure_inkey = false;

    // Allow "INKEY$" or "INKEY$()" with arbitrary spaces
    // Strip whitespace
    var expr_compact = string_replace_all(string_replace_all(expr_uc, " ", ""), "\t", "");
    if (expr_compact == "INKEY$" || expr_compact == "INKEY$()") is_pure_inkey = true;

    if (is_pure_inkey) {

        // 1) If we are resuming from a prior wait and have a captured char, COMMIT now.
        if (variable_global_exists("inkey_waiting") && global.inkey_waiting) {
            if (variable_global_exists("inkey_captured") && string_length(global.inkey_captured) > 0) {
                var ch_commit = string(global.inkey_captured);
                
                // Handle array vs regular variable for INKEY$ assignment
                if (basic_is_array_reference(varName)) {
                    basic_assign_to_array(varName, ch_commit);
                } else {
                    var k = basic_normvar(varName);
                    global.basic_variables[? k] = ch_commit;
                }

                // Clear modal flags
                global.inkey_captured   = "";
                global.inkey_waiting    = false;
                global.pause_in_effect  = false;
                global.inkey_target_var = "";

                if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: committed '" + ch_commit + "' to " + varName + " (resume)");
                return;
            }

            // Still waiting, keep paused this frame
            global.pause_in_effect = true;
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: still waiting (no captured char yet)");
            return;
        }

        // 2) Not waiting yet – FAST PATH: assign immediately if queue already has a key
        // Support either queue name (__inkey_queue primary; inkey_queue legacy)
        var _q = undefined;
        if (ds_exists(global.__inkey_queue, ds_type_queue)) _q = global.__inkey_queue;
        else if (variable_global_exists("inkey_queue") && ds_exists(global.inkey_queue, ds_type_queue)) _q = global.inkey_queue;

        if (!is_undefined(_q) && ds_queue_size(_q) > 0) {
            var ch2 = ds_queue_dequeue(_q);
            if (is_real(ch2)) ch2 = chr(ch2);
            
            // Handle array vs regular variable for INKEY$ assignment
            if (basic_is_array_reference(varName)) {
                basic_assign_to_array(varName, string(ch2));
            } else {
                var k = basic_normvar(varName);
                global.basic_variables[? k] = string(ch2);
            }
            
            if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: fast-path assign '" + string(ch2) + "' to " + varName);
            return;
        }

        // 3) Arm modal wait: no key ready yet → pause interpreter and let Step capture ONE key
        global.inkey_waiting    = true;
        global.pause_in_effect  = true;
        global.inkey_target_var = varName; // Store the full variable name including array syntax
        global.inkey_captured   = "";
        if (dbg_on(DBG_FLOW)) show_debug_message("LET/INKEY$: armed modal wait for " + varName);
        return;
    }
    // ---------- END MODAL INKEY$ special case ----------

    // ---------- Default LET path: evaluate expression and assign ----------
    var tokens  = basic_tokenize_expression_v2(exprStr);
    var postfix = infix_to_postfix(tokens);
    var val     = evaluate_postfix(postfix);

    // Check if this is an array assignment
    if (basic_is_array_reference(varName)) {
        basic_assign_to_array(varName, val);
        return;
    }

    // Regular variable assignment (existing logic)
    var k = basic_normvar(varName);

    // Coerce based on variable sigil: trailing $ means string var
    var is_string_var = (string_length(k) > 0) && (string_char_at(k, string_length(k)) == "$");
    if (is_string_var) {
        global.basic_variables[? k] = string(val);
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned string value: '" + string(val) + "' to '" + k + "'");
    } else {
        // Numeric: if it looks numeric, coerce to real; else 0 (or keep as-is if you prefer)
        if (is_real(val)) {
            global.basic_variables[? k] = val;
        } else if (basic_looks_numeric(string(val))) {
            global.basic_variables[? k] = real(val);
        } else {
            global.basic_variables[? k] = 0;
        }
        if (dbg_on(DBG_FLOW)) show_debug_message("LET: Assigned value: '" + string(global.basic_variables[? k]) + "' to '" + k + "'");
    }
}



================================================================================

/// @file scripts/basic_cmd_next/basic_cmd_next.gml

/// @function basic_cmd_next(arg)
/// @description Handles BASIC NEXT loop continuation (legacy-compatible; optional inline-colon support)
function basic_cmd_next(arg) {
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Entering handler with arg: '" + string(arg) + "'");

    if (!ds_exists(global.for_stack, ds_type_stack) || ds_stack_empty(global.for_stack)) {
        basic_syntax_error("NEXT without matching FOR",
            global.current_line_number, global.interpreter_current_stmt_index, "FOR_MISMATCH");
        return;
    }

    var frame = ds_stack_top(global.for_stack);

    // Optional check: NEXT I
    var user_var = string_trim(string_upper(string(arg)));
    if (user_var != "" && is_struct(frame) && variable_struct_exists(frame, "varname")) {
        if (string_upper(frame.varname) != user_var && dbg_on(DBG_FLOW)) {
            show_debug_message("NEXT: WARNING — NEXT " + user_var + " does not match active FOR var " + string(frame.varname));
        }
    }

    var varname     = frame.varname;
    var to_val      = frame.to;
    var step_val    = frame.step;
    var return_line = frame.return_line;
    var loop_line   = (variable_struct_exists(frame, "loop_line")) ? frame.loop_line : -1;
    var loop_stmt   = (variable_struct_exists(frame, "loop_stmt")) ? frame.loop_stmt : -1;

    if (is_undefined(global.basic_variables)) {
        basic_system_message("RUNTIME ERROR: variable store not initialized");
        global.interpreter_running = false;
        return;
    }

    // Re-evaluate TO / STEP each iteration if they weren’t numeric
    if (!is_real(to_val)) {
        var to_expr_local = variable_struct_exists(frame, "to_raw") ? frame.to_raw : to_val;
        to_val = basic_evaluate_expression_v2(to_expr_local);
        if (is_string(to_val)) {
            var key_to = string_upper(string_trim(to_expr_local));
            if (!ds_map_exists(global.basic_variables, key_to)) {
                basic_syntax_error("FOR ... TO must be numeric",
                    global.current_line_number, global.interpreter_current_stmt_index, "FOR_TO_NONNUM");
                return;
            }
            to_val = global.basic_variables[? key_to];
        }
        frame.to = to_val;
    }
    if (!is_real(step_val)) {
        var step_expr_local = variable_struct_exists(frame, "step_raw") ? frame.step_raw : step_val;
        step_val = basic_evaluate_expression_v2(step_expr_local);
        if (is_string(step_val)) {
            var key_step = string_upper(string_trim(step_expr_local));
            if (!ds_map_exists(global.basic_variables, key_step)) {
                // default if someone did STEP with a non-numeric symbol
                step_val = 1;
            } else {
                step_val = global.basic_variables[? key_step];
            }
        }
        frame.step = step_val;
    }

    var current = global.basic_variables[? varname];

    if (step_val == 0) {
        var inferred = (to_val >= current) ? 1 : -1;
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: STEP=0; defaulting to " + string(inferred));
        step_val = inferred;
        frame.step = step_val;
    }

    current += step_val;
    global.basic_variables[? varname] = current;

    var continue_loop = (step_val > 0) ? (current <= to_val) : (current >= to_val);
    if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: to=" + string(to_val)
        + " step=" + string(step_val) + " current=" + string(current)
        + " → continue=" + string(continue_loop));

    if (continue_loop) {
        var have_stmt_jump =
            variable_global_exists("interpreter_target_line") &&
            variable_global_exists("interpreter_target_stmt");

        if (have_stmt_jump && loop_line >= 0 && loop_stmt >= 0) {
            global.interpreter_target_line = loop_line;
            global.interpreter_target_stmt = loop_stmt;
            if (variable_global_exists("interpreter_use_stmt_jump")) {
                global.interpreter_use_stmt_jump = true;
            }
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Inline jump → (" + string(loop_line) + "," + string(loop_stmt) + ")");
        } else {
            global.interpreter_next_line = return_line + 1; // legacy line jump
            if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Legacy jump → line index " + string(global.interpreter_next_line));
        }
    } else {
        ds_stack_pop(global.for_stack);
        if (dbg_on(DBG_FLOW)) show_debug_message("NEXT: Loop complete — popped FOR frame");
    }
}


================================================================================

/// @file scripts/basic_cmd_print/basic_cmd_print.gml

// === BEGIN: basic_cmd_print ===
function basic_cmd_print(arg, line_number) {

    if (!ds_exists(global.output_lines, ds_type_list))  global.output_lines  = ds_list_create();
    if (!ds_exists(global.output_colors, ds_type_list)) global.output_colors = ds_list_create();

    var suppress_newline = false;
    var tabw = max(1, is_undefined(global.print_zone) ? 14 : global.print_zone);
    var line_accum = "";
    var col = 0;

    // Trailing semicolon → no newline
    if (string_length(arg) > 0 && string_char_at(arg, string_length(arg)) == ";") {
        suppress_newline = true;
        arg = string_copy(arg, 1, string_length(arg) - 1);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Trailing semicolon detected; suppressing newline");
    }

    arg = string_trim(arg);

    // 1) Split by unquoted semicolons (these do NOT tab)
    var semi_parts = split_on_unquoted_semicolons(arg);

    // 2) Flatten, preserving WHICH separator preceded each part
    //    sep[i] ∈ { "START", "SEMI", "COMMA" }
    var parts = [];
    var seps  = [];

    var have_any = false;
    for (var si = 0; si < array_length(semi_parts); si++) {
        var seg = string_trim(semi_parts[si]);
        if (seg == "") {
            // if there are consecutive semicolons, they just concatenate nothing
            continue;
        }

        var comma_parts = split_on_unquoted_commas(seg);
        if (array_length(comma_parts) <= 1) {
            parts[array_length(parts)] = seg;
            seps[array_length(seps)]   = (have_any ? "SEMI" : "START");
            have_any = true;
        } else {
            for (var cj = 0; cj < array_length(comma_parts); cj++) {
                var p = string_trim(comma_parts[cj]);
                if (p == "") continue;
                parts[array_length(parts)] = p;
                var sep_kind = "START";
                if (have_any) {
                    // first item of this segment is after a semicolon; others after commas
                    sep_kind = (cj == 0) ? "SEMI" : "COMMA";
                }
                seps[array_length(seps)] = sep_kind;
                have_any = true;
            }
        }
    }

    // Column-aware appender with "\t" expansion (inline, no local functions)
    var _append_string = 0; // dummy to allow block reuse via comments

    // 3) Evaluate/emit each part with separator behavior
    for (var i = 0; i < array_length(parts); i++) {

        // --- Insert padding if previous separator was a COMMA (tab to next zone)
		if (seps[i] == "COMMA") {
		    var pad_comm;
		    if (global.print_tab_mode == 1) {
		        // Fixed-width tab (equal every time)
		        pad_comm = tabw;
		    } else {
		        // Zone tab (classic BASIC)
		        var next_zone = ((col div tabw) + 1) * tabw;
		        pad_comm = max(1, next_zone - col);
		    }
		    line_accum += string_repeat(" ", pad_comm);
		    col += pad_comm;
		}

        // "SEMI" and "START" add nothing (plain concatenation)

        var part = parts[i];
        var treat_as_literal = false;

        if (is_quoted_string(part)) {
            var inner = string_copy(part, 2, string_length(part) - 2);
            if (!string_pos("+", inner) && !string_pos("-", inner) && !string_pos("*", inner) && !string_pos("/", inner)) {
                treat_as_literal = true;
            }
        }

        var text_piece = "";

        if (treat_as_literal) {
            text_piece = string_copy(part, 2, string_length(part) - 2);
            text_piece = string_replace_all(text_piece, "\"\"", "\""); // "" → "
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " literal → " + text_piece);
        } else {
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Part " + string(i) + " expr → " + part);
            var tokens  = basic_tokenize_expression_v2(part);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Tokens = " + string(tokens));
            var postfix = infix_to_postfix(tokens);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Postfix = " + string(postfix));
            var result  = evaluate_postfix(postfix);
            if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Evaluated result = " + string(result));

            // INKEY$ modal sentinel — defer PRINT until resume
            if (is_string(result) && result == "<<INKEY_WAIT>>") {
                if (is_undefined(global.inkey_waiting))  global.inkey_waiting  = false;
                if (is_undefined(global.inkey_captured)) global.inkey_captured = "";
                global.inkey_waiting   = true;
                global.inkey_captured  = "";
                global.pause_in_effect = true;
                global.awaiting_input  = false;
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY_WAIT: Deferring PRINT until a key is captured.");
                return;
            }

            if (is_real(result)) {
                if (array_length(parts) > 1) {
                    text_piece = string(result); // compact for multi-arg print
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (compact) → '" + text_piece + "'");
                } else {
                    if (frac(result) == 0) text_piece = string(round(result));
                    else                   text_piece = string_format(result, 12, 8);
                    if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: numeric (padded) → '" + text_piece + "'");
                }
            } else {
                text_piece = string(result);
            }
        }

        // Treat CHR$(9) as a tab (optional, harmless)
        if (text_piece == chr(9)) text_piece = "\t";

        // Append with "\t" expansion and column tracking
        var s = string(text_piece);
        for (var k = 1; k <= string_length(s); k++) {
            var ch = string_char_at(s, k);
			if (ch == "\t") {
			    var pad = (global.print_tab_mode == 1)
			        ? tabw
			        : max(1, (((col div tabw) + 1) * tabw) - col);
			    line_accum += string_repeat(" ", pad);
			    col += pad;
			} else {
                line_accum += ch;
                col += 1;
            }
        }
    }

    // 4) Wrap + commit using your existing buffer
    var wrap_width = 40;
    var full_line  = global.print_line_buffer + line_accum;

    while (string_length(full_line) > wrap_width) {
        var line = string_copy(full_line, 1, wrap_width);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, global.current_draw_color);
        full_line = string_copy(full_line, wrap_width + 1, string_length(full_line) - wrap_width);
    }

    global.print_line_buffer = full_line;

    if (!suppress_newline) {
        basic_wrap_and_commit(global.print_line_buffer, global.current_draw_color);
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Line committed → " + global.print_line_buffer);
        global.print_line_buffer = "";
    } else {
        if (dbg_on(DBG_FLOW)) show_debug_message("PRINT: Output buffered without newline → " + global.print_line_buffer);
    }
}
// === END: basic_cmd_print ===


================================================================================

/// @file scripts/basic_cmd_return/basic_cmd_return.gml

/// @file scripts/basic_cmd_return/basic_cmd_return.gml
function basic_cmd_return() {
    if (ds_stack_empty(global.gosub_stack)) {
        basic_syntax_error("RETURN without matching GOSUB",
            global.current_line_number, global.interpreter_current_stmt_index, "GOSUB_MISMATCH");
        return;
    }

    var frame = ds_stack_pop(global.gosub_stack);

    // Backward-compat: older frames were numeric line indexes
    if (is_real(frame)) {
        global.interpreter_next_line = frame;
        return;
    }

    // === CHANGE: statement-level resume ===
    if (is_struct(frame) && frame.kind == "stmt") {
        global.interpreter_use_stmt_jump = true;
        global.interpreter_target_line  = frame.line_index;
        global.interpreter_target_stmt  = max(0, frame.stmt_index);
        return;
    }

    // Fallback: if unknown, behave like legacy
    global.interpreter_next_line = is_real(frame) ? frame : (line_index + 1);
}


================================================================================

/// @file scripts/basic_is_array_reference/basic_is_array_reference.gml

/// Helper function to check if a variable name is an array reference
function basic_is_array_reference(varName) {
    var open_paren = string_pos("(", varName);
    var close_paren = string_pos(")", varName);
    return (open_paren > 0 && close_paren > open_paren);
}



================================================================================

/// @file scripts/basic_tokenize_expression_v2/basic_tokenize_expression_v2.gml

function basic_tokenize_expression_v2(expr) { 
    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting expression: '" + expr + "'");

    var tokens  = [];
    var i       = 1;
    var len     = string_length(expr);
    var current = "";

    // Names that, when immediately followed by '(', should be treated as function calls
    var function_names = ["RND","ABS","EXP","LOG","LOG10","SGN","INT","SIN","COS","TAN","STR$","CHR$","REPEAT$","ASC","LEN"];

    while (i <= len) {
        var c = string_char_at(expr, i);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Char[" + string(i) + "] = '" + c + "'");

        // --------------------------------------------------------------------
        // STRING LITERALS: copy verbatim `"..."` including the closing quote.
        // --------------------------------------------------------------------
        if (c == "\"") {
            var str = "\"";
            i++;
            while (i <= len) {
                var ch = string_char_at(expr, i);
                str += ch;
                if (ch == "\"") break;   // NOTE: this keeps doubled quotes as-is; evaluator unescapes "" → "
                i++;
            }
            array_push(tokens, str);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added (quoted string): " + str);
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // WHITESPACE: finalize any pending token and skip the space.
        // --------------------------------------------------------------------
        if (c == " ") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token from space: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // RELATIONAL (two-char first): <=  >=  <>
        // We must emit these as single tokens so "ROLL<3" → ["ROLL","<","3"].
        // --------------------------------------------------------------------
        if (c == "<" || c == ">") {
            // finalize any pending identifier/number before the operator
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before relation: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            var two = (i < len) ? c + string_char_at(expr, i + 1) : "";
            if (two == "<=" || two == ">=" || two == "<>") {
                array_push(tokens, two);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Relation token added: " + two);
                i += 2;
                continue;
            } else {
                array_push(tokens, c);  // bare < or >
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Relation token added: " + c);
                i += 1;
                continue;
            }
        }

        // --------------------------------------------------------------------
        // EQUALITY: single '='
        // --------------------------------------------------------------------
        if (c == "=") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before '=': '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, "=");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: '=' token added");
            i += 1;
            continue;
        }

        // --------------------------------------------------------------------
        // ARITHMETIC / PARENS / POWER / INT-DIV: +  *  /  \  (  )  %  ^
        //  - If '(' follows a known function name token, we still just emit '(';
        //    the function-ness is used later by the parser, not the tokenizer.
        // --------------------------------------------------------------------
        if (c == "+" || c == "*" || c == "/" || c == "\\" || c == "(" || c == ")" || c == "%" || c == "^") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before operator: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            // We still push "(" literally. Detection of "NAME(" being a function call
            // is handled later by your infix/postfix logic (it looks at the NAME token).
            array_push(tokens, c);
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Operator token added: " + c);

            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // ARG SEPARATOR: comma
        // --------------------------------------------------------------------
        if (c == ",") {
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before comma: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }
            array_push(tokens, ",");
            if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Comma token added");
            i++;
            continue;
        }

        // --------------------------------------------------------------------
        // MINUS: subtraction or start of a negative number token.
        // Heuristic: if '-' is at start, or follows another operator/paren/relation,
        // and is followed by a digit, we treat it as the start of a numeric literal.
        // --------------------------------------------------------------------
        if (c == "-") {
            // finalize any pending token first
            if (current != "") {
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing token before minus: '" + current + "'");
                array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
                current = "";
            }

            var is_negative = false;

            // only consider negative if a digit follows
            if (i < len) {
                var next_is_digit = (ord(string_char_at(expr, i + 1)) >= 48 && ord(string_char_at(expr, i + 1)) <= 57);
                if (next_is_digit) {
                    if (array_length(tokens) == 0) {
                        is_negative = true; // start of expression → negative
                    } else {
                        var last_token = tokens[array_length(tokens) - 1];
                        // If previous token is an operator/paren/relation, this '-' starts a number
                        if ( last_token == "+" || last_token == "-" || last_token == "*" 
                          || last_token == "/" || last_token == "(" || last_token == "%" 
                          || last_token == "^" || string_upper(last_token) == "MOD" 
                          || last_token == "=" || last_token == "<" || last_token == ">" 
                          || last_token == "<=" || last_token == ">=" || last_token == "<>" ) {
                            is_negative = true;
                        }
                    }
                }
            }

            if (is_negative) {
                current = "-"; // begin building a numeric literal like "-12"
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Starting negative number");
            } else {
                array_push(tokens, "-"); // subtraction operator
                if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Added subtraction operator");
            }

            i++;
            continue;
        }
        // ------------------------- END '-' handling -------------------------

        // --------------------------------------------------------------------
        // DEFAULT: accumulate chars for identifiers or number bodies.
        // --------------------------------------------------------------------
        current += c;
        i++;
    }

    // ------------------------------------------------------------------------
    // END: flush any leftover token.
    // ------------------------------------------------------------------------
    if (current != "") {
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Finalizing last token: '" + current + "'");
        array_push(tokens, string_upper(current) == "MOD" ? "MOD" : current);
        if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Token added: " + current);
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("TOKENIZER: Final token list = " + string(tokens));
    return tokens;
}


================================================================================

/// @file scripts/basic_wrap_and_commit/basic_wrap_and_commit.gml

function basic_wrap_and_commit(_text, _color) {
    if (dbg_on(DBG_FLOW)) show_debug_message("=== basic_wrap_and_commit START ===");

    // Output buffers must already exist
    if (is_undefined(global.output_lines) || !ds_exists(global.output_lines, ds_type_list)
    ||  is_undefined(global.output_colors) || !ds_exists(global.output_colors, ds_type_list)) {
        if (dbg_on(DBG_FLOW)) show_debug_message("wrap: buffers not initialized; SKIP");
        return;
    }

    // Width: default 64 unless caller set global.wrap_width
    var wrap_width = (variable_global_exists("wrap_width") && is_real(global.wrap_width) && global.wrap_width > 0)
        ? floor(global.wrap_width) : 70;

    var remaining = string(_text);

    while (string_length(remaining) > wrap_width) {
        var len_rem = string_length(remaining);
        var cut = wrap_width;
        var last_space = 0;
        var found_space = false;

        // Find the last space at or before wrap_width
        var p = min(wrap_width, len_rem);
        for (; p >= 1; p--) {
            if (string_char_at(remaining, p) == " ") { last_space = p; break; }
        }

        if (last_space > 0) {
            // Break on that space (exclude it)
            cut = last_space - 1;
            found_space = true;
        } else {
            // Hard break … but avoid dangling punctuation on next line
            var next_char = (wrap_width + 1 <= len_rem) ? string_char_at(remaining, wrap_width + 1) : "";
            if (next_char == ")" || next_char == "]" || next_char == "}" ||
                next_char == "!" || next_char == "?" || next_char == "." ||
                next_char == "," || next_char == ":" || next_char == ";") {
                var back = wrap_width;
                while (back > 1 && string_char_at(remaining, back) != " ") back--;
                if (back > 1) {
                    cut = back - 1;   // exclude that space
                    found_space = true;
                }
            }
        }

        if (cut < 1) cut = wrap_width; // safety for huge first word

        var line = string_copy(remaining, 1, cut);
        ds_list_add(global.output_lines, line);
        ds_list_add(global.output_colors, _color);

        // Advance; skip the space when we broke on a space
        var next_start = cut + (found_space ? 2 : 1);
        if (next_start <= len_rem) {
            remaining = string_copy(remaining, next_start, len_rem - (next_start - 1));
        } else {
            remaining = "";
        }

        // Trim any leading spaces on the next line
        while (string_length(remaining) > 0 && string_char_at(remaining, 1) == " ") {
            remaining = string_copy(remaining, 2, string_length(remaining) - 1);
        }
    }

    // Tail
    ds_list_add(global.output_lines, remaining);
    ds_list_add(global.output_colors, _color);
}


================================================================================

/// @file scripts/evaluate_postfix/evaluate_postfix.gml

/// @script evaluate_postfix
/// @description Evaluate a postfix token array, with support for 1-D arrays.
/// Notes:
/// - Array tokens arrive as a single atom like "D(I)" because infix_to_postfix collapses NAME(...).
/// - We defensively avoid treating built-in functions as arrays (e.g., "INT(5)").
/// - Comma tokens are ignored completely.
/// - Returns the TOP of the stack (last pushed), else 0.

function evaluate_postfix(postfix) {
    var stack = [];
    if (dbg_on(DBG_PARSE)) show_debug_message("Evaluating postfix: " + string(postfix));

    for (var i = 0; i < array_length(postfix); i++) {
        var token = postfix[i];
        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Processing token [" + string(i) + "] → " + string(token));

        // Normalize once
        var trimmed     = string_trim(string(token));
        var token_upper = string_upper(trimmed);

        // -------------------------------------------------------
        // Ignore commas completely (arg separators, never values)
        // -------------------------------------------------------
        if (trimmed == ",") {
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Ignoring stray comma token");
            continue;
        }

        // -------------------------------------------------------
        // ARRAY READ SUPPORT (atom form: NAME(index_expr))
        // -------------------------------------------------------
        var openPos = string_pos("(", token_upper);
        if (openPos > 0 && string_char_at(token_upper, string_length(token_upper)) == ")") {
            var arrNameU   = string_copy(token_upper, 1, openPos - 1);
            var innerLen   = string_length(token) - openPos - 1;
            var idxTextRaw = string_copy(token, openPos + 1, innerLen);

            // MINIMAL CHANGE: also skip STRING$ here even if is_function() doesn't know it
            if (!is_function(arrNameU) && arrNameU != "STRING$") {
                var arrName = arrNameU; // arrays stored uppercase in helpers
                var idxText = string_trim(idxTextRaw);

                if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY]: Candidate '" + string(token) + "' → name='" + arrName + "', idxText='" + idxText + "'");

                var idxVal = basic_evaluate_expression_v2(idxText);
                if (!is_real(idxVal)) {
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY] ERROR: Index non-numeric from '" + idxText + "' → '" + string(idxVal) + "'. Pushing 0.");
                    array_push(stack, 0);
                    continue;
                }

                var arrVal = basic_array_get(arrName, idxVal); // your 1-based getter
                if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX[ARRAY]: " + arrName + "(" + string(idxVal) + ") → " + string(arrVal));
                array_push(stack, arrVal);
                continue;
            }
        }

        // -------------------------------------------------------
        // Numeric literal
        // -------------------------------------------------------
        if (is_numeric_string(trimmed)) {
            var num = real(trimmed);
            array_push(stack, num);
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed number → " + string(num));
            continue;
        }

        // -------------------------------------------------------
        // Quoted string literal
        // -------------------------------------------------------
        if (string_length(trimmed) >= 2
        &&  string_char_at(trimmed, 1) == "\""
        &&  string_char_at(trimmed, string_length(trimmed)) == "\"")
        {
            var str = string_copy(trimmed, 2, string_length(trimmed) - 2);
            str = string_replace_all(str, "\"\"", "\"");  // unescape "" -> "
            array_push(stack, str);
            if (dbg_on(DBG_FLOW)) if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed quoted string literal → " + str);
            continue;
        }

		// -------------------------------------------------------
		// Operators
		// -------------------------------------------------------
		if (is_operator(token_upper)) {
		    if (array_length(stack) < 2) {
		        if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX ERROR: Not enough operands for operator " + token_upper);
		        return 0;
		    }
		    var b = array_pop(stack);
		    var a = array_pop(stack);
		    var result = 0;

		    switch (token_upper) {
		        case "+":  result = (is_string(a) || is_string(b)) ? string(a) + string(b) : a + b; break;

		        case "-":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = a - b;
		            break;

case "=": {
    // Check if both are numeric (but exclude empty strings)
    var an = is_real(a) || (is_string(a) && string_length(a) > 0 && is_numeric_string(a));
    var bn = is_real(b) || (is_string(b) && string_length(b) > 0 && is_numeric_string(b));

    if (an && bn) {
        if (is_string(a)) a = real(a);
        if (is_string(b)) b = real(b);
        result = (a == b) ? 1 : 0;
    } else {
        result = (string(a) == string(b)) ? 1 : 0;
    }
    break;
}

		        // NEW: all other comparisons must live here (not in the function switch)
		        case "<>": {
		            // numeric compare if both are numbers; otherwise string compare
		            if (is_real(a) && is_real(b)) result = (a != b) ? 1 : 0;
		            else                          result = (string(a) != string(b)) ? 1 : 0;
		            break;
		        }
		        case "<": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a < b) ? 1 : 0;
		            break;
		        }
		        case ">": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a > b) ? 1 : 0;
		            break;
		        }
		        case "<=": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a <= b) ? 1 : 0;
		            break;
		        }
		        case ">=": {
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (a >= b) ? 1 : 0;
		            break;
		        }

		        case "*":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = a * b;
		            break;

		        case "/":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = (b != 0) ? a / b : 0;
		            break;

		        case "\\": { // integer division → truncate toward ZERO
		            if (is_string(a) && is_numeric_string(a)) a = real(a);
		            if (is_string(b) && is_numeric_string(b)) b = real(b);

		            if (!is_real(a) || !is_real(b)) {
		                basic_syntax_error("Integer division '\\' expects numbers; got a=" + string(a) + ", b=" + string(b),
		                    global.current_line_number, global.interpreter_current_stmt_index, "TYPE_MISMATCH");
		                result = 0; break;
		            }
		            if (b == 0) {
		                basic_syntax_error("Division by zero in '\\'",
		                    global.current_line_number, global.interpreter_current_stmt_index, "DIV_ZERO");
		                result = 0; break;
		            }

		            var q = a / b;
		            q = (q >= 0) ? floor(q) : ceil(q); // trunc-to-zero
		            result = q;
		            break;
		        }

		        case "%":
		        case "MOD":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = a mod b;
		            break;

		        case "^":
		            if (is_string(a)) a = real(a);
		            if (is_string(b)) b = real(b);
		            result = power(a, b);
		            break;

case "AND": {
    // Don't pop again - use the a,b already popped above
    var tb = is_real(b) ? (b != 0) : (string_length(string(b)) > 0);
    var ta = is_real(a) ? (a != 0) : (string_length(string(a)) > 0);
    
    result = (ta && tb) ? 1 : 0;
    break;
}
case "OR": {
    // Don't pop again - use the a,b already popped above  
    var tb = is_real(b) ? (b != 0) : (string_length(string(b)) > 0);
    var ta = is_real(a) ? (a != 0) : (string_length(string(a)) > 0);
    
    result = (ta || tb) ? 1 : 0;
    break;
}

		        default:
		            if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX WARNING: Unknown operator = " + token_upper + " → 0");
		            result = 0;
		            break;
		    }

		    array_push(stack, result);
		    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Operator result (" + token_upper + ") = " + string(result));
		    continue;
		}


        // -------------------------------------------------------
        // Functions (numeric + string)
        // -------------------------------------------------------
        if (is_function(token_upper) || token_upper == "STRING$") {
            token_upper = string_upper(string_trim(token));
            if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Dispatching function → '" + token_upper + "'");

            switch (token_upper) {

                // ---- Random
                case "RND1": {
                    var n = safe_real_pop(stack);
                    if (n <= 0) n = 1;
                    var r1;
                    if (n == 1) {
                        // Classic BASIC: RND(1) returns 0.0 to 0.999...
                        r1 = random(1);
                    } else {
                        // Integer range: RND(6) returns 1-6
                        r1 = irandom(n - 1) + 1;
                    }
                    array_push(stack, r1);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RND1(" + string(n) + ") → " + string(r1));
                    break;
                }

                case "RND2": {
                    var max_val_raw = array_pop(stack);
                    var min_val_raw = array_pop(stack);
                    var min_val, max_val;

                    if (is_real(min_val_raw)) {
                        min_val = min_val_raw;
                    } else if (ds_map_exists(global.basic_variables, min_val_raw) && is_real(global.basic_variables[? min_val_raw])) {
                        min_val = global.basic_variables[? min_val_raw];
                    } else {
                        min_val = undefined;
                    }

                    if (is_real(max_val_raw)) {
                        max_val = max_val_raw;
                    } else if (ds_map_exists(global.basic_variables, max_val_raw) && is_real(global.basic_variables[? max_val_raw])) {
                        max_val = global.basic_variables[? max_val_raw];
                    } else {
                        max_val = undefined;
                    }

                    if (!is_real(min_val) || !is_real(max_val)) {
                        basic_system_message("ERROR: RND(min,max) requires numeric arguments — got '" 
                            + string(min_val_raw) + "', '" + string(max_val_raw) + "'");
                        array_push(stack, 0);
                    } else {
                        var result = irandom_range(min_val, max_val);
                        array_push(stack, result);
                        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RND2(" + string(min_val) + "," + string(max_val) + ") → " + string(result));
                    }
                    break;
                }

                // ---- NEW: Zero-arg time/keyboard functions ----
                case "TIMER": {
                    var secs = floor(current_time / 1000); // ms → seconds since game start
                    array_push(stack, secs);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: TIMER → " + string(secs));
                    break;
                }
				
				case "LEN": {
				    var s = string(array_pop(stack));
				    array_push(stack, string_length(s));
				    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: LEN('" + s + "') → " + string(string_length(s)));
				    break;
				}
				
                case "TIME$": {
                    var dt  = date_current_datetime();
                    var hh  = date_get_hour(dt);
                    var mm  = date_get_minute(dt);
                    var ss  = date_get_second(dt);
                    var hhs = (hh < 10 ? "0" : "") + string(hh);
                    var mms = (mm < 10 ? "0" : "") + string(mm);
                    var sss = (ss < 10 ? "0" : "") + string(ss);
                    var out = hhs + ":" + mms + ":" + sss;
                    array_push(stack, out);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: TIME$ → " + out);
                    break;
                }
                case "DATE$": {
                    var dt2 = date_current_datetime();
                    var yy  = date_get_year(dt2);
                    var mo  = date_get_month(dt2);
                    var dd  = date_get_day(dt2);
                    var mos = (mo < 10 ? "0" : "") + string(mo);
                    var dds = (dd < 10 ? "0" : "") + string(dd);
                    var out2 = string(yy) + "-" + mos + "-" + dds;
                    array_push(stack, out2);
                    if (dbg_on(DBG_PARSE)) show_debug_message("FUNC: DATE$ → " + out2);
                    break;
                }

                case "INKEY$": {
                    if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: Processing INKEY$ token");

                    if (!variable_global_exists("inkey_queue") || is_undefined(global.inkey_queue)) {
                        if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: creating global.inkey_queue");
                        global.inkey_queue = ds_queue_create();
                    }

                    var _res = "";
                    if (ds_queue_size(global.inkey_queue) > 0) {
                        var _ch = ds_queue_dequeue(global.inkey_queue);
                        if (is_real(_ch)) _ch = chr(_ch);
                        _res = string(_ch);
                        if (dbg_on(DBG_PARSE)) show_debug_message(
                            "INKEY$ function: Dequeued '" + _res + "', queue size now = " + string(ds_queue_size(global.inkey_queue))
                        );
                    } else {
                        if (dbg_on(DBG_PARSE)) show_debug_message("INKEY$ function: Queue empty → returning empty string");
                    }

                    if (dbg_on(DBG_PARSE)) {
                        var _len = string_length(_res);
                        var _a1  = (_len >= 1) ? ord(string_char_at(_res, 1)) : -1;
                        var _a2  = (_len >= 2) ? ord(string_char_at(_res, 2)) : -1;
                        if (dbg_on(DBG_FLOW)) show_debug_message("##INK## LEN=" + string(_len)
                            + " A1=" + string(_a1)
                            + " A2=" + string(_a2)
                            + " K$='" + _res + "'");
                    }

                    array_push(stack, _res);
                    break;
                }

                // ---- Math
                case "ABS": array_push(stack, abs(safe_real_pop(stack))); break;
                case "EXP": array_push(stack, exp(safe_real_pop(stack))); break;

                // Preserving your prior semantics: LOG & LOG10 both as base-10
                case "LOG":
                case "LOG10": {
                    var v = safe_real_pop(stack);
                    array_push(stack, (ln(v) / ln(10)));
                    break;
                }

                case "SGN": {
                    var vsgn = safe_real_pop(stack);
                    var sgnv = (vsgn > 0) - (vsgn < 0);
                    array_push(stack, sgnv);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: SGN(" + string(vsgn) + ") → " + string(sgnv));
                    break;
                }

                case "INT": array_push(stack, floor(safe_real_pop(stack))); break;
                case "SIN": array_push(stack, sin(safe_real_pop(stack)));   break;
                case "COS": array_push(stack, cos(safe_real_pop(stack)));   break;
                case "TAN": array_push(stack, tan(safe_real_pop(stack)));   break;

                // ---- String conversions
                case "STR$": {
                    var vstr = safe_real_pop(stack);
                    var s = string(vstr);
                    array_push(stack, s);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: STR$ → " + s);
                    break;
                }
				
                case "CHR$": {
                    var cv = safe_real_pop(stack);
                    var c  = chr(cv);
                    array_push(stack, c);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: CHR$ → " + c);
                    break;
                }

                // ---- String functions we added
                case "REPEAT$": {
                    var nrep = floor(safe_real_pop(stack));
                    var srep = string(array_pop(stack));
                    if (nrep < 0) nrep = 0;

                    var max_out = 65535;
                    var unit = max(1, string_length(srep));
                    if (unit * nrep > max_out) nrep = floor(max_out / unit);

                    var outrep = "";
                    repeat (nrep) outrep += srep;
                    array_push(stack, outrep);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: REPEAT$('"+srep+"', "+string(nrep)+") → len="+string(string_length(outrep)));
                    break;
                }

                case "LEFT$": {
                    var nleft = floor(safe_real_pop(stack));
                    var sleft = string(array_pop(stack));
                    if (nleft < 0) nleft = 0;

                    var outleft = (nleft <= 0) ? "" : string_copy(sleft, 1, nleft);
                    array_push(stack, outleft);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: LEFT$('"+sleft+"', "+string(nleft)+") → '"+outleft+"'");
                    break;
                }

                case "RIGHT$": {
                    var nright = floor(safe_real_pop(stack));
                    var sright = string(array_pop(stack));
                    if (nright < 0) nright = 0;

                    var lenr = string_length(sright);
                    var start = max(1, lenr - nright + 1);
                    var outright = (nright <= 0) ? "" : string_copy(sright, start, nright);
                    array_push(stack, outright);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: RIGHT$('"+sright+"', "+string(nright)+") → '"+outright+"'");
                    break;
                }

                case "MID$": {
                    var lmid = floor(safe_real_pop(stack));
                    var smid = floor(safe_real_pop(stack));
                    var strm = string(array_pop(stack));

                    if (lmid < 0) lmid = 0;
                    if (smid < 1) smid = 1;

                    var outm = "";
                    if (lmid > 0 && smid <= string_length(strm)) {
                        outm = string_copy(strm, smid, lmid);
                    }
                    array_push(stack, outm);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: MID$('"+strm+"', "+string(smid)+", "+string(lmid)+") → '"+outm+"'");
                    break;
                }

                case "ASC": {
                    var s = string(array_pop(stack));            // ensure string
                    var r = (string_length(s) >= 1) ? ord(string_char_at(s, 1)) : 0;
                    array_push(stack, r);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: ASC('" + s + "') → " + string(r));
                    break;
                }

                // ---- NEW: STRING$(x, n) ----
                case "STRING$": {
                    // Postfix order from infix handler: push x, push n, then STRING$
                    var n = array_pop(stack);
                    var _x = array_pop(stack);

                    // normalize n
                    var count = max(0, floor(is_real(n) ? n : real(n)));

                    // determine a single character from _x
                    var ch;
                    if (is_string(_x)) {
                        ch = (string_length(_x) > 0) ? string_copy(_x, 1, 1) : " ";
                    } else {
                        var code = clamp(floor(real(_x)), 0, 255);
                        ch = chr(code);
                    }

                    var out = "";
                    repeat (count) out += ch;

                    array_push(stack, out);
                    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: STRING$(" + string(x) + "," + string(count) + ") → len=" + string(string_length(out)));
                    break;
                }

			


                default:
                    if (dbg_on(DBG_PARSE)) show_debug_message("? POSTFIX WARNING: Unknown function = " + token_upper + " — pushing last real as fallback");
                    array_push(stack, safe_real_pop(stack));
                    break;
            }

            continue;
        }

			// -------------------------------------------------------
			// Scalar variable load (string vars stay strings; numeric vars coerce)
			// -------------------------------------------------------
			if (ds_map_exists(global.basic_variables, token_upper)) {
			    var vv = global.basic_variables[? token_upper];

			    var is_string_var = (string_char_at(token_upper, string_length(token_upper)) == "$");

			    if (is_string_var) {
			        // String variables ALWAYS behave as strings (QBASIC semantics)
			        if (is_undefined(vv)) vv = "";
			        vv = string(vv); // ensure string; do not numeric-coerce
			    } else {
			        // Numeric variables: allow numeric strings, else 0
			        if (is_string(vv)) {
			            vv = is_numeric_string(vv) ? real(vv) : 0;
			        } else if (!is_real(vv)) {
			            vv = 0;
			        }
			    }

			    array_push(stack, vv);

			    if (dbg_on(DBG_PARSE)) {
			        var _tag = is_string_var ? "[S]" : "[N]";
			        show_debug_message("POSTFIX: Loaded variable " + token_upper + " " + _tag + " = " + string(vv));
			    }
			    continue;
			}


       // -------------------------------------------------------
		// Fallback: IDENT or literal
		// -------------------------------------------------------
		var ident = trimmed;

		// If this looks like an identifier (A..Z start) and it’s not in the map,
		// treat it as an undeclared numeric variable (default 0).
		var first = string_upper(string_char_at(ident, 1));
		var oc = ord(first);
		var looks_ident = (oc >= 65 && oc <= 90); // A..Z

		if (looks_ident) {
		    var key = string_upper(ident);
		    if (!ds_map_exists(global.basic_variables, key)) {
		        // create as numeric 0 (QBASIC style)
		        global.basic_variables[? key] = 0;
		        if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Implicit numeric var created '" + key + "' = 0");
		    }
		    var vv = global.basic_variables[? key];

		    // coerce type by suffix: $ means string var
		    if (string_char_at(key, string_length(key)) == "$") {
		        if (is_undefined(vv)) vv = "";
		        if (!is_string(vv))  vv = string(vv);
		    } else {
		        if (is_string(vv)) {
		            vv = is_numeric_string(vv) ? real(vv) : 0;
		        } else if (!is_real(vv)) {
		            vv = 0;
		        }
		    }
		    array_push(stack, vv);
		    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Loaded/created ident " + key + " = " + string(vv));
		} else {
		    // true literal fallback
		    array_push(stack, trimmed);
		    if (dbg_on(DBG_PARSE)) show_debug_message("POSTFIX: Pushed fallback string → " + trimmed);
		}

    }

    return (array_length(stack) > 0) ? stack[array_length(stack) - 1] : 0;
}


================================================================================

/// @file scripts/get_precedence/get_precedence.gml

function get_precedence(op) {
    switch (string_upper(op)) {
        // Logical operators (lowest precedence)
        case "OR":
            return 0;
        case "AND": 
            return 1;
        // Relational comparisons
        case "=": case "<>": case "<": case ">": case "<=": case ">=":
            return 2;
        // Add/subtract
        case "+": case "-":
            return 3;
        // Multiply/divide/mod
        case "*": case "/": case "\\": case "%": case "MOD":
            return 4;
        // Exponentiation (highest precedence)
        case "^":
            return 5;
        default:
            return 0;
    }
}

================================================================================

/// @file scripts/handle_basic_command/handle_basic_command.gml

/// @function handle_basic_command(cmd, arg)
/// @description Routes BASIC commands (and multiple colon-separated statements) to the correct functions
function handle_basic_command(cmd, arg) {
    // Rebuild the full statement (so we catch any colons in the original)
    var full = string_trim(cmd + (string_length(arg) ? " " + arg : ""));

    // Split on unquoted, top-level colons.
    var parts = split_on_unquoted_colons(full);

    // Dispatch each sub-statement in turn
    for (var i = 0; i < array_length(parts); i++) {
        var stmt = string_trim(parts[i]);
        if (stmt == "") continue;

        if (dbg_on(DBG_FLOW)) show_debug_message("DISPATCH PART: " + stmt);

        // Strip any trailing REM (apostrophe handled inside)
        stmt = strip_basic_remark(stmt);

        // Pull off the verb vs. the rest
        var sp = string_pos(" ", stmt);
        var _verb, _rest;
        if (sp > 0) {
            _verb = string_upper(string_copy(stmt, 1, sp - 1));
            _rest = string_trim(string_copy(stmt, sp + 1, string_length(stmt)));
        } else {
            _verb = string_upper(stmt);
            _rest = "";
        }

        // Skip INKEY$ as command (handled as function in evaluate_postfix)
        if (_verb == "INKEY$") {
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$: Ignored as command, treated as function");
            continue;
        }

        // ---------- SYNTAX GUARD: INKEY$ misuse (quote-aware) ----------
        {
            var _src  = stmt;   // stmt already had remarks stripped
            var _len  = string_length(_src);
            var _up   = string_upper(_src);

            var inq = false;
            var i2  = 1;
            var found_inkey = false;
            var eq_pos = 0;

            while (i2 <= _len) {
                var ch = string_char_at(_src, i2);
                if (ch == "\"") {
                    if (i2 < _len && string_char_at(_src, i2 + 1) == "\"") { i2 += 2; continue; }
                    inq = !inq; i2++; continue;
                }
                if (!inq) {
                    if (eq_pos == 0 && ch == "=") eq_pos = i2;
                    if (i2 + 5 <= _len && string_copy(_up, i2, 6) == "INKEY$") { found_inkey = true; break; }
                }
                i2++;
            }

            if (found_inkey) {
                var implicit_assign = false;
                if (eq_pos > 0) {
                    var lhs = string_trim(string_copy(_src, 1, eq_pos - 1));
                    if (string_length(lhs) > 0) {
                        var h  = string_upper(string_char_at(lhs, 1));
                        var oc = ord(h);
                        if (oc >= 65 && oc <= 90) implicit_assign = true;
                    }
                }
                if (!(_verb == "LET" || implicit_assign)) {
                    basic_syntax_error(
                        "INKEY$ may only appear on the right side of an assignment like  K$ = INKEY$",
                        global.current_line_number,
                        global.interpreter_current_stmt_index,
                        "INKEY_MISUSE"
                    );
                    return;
                }
            }
        }
        // ---------- END SYNTAX GUARD ----------

        // Guard: IF must contain THEN in the same statement
        if (_verb == "IF" && string_pos("THEN", string_upper(_rest)) <= 0) {
            basic_syntax_error(
                "IF requires THEN",
                /* line_no */ undefined,
                /* stmt_idx */ global.interpreter_current_stmt_index,
                "IF REQUIRES THEN"
            );
            return;
        }

        // === INLINE IF COLLAPSE (only within THIS colon segment) ===
        if (_verb == "IF") {
            // Reconstruct the original physical line from the dispatcher’s position
            var line_idx   = global.interpreter_current_line_index; // set by Step
            var line_no    = global.line_list[| line_idx];
            var src_line   = ds_map_find_value(global.program_map, line_no);
            var parts_full = split_on_unquoted_colons(string_trim(src_line));

            // Use ONLY the current colon segment (do NOT append the rest of the line)
            var p       = global.interpreter_current_stmt_index;  // set by Step
            var segment = parts_full[p];

            // Text after the "IF" keyword within THIS segment only
            var after_if  = string_trim(string_copy(segment, 3, max(0, string_length(segment) - 2)));
            var up_after  = string_upper(after_if);

            var has_then = (string_pos("THEN", up_after) > 0);

            // Is there content after THEN within THIS segment?
            var has_content_after_then = false;
            if (has_then) {
                var then_pos   = string_pos("THEN", up_after);
                var after_then = string_trim(string_copy(after_if, then_pos + 4, string_length(after_if)));
                has_content_after_then = (string_length(after_then) > 0);
            }

            if (has_content_after_then) {
                // Inline: parse THEN/ELSE only inside this segment
                var arg_full = string_trim(string_copy(segment, 3, string_length(segment) - 2)); // after "IF"

                if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH (collapsed IF): IF | ARG: " + arg_full);

                // Find top-level THEN (quote/paren-aware)
                var _arg = arg_full;
                var _L   = string_length(_arg);
                var _lvl = 0, _inq = false, _then_pos = 0;
                for (var _i = 1; _i <= _L - 4 + 1; _i++) {
                    var _ch = string_char_at(_arg, _i);
                    if (_ch == "\"") _inq = !_inq;
                    if (!_inq) {
                        if (_ch == "(") _lvl++;
                        else if (_ch == ")") _lvl = max(0, _lvl - 1);
                        if (_lvl == 0 && string_upper(string_copy(_arg, _i, 4)) == "THEN") { _then_pos = _i; break; }
                    }
                }

                if (_then_pos == 0) {
                    // Fallback: old handler
                    basic_cmd_if_inline(arg_full);
                } else {
                    // Split condition and the THEN/ELSE tail (still within this segment only)
                    var _cond_src = string_trim(string_copy(_arg, 1, _then_pos - 1));
                    var _tail     = string_trim(string_copy(_arg, _then_pos + 4, _L - (_then_pos + 4) + 1));

                    // Look for a top-level ELSE
                    var _L2 = string_length(_tail), _lvl2 = 0, _inq2 = false, _else_pos = 0;
                    for (var _j = 1; _j <= _L2 - 4 + 1; _j++) {
                        var _ch2 = string_char_at(_tail, _j);
                        if (_ch2 == "\"") _inq2 = !_inq2;
                        if (!_inq2) {
                            if (_ch2 == "(") _lvl2++;
                            else if (_ch2 == ")") _lvl2 = max(0, _lvl2 - 1);
                            if (_lvl2 == 0 && string_upper(string_copy(_tail, _j, 4)) == "ELSE") { _else_pos = _j; break; }
                        }
                    }

                    var _then_src = (_else_pos > 0) ? string_trim(string_copy(_tail, 1, _else_pos - 1)) : _tail;
                    var _else_src = (_else_pos > 0) ? string_trim(string_copy(_tail, _else_pos + 4, _L2 - (_else_pos + 4) + 1)) : "";

                    // Evaluate condition
                    var _tok  = basic_tokenize_expression_v2(_cond_src);
                    var _post = infix_to_postfix(_tok);
                    var _val  = evaluate_postfix(_post);
                    var _truth = 0;
                    if (is_real(_val))        _truth = (_val != 0);
                    else if (is_string(_val)) _truth = (string_length(_val) > 0);

                    // Execute the chosen arm by reusing the normal dispatcher
                    if (_truth) {
                        if (_then_src != "") handle_basic_command(_then_src, "");
                    } else {
                        if (_else_src != "") handle_basic_command(_else_src, "");
                    }

                    if (dbg_on(DBG_FLOW)) show_debug_message(
                        "INLINE IF (" + string(_truth) + "): THEN='" + _then_src + "' ELSE='" + _else_src + "'"
                    );

                    // *** FIX: If INPUT/PAUSE occurred inside the THEN/ELSE arm,
                    // set a statement-level jump to the NEXT colon segment (p+1)
                    // and return immediately so Step resumes AFTER this IF segment.
                    if (global.pause_in_effect || global.awaiting_input) {
                        if (dbg_on(DBG_FLOW)) show_debug_message("INLINE IF: pausing after arm — scheduling resume at next segment");
                        global.interpreter_use_stmt_jump = true;
                        global.interpreter_target_line   = line_idx;
                        global.interpreter_target_stmt   = p + 1;  // resume at next colon slot (or EOL)
                        return; // yield now
                    }
                }

                // If the inline handler halted with an error, don't synthesize a jump
                if (global.program_has_ended || !global.interpreter_running) {
                    break; // stop dispatching
                }

                // Normal path (no INPUT): advance to the NEXT colon segment on this line.
                global.interpreter_use_stmt_jump = true;
                global.interpreter_target_line   = line_idx;
                global.interpreter_target_stmt   = p + 1;
                break;
            }
            // Else fall-through to the structured IF handler below.
        }

        if (dbg_on(DBG_FLOW)) show_debug_message("COMMAND DISPATCH: " + _verb + " | ARG: " + _rest);

        switch (_verb) {

            case "PRINT":
                if (global.current_mode >= 1) {
                    basic_cmd_print_mode1(_rest);
                } else {
                    basic_cmd_print(_rest, global.current_line_number);
                }
                break;

            case "LET":       basic_cmd_let(_rest); break;
            case "GOTO":      basic_cmd_goto(_rest); break;
            case "INPUT":     basic_cmd_input(_rest); break;
            case "COLOR":     basic_cmd_color(_rest); break;

            case "CLS":
                if (global.current_mode >= 1) { basic_cmd_cls_mode1(); }
                else                           { basic_cmd_cls(); }
                break;

            // Structured control flow (multi-line)
            case "IF":        basic_cmd_if(_rest); break;
            case "ELSEIF":    basic_cmd_elseif(_rest); break;
            case "ELSE":      basic_cmd_else(); break;
            case "ENDIF":     basic_cmd_endif(); break;

            case "FOR":       basic_cmd_for(_rest); break;
            case "NEXT":      basic_cmd_next(_rest); break;
            case "WHILE":     basic_cmd_while(_rest); break;
            case "WEND":      basic_cmd_wend(); break;

            case "GOSUB":     basic_cmd_gosub(_rest); break;
            case "RETURN":    basic_cmd_return(); break;

            case "BGCOLOR":   basic_cmd_bgcolor(_rest); break;
            case "PAUSE":     basic_cmd_pause(); break;
            case "MODE":      basic_cmd_mode(_rest); break;
            case "CLSCHAR":   basic_cmd_clschar(_rest); break;
            case "PSET":      basic_cmd_pset(_rest); break;
            case "CHARAT":    basic_cmd_charat(_rest); break;
            case "PRINTAT":   basic_cmd_printat(_rest); break;
            case "FONT":      basic_cmd_font(_rest); break;
            case "DIM":       basic_cmd_dim(_rest); break; // 1-D arrays

            case "END":       basic_cmd_end(); break;

            case "REM":
                // no-op
                break;

            case "DATA":
                // Runtime no-op (DATA was harvested at load time)
                if (dbg_on(DBG_FLOW)) show_debug_message("DATA (runtime): no-op");
                break;

            case "READ":      basic_cmd_read(_rest); break;
            case "RESTORE":   basic_cmd_restore(_rest); break;

            case "LOCATE":    basic_cmd_locate(_rest); break;
            case "SCROLL":    basic_cmd_scroll(_rest); break;

		case "POS":
		    // If it's being used as a variable assignment (e.g., "POS = 1"),
		    // treat it as an implicit LET. Otherwise it's a function token in expressions,
		    // so do nothing at command level.
		    if (string_pos("=", _rest) > 0) {
		        basic_cmd_let(_verb + " " + _rest);
		    }
		    break;

            case "SCREEN":    // handled as function in expressions
            case "POINT":     // handled as function in expressions
        //    case "POS":       // handled as function in expressions
            case "CSRLIN":    // handled as function in expressions
            case "TAB":       // handled in PRINT processing
            case "SPC":       // handled in PRINT processing
                break;

            case "FONTSET":   basic_cmd_fontset(_rest); break;

            default:
                // implicit LET?  e.g.  "X = 5"
                if (string_pos("=", _verb + " " + _rest) > 0) {
                    basic_cmd_let(_verb + " " + _rest);
                } else {
                    basic_syntax_error("Unknown command: " + _verb,
                        global.current_line_number,
                        global.interpreter_current_stmt_index,
                        "UNKNOWN_COMMAND");
                }
                break;
        }
    }
}


================================================================================

/// @file scripts/handle_command/handle_command.gml

// Script assets have changed for v2.3.0 see
// https://help.yoyogames.com/hc/en-us/articles/360005277377 for more information
function handle_command(command) {
//	show_debug_message("HANDLE_COMMAND called with: " + string(command) + " - paste_manager_exists: " + string(instance_exists(obj_paste_manager)));
   
var original_command = string_trim(command);
    command = string_upper(original_command);
    
    // Split command from parameters to preserve case in filenames
    var space_pos = string_pos(" ", command);
    var cmd_word = "";
    var cmd_params = "";
    
    if (space_pos > 0) {
        cmd_word = string_copy(command, 1, space_pos - 1);
        cmd_params = string_trim(string_copy(original_command, space_pos + 1, string_length(original_command)));
    } else {
        cmd_word = command;
    }
    
    switch (cmd_word) {
        case "LIST":
            if (cmd_params == "") {
                list_program();
            } else {
                list_program_range(cmd_params);
            }
            break;
            
        case "RUN":
            run_program();
            break;
            
        case "NEW":
            new_program();
            break;
            
        case "SAVE":
            if (os_browser != browser_not_a_browser) {
                // HTML build → use browser_file_tools download dialog
                if (cmd_params == "") {
                    editor_html_save_program();
                } else {
                    editor_html_save_program_as(cmd_params);
                }
            } else {
                // Desktop build → use file system save
                if (cmd_params == "") {
                    save_program();
                } else {
                    save_program_as(cmd_params);
                }
            }
            break;

case "CHECK_SAVE_FUNCS":
{
    var s = "browser_show_save_dialog";
    var r = "browser_show_save_dialog_raw";
   if (dbg_on(DBG_FLOW)) show_debug_message("[CHECK] wrapper exists=" + string(function_exists(s)));
   if (dbg_on(DBG_FLOW)) show_debug_message("[CHECK] raw exists=" + string(function_exists(r)));
    break;
}


            
        case "LOAD":
            if (cmd_params == "") {
                show_error_message("FILENAME REQUIRED");
            } else {
                load_program_from(cmd_params);
            }
            break;

		
case "DIR":
    if (os_browser != browser_not_a_browser) {
        var p = string_trim(cmd_params);
        var P = string_upper(p);
        if (P == "" || P == "PROMPT") {
            editor_html_dir_prompt();
        } else if (P == "SHOW") {
            editor_html_dir_show();
        } else if (string_copy(P, 1, 4) == "OPEN") {
            var arg = string_trim(string_delete(p, 1, 4)); // after "OPEN"
            if (string_length(arg) == 0) {
                show_message("Usage: DIR OPEN <index|filename>");
            } else {
                editor_html_dir_open(arg);
            }
        } else if (P != "") {  // Only try to open if there's actually a parameter
            // convenience: if they pass a number or name directly
            editor_html_dir_open(p);
        }
        // Remove the bare else clause that was causing the double call
    } else {
        // Windows: your original code path
        if (cmd_params == "") {
            list_saved_programs();
        } else {
            list_saved_programs(); // preserve your param behavior
        }
    }
    break;

case "HELP":
	help_launch();
	break

case ":PASTE":
{
    // Desktop build: native clipboard
    if (os_browser == browser_not_a_browser) {
        editor_handle_paste_command();
        break;
    }

		editor_html_handle_paste_command();

   if (dbg_on(DBG_FLOW)) show_debug_message("[PASTE] Bound. Click the game, then press Ctrl/Cmd+V.");
}
break;





	    case ":LOADURL":
	        // Expect the rest of the input line to be the URL
	        // If your parser provides 'args', use that. Otherwise, adapt to your arg var.
	        import_from_url(string_trim(args));
	        break;
		
		

		case "QUIT":	
		case "Q":
		quit_program()
		break;

        case "SCREENEDIT":
        case "SE":
            start_screen_editor();
            break;


			
        default:
            show_error_message("SYNTAX ERROR");
            break;
    }
 }

================================================================================

/// @file scripts/help_build_program/help_build_program.gml

/// help_build_program() - CORRECTED VERSION
function help_build_program() {
    // clear current program and line numbers
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // Work out how many topics we're going to list
    var topic_count = ds_list_size(global.help_topics);

    // Seed the runtime variable store
    if (!is_undefined(global.basic_variables)) {
        global.basic_variables[? "TOPIC_COUNT"] = topic_count;
    }

    var add = function(n, s) {
        ds_map_add(global.program_lines, n, s);
        ds_list_add(global.line_numbers, n);
    };

    // ==== BASIC "HELP BROWSER" PROGRAM ====
add(10,"REM NW-BASIC HELP SYSTEM - Clean Version (ASCII-safe)");
add(15,"HDR$ = \"\"             : REM avoid undefined var on first header call");
add(20,"CLS: COLOR YELLOW: HDR$=\"NW-BASIC HELP\": GOSUB 7000");
add(30,"PRINT \"Select a topic by number. 0 returns to editor.\"");
add(35,"REM -- Arrays must exist BEFORE we READ into them");
add(36,"DIM TOPIC$(32), TOPIC_START(32), TOPIC_LEN(32)");
add(37,"DIM SUB$(128), SUBTOPIC_OF(128), SUB_START(128), SUB_LEN(128)");
add(38,"DIM IDX(32)");
add(40,"GOSUB 9500   : REM Load data");
add(50,"REM --- MAIN MENU LOOP ---");
add(60,"CLS: HDR$=\"TOPICS - Select a topic (0=Exit)\": GOSUB 7000");
add(65,"PRINT");
add(70,"FOR I=1 TO TOPIC_COUNT: PRINT I; \") \"; TOPIC$(I): NEXT");
add(80,"PRINT");
add(90,"INPUT \"Topic (0=Exit): \", T");
add(100,"IF T=0 THEN END");
add(110,"IF T<1 OR T>TOPIC_COUNT THEN PRINT \"Invalid.\": GOTO 80");
add(120,"REM --- SUBTOPIC MENU LOOP ---");
add(130,"CLS: HDR$=\"TOPIC: \" + TOPIC$(T) + \"  (0=Back)\": GOSUB 7000");
add(140,"C=0");
add(150,"FOR I=1 TO SUB_COUNT");
add(160,"  IF SUBTOPIC_OF(I)=T THEN C=C+1: PRINT C; \") \"; SUB$(I): IDX(C)=I");
add(170,"NEXT");
add(180,"IF C=0 THEN PRINT \"(No subtopics)\": INPUT \"[ENTER]\", X$: GOTO 50");
add(190,"PRINT");
add(200,"INPUT \"Subtopic (0=Back): \",K");
add(210,"IF K=0 THEN GOTO 50");
add(220,"IF K<1 OR K>C THEN GOTO 190");
add(230,"REM --- SHOW CONTENT ---");
add(240,"I = IDX(K): S = SUB_START(I): N = SUB_LEN(I)");
add(250,"GOSUB 8000");
add(260,"GOTO 120");
add(6999,"REM ---- helpers ----");
add(7000,"REM Print a decorated header (no LEN, no REPEAT$)");
add(7005,"D$=\"\": FOR J=1 TO 40: D$=D$ + \"-\": NEXT");
add(7010,"PRINT D$");
add(7015,"IF HDR$ <> \"\" THEN PRINT HDR$");
add(7020,"PRINT D$");
add(7030,"RETURN");
add(8000,"REM --- CONTENT DISPLAY: seek once to first page, then stream N pages ---");
add(8010,"REM We want pages S..S+N-1. Land on page S once, then read forward.");
add(8030,"RESTORE");
add(8040,"READ TC, SC, PC");
add(8050,"FOR SKT = 1 TO TC: READ TMP$, TMP1, TMP2: NEXT SKT");
add(8060,"FOR SKS = 1 TO SC: READ TMP2$, TMP3, TMP4, TMP5: NEXT SKS");
add(8080,"FOR SK = 1 TO S - 1");
add(8090,"  READ L: FOR R = 1 TO L: READ D$: NEXT R");
add(8100,"NEXT SK");
add(8120,"FOR PP = 1 TO N");
add(8130,"  CLS");
add(8140,"  PRINT \"HELP: \"; SUB$(I)");
add(8150,"  HDR$ = \"TOPIC: \" + TOPIC$( SUBTOPIC_OF(I) ) + \"  (0=Back)\": GOSUB 7000");
add(8160,"  PRINT \"Page \"; PP; \" of \"; N");
add(8170,"  PRINT");
add(8180,"  READ L");
add(8190,"  FOR R = 1 TO L");
add(8200,"    READ D$: PRINT D$");
add(8210,"  NEXT R");
add(8220,"  PRINT");
add(8230,"  INPUT \"[ENTER=Next/Back]\", X$");
add(8240,"NEXT PP");
add(8250,"RETURN");
add(9500,"REM -- Load all data --");
add(9510,"RESTORE");
add(9520,"READ TOPIC_COUNT, SUB_COUNT, PAGE_COUNT");
add(9530,"FOR I=1 TO TOPIC_COUNT: READ TOPIC$(I), TOPIC_START(I), TOPIC_LEN(I): NEXT");
add(9550,"FOR I=1 TO SUB_COUNT: READ SUB$(I), SUBTOPIC_OF(I), SUB_START(I), SUB_LEN(I): NEXT");
add(9560,"RETURN");
add(9900,"DATA 9, 27, 38");
add(9910,"REM Topic data: name, start_page, length");
add(9920,"DATA \"Program Structure\", 1, 2");
add(9921,"DATA \"Variables & Data Types\", 3, 3");
add(9922,"DATA \"Input/Output\", 6, 4");
add(9923,"DATA \"Program Control\", 10, 5");
add(9924,"DATA \"MODE / Graphics\", 15, 5");
add(9925,"DATA \"Math & Random\", 20, 4");
add(9926,"DATA \"Strings\", 24, 3");
add(9927,"DATA \"Data & Arrays\", 27, 5");
add(9928,"DATA \"Editor & Files\", 32, 7");
add(9930,"REM Subtopic data: name, parent_topic, start_page, length");
add(9931,"DATA \"Line Numbers\", 1, 1, 1");
add(9932,"DATA \"Multiple Statements\", 1, 2, 1");
add(9933,"DATA \"LET & Types\", 2, 3, 1");
add(9934,"DATA \"Arrays (DIM)\", 2, 4, 2");
add(9935,"DATA \"PRINT\", 3, 6, 2");
add(9936,"DATA \"INPUT\", 3, 8, 1");
add(9937,"DATA \"CLS/Color\", 3, 9, 1");
add(9938,"DATA \"IF / ELSE / ENDIF\", 4, 10, 2");
add(9939,"DATA \"FOR/NEXT\", 4, 12, 1");
add(9940,"DATA \"WHILE/WEND\", 4, 13, 1");
add(9941,"DATA \"GOTO/GOSUB/RETURN\", 4, 14, 1");
add(9942,"DATA \"MODE 1 & Fonts\", 5, 15, 2");
add(9943,"DATA \"PRINTAT/CHARAT\", 5, 17, 2");
add(9944,"DATA \"CLSCHAR/SCROLL\", 5, 19, 1");
add(9945,"DATA \"Math & Trig\", 6, 20, 2");
add(9946,"DATA \"RND\", 6, 22, 1");
add(9947,"DATA \"Operators\", 6, 23, 1");
add(9948,"DATA \"Substring & Len\", 7, 24, 1");
add(9949,"DATA \"CHR$/ASC\", 7, 25, 1");
add(9950,"DATA \"Concatenation\", 7, 26, 1");
add(9951,"DATA \"DATA/READ/RESTORE\", 8, 27, 2");
add(9952,"DATA \"Named Streams\", 8, 29, 1");
add(9953,"DATA \"Arrays\", 8, 30, 2");
add(9954,"DATA \"Editor Commands\", 9, 32, 3");
add(9955,"DATA \"DIR Overlay\", 9, 35, 1");
add(9956,"DATA \"SAVE/LOAD\", 9, 36, 1");
add(9957,"DATA \"Shortcuts\", 9, 37, 2");
add(10000,"REM === Page 1: Program Structure / Line Numbers ===");
add(10010,"DATA 9");
add(10011,"DATA \"PROGRAM STRUCTURE\"");
add(10012,"DATA \"What: Programs are a list of numbered lines.\"");
add(10013,"DATA \"Syntax: 10 STATEMENT  : 20 STATEMENT\"");
add(10014,"DATA \"Type: 10 PRINT \"\"Hello\"\"  : 20 END\"");
add(10015,"DATA \"Gotchas: Use gaps 10,20,30 so you can insert.\"");
add(10016,"DATA \"Gotchas: A repeated number overwrites that line.\"");
add(10017,"DATA \"See also: Multiple Statements, GOTO, GOSUB\"");
add(10018,"DATA \"SCREENEDIT or SE = full screen editor\"");
add(10019,"DATA \"Use REM or ' to start a comment to end of line\"");
add(10020,"REM === Page 2: Program Structure / Multiple Statements ===");
add(10030,"DATA 7");
add(10031,"DATA \"PROGRAM STRUCTURE\"");
add(10032,"DATA \"What: Put several statements on one line.\"");
add(10033,"DATA \"Syntax: STAT : STAT : STAT\"");
add(10034,"DATA \"Type: 10 A=1: B=2: PRINT A+B\"");
add(10035,"DATA \"Gotchas: Keep lines short for readability.\"");
add(10036,"DATA \"See also: LET & Types, IF, FOR/NEXT\"");
add(10037,"DATA \"\"");
add(10040,"REM === Page 3: Variables & Data Types / LET & Types ===");
add(10050,"DATA 9");
add(10051,"DATA \"VARIABLES & TYPES\"");
add(10052,"DATA \"What: Store numbers or text in named variables.\"");
add(10053,"DATA \"Syntax: A=5  or  LET A=5  ;  N$=\"\"Name\"\"\"");
add(10054,"DATA \"Type: A=3: B=4: PRINT A+B   :  N$=\"\"Joe\"\"\"");
add(10055,"DATA \"Type: PRINT \"\"Hello, \"\" + N$\"");
add(10056,"DATA \"Gotchas: Names ending in $ are strings only.\"");
add(10057,"DATA \"Gotchas: Others are numeric; default is 0.\"");
add(10058,"DATA \"See also: Strings, PRINT\"");
add(10059,"DATA \"\"");
add(10060,"REM === Page 4: Variables & Data Types / Arrays (DIM) p1 ===");
add(10070,"DATA 9");
add(10071,"DATA \"ARRAYS (DIM) - Part 1\"");
add(10072,"DATA \"What: Store many values under one name.\"");
add(10073,"DATA \"Syntax: DIM A(10)  ;  DIM N$(5)\"");
add(10074,"DATA \"Type: DIM A(3): A(1)=10: A(2)=20: PRINT A(1)+A(2)\"");
add(10075,"DATA \"Type: DIM N$(2): N$(1)=\"\"OK\"\": PRINT N$(1)\"");
add(10076,"DATA \"Gotchas: Indexing is 1-based in this build.\"");
add(10077,"DATA \"Gotchas: Out of range gives 0 or empty string.\"");
add(10078,"DATA \"See also: Arrays p2, Data & Arrays\"");
add(10079,"DATA \"\"");
add(10080,"REM === Page 5: Variables & Data Types / Arrays (DIM) p2 ===");
add(10090,"DATA 8");
add(10091,"DATA \"ARRAYS (DIM) - Part 2\"");
add(10092,"DATA \"What: Use expressions for the index.\"");
add(10093,"DATA \"Type: I=3: DIM A(5): A(I-1)=7: PRINT A(2)\"");
add(10094,"DATA \"Type: DIM N$(3): N$(1)=\"\"A\"\": PRINT N$(1)\"");
add(10095,"DATA \"Gotchas: Arrays and scalars are distinct names.\"");
add(10096,"DATA \"Gotchas: Re-DIM by defining before use.\"");
add(10097,"DATA \"See also: Substring & LEN, Data & Arrays\"");
add(10098,"DATA \"\"");
add(10100,"REM === Page 6: Input/Output / PRINT p1 ===");
add(10110,"DATA 9");
add(10111,"DATA \"PRINT - Part 1\"");
add(10112,"DATA \"What: Show text or values on the screen.\"");
add(10113,"DATA \"Syntax: PRINT expr   ;   PRINT A;B   ;   PRINT A,B\"");
add(10114,"DATA \"Type: PRINT \"\"Hello\"\"   :   PRINT 1,2,3\"");
add(10115,"DATA \"Type: A=3: B=4: PRINT \"\"Sum=\"\";A+B\"");
add(10116,"DATA \"Output: 1       2       3\"");
add(10117,"DATA \"Gotchas: A trailing ; keeps the cursor on the line.\"");
add(10118,"DATA \"See also: PRINT p2, INPUT\"");
add(10119,"DATA \"\"");
add(10120,"REM === Page 7: Input/Output / PRINT p2 ===");
add(10130,"DATA 8");
add(10131,"DATA \"PRINT - Part 2\"");
add(10132,"DATA \"What: Format with strings for labels.\"");
add(10133,"DATA \"Type: PRINT \"\"A=\"\"+STR$(5)\"");
add(10134,"DATA \"Type: PRINT \"\"First\"\";: PRINT \"\" line\"\"\"");
add(10135,"DATA \"Gotchas: , uses tab columns; ; no spacing.\"");
add(10136,"DATA \"Gotchas: Use CHR$(13)+CHR$(10) for custom breaks.\"");
add(10137,"DATA \"See also: Strings, CHR$/ASC\"");
add(10138,"DATA \"\"");
add(10140,"REM === Page 8: Input/Output / INPUT ===");
add(10150,"DATA 8");
add(10151,"DATA \"INPUT\"");
add(10152,"DATA \"What: Ask the user for a number or text.\"");
add(10153,"DATA \"Syntax: INPUT \"\"Prompt: \"\", X   or   INPUT \"\"Name: \"\", N$\"");
add(10154,"DATA \"Type: INPUT \"\"Name: \"\", N$: PRINT \"\"Hello, \"\";N$\"");
add(10155,"DATA \"INKEY$ returns one key from the queue; \"\"\"\" if none\"");
add(10156,"DATA \"Gotchas: Use $ names for text; others are numeric.\"");
add(10157,"DATA \"Gotchas: Entering nothing keeps current value.\"");
add(10158,"DATA \"See also: PRINT, IF, Shortcuts\"");
add(10160,"REM === Page 9: Input/Output / CLS & Color ===");
add(10170,"DATA 8");
add(10171,"DATA \"CLS & COLOR\"");
add(10172,"DATA \"What: Clear the screen and set text color.\"");
add(10173,"DATA \"Syntax: CLS    ;   COLOR YELLOW\"");
add(10174,"DATA \"Type: CLS: COLOR YELLOW: PRINT \"\"Ready\"\"\"");
add(10175,"DATA \"Gotchas: Use a small set of named colors.\"");
add(10176,"DATA \"Gotchas: Clear before drawing a new view.\"");
add(10177,"DATA \"See also: MODE 1, PRINTAT\"");
add(10178,"DATA \"\"");
add(10180,"REM === Page 10: Program Control / IF-ELSE-ENDIF p1 ===");
add(10190,"DATA 9");
add(10191,"DATA \"IF / ELSE / ENDIF - Part 1\"");
add(10192,"DATA \"What: Run code only when a test is true.\"");
add(10193,"DATA \"Syntax:\"");
add(10194,"DATA \"IF A>0 THEN\"");
add(10195,"DATA \"  PRINT \"\"POSITIVE\"\"\"");
add(10196,"DATA \"ELSE\"");
add(10197,"DATA \"  PRINT \"\"NON-POSITIVE\"\"\"");
add(10198,"DATA \"ENDIF\"");
add(10199,"DATA \"\"");
add(10200,"REM === Page 11: Program Control / IF-ELSE-ENDIF p2 ===");
add(10210,"DATA 7");
add(10211,"DATA \"IF / ELSE / ENDIF - Part 2\"");
add(10212,"DATA \"What: Single-line IF for short actions.\"");
add(10213,"DATA \"Type: IF A=0 THEN PRINT \"\"ZERO\"\"\"");
add(10214,"DATA \"Gotchas: Use parentheses to group tests.\"");
add(10215,"DATA \"Gotchas: Strings compare with = and <>.\"");
add(10216,"DATA \"See also: FOR/NEXT, WHILE/WEND\"");
add(10217,"DATA \"\"");
add(10220,"REM === Page 12: Program Control / FOR-NEXT ===");
add(10230,"DATA 8");
add(10231,"DATA \"FOR / NEXT\"");
add(10232,"DATA \"What: Repeat a block a set number of times.\"");
add(10233,"DATA \"Syntax: FOR I=start TO end [STEP s] ... NEXT\"");
add(10234,"DATA \"Type: FOR I=1 TO 5: PRINT I: NEXT\"");
add(10235,"DATA \"Type: FOR T=10 TO 0 STEP -2: PRINT T: NEXT\"");
add(10236,"DATA \"Gotchas: Do not change I inside the loop.\"");
add(10237,"DATA \"See also: WHILE/WEND, IF\"");
add(10238,"DATA \"\"");
add(10240,"REM === Page 13: Program Control / WHILE-WEND ===");
add(10250,"DATA 6");
add(10251,"DATA \"WHILE / WEND\"");
add(10252,"DATA \"What: Repeat while a condition is true.\"");
add(10253,"DATA \"Syntax: WHILE cond: ... : WEND\"");
add(10254,"DATA \"Type: A=3: WHILE A>0: PRINT A: A=A-1: WEND\"");
add(10255,"DATA \"Gotchas: Ensure progress to avoid an infinite loop.\"");
add(10256,"DATA \"\"");
add(10260,"REM === Page 14: Program Control / GOTO-GOSUB-RETURN ===");
add(10270,"DATA 8");
add(10271,"DATA \"GOTO / GOSUB / RETURN\"");
add(10272,"DATA \"What: Jump or call a subroutine by line number.\"");
add(10273,"DATA \"Type: 100 GOSUB 900 : PRINT \"\"Back\"\" : END\"");
add(10274,"DATA \"Type: 900 PRINT \"\"Hi\"\": RETURN\"");
add(10275,"DATA \"Gotchas: RETURN goes to the line after GOSUB.\"");
add(10276,"DATA \"Gotchas: Use small helpers; avoid deep nesting.\"");
add(10277,"DATA \"See also: Line Numbers, IF\"");
add(10278,"DATA \"\"");
add(10280,"REM === Page 15: MODE / Graphics / MODE1 & Fonts p1 ===");
add(10290,"DATA 8");
add(10291,"DATA \"MODE 1 & FONTS - Part 1\"");
add(10292,"DATA \"What: Character grid display with sprite fonts.\"");
add(10293,"DATA \"Syntax: FONT \"\"DEFAULT_16\"\"\"");
add(10294,"DATA \"Type: FONT \"\"DEFAULT_16\"\": PRINT \"\"Hello\"\"\"");
add(10295,"DATA \"Gotchas: Tile size sets columns and rows.\"");
add(10296,"DATA \"Gotchas: Keep a consistent font for readability.\"");
add(10297,"DATA \"See also: PRINTAT/CHARAT\"");
add(10298,"DATA \"\"");
add(10300,"REM === Page 16: MODE / Graphics / MODE1 & Fonts p2 ===");
add(10310,"DATA 7");
add(10311,"DATA \"MODE 1 & FONTS - Part 2\"");
add(10312,"DATA \"What: Pick a tile size for your layout.\"");
add(10313,"DATA \"Guide: 16x16 is readable; 8x8 fits more text.\"");
add(10314,"DATA \"Tip: Test on your target window size.\"");
add(10315,"DATA \"Tip: Use headers and spacing to reduce clutter.\"");
add(10316,"DATA \"See also: PRINTAT/CHARAT, CLSCHAR/SCROLL\"");
add(10317,"DATA \"\"");
add(10320,"REM === Page 17: MODE / Graphics / PRINTAT-CHARAT p1 ===");
add(10330,"DATA 8");
add(10331,"DATA \"PRINTAT / CHARAT - Part 1\"");
add(10332,"DATA \"What: Draw at a grid position.\"");
add(10333,"DATA \"Syntax: PRINTAT x,y,\"\"Text\"\"\"");
add(10334,"DATA \"Syntax: CHARAT x,y,code[,fg[,bg]]\"");
add(10335,"DATA \"Type: PRINTAT 1,1,\"\"TOP\"\"\"");
add(10336,"DATA \"Type: CHARAT 10,5,45  ' draw '-'\"");
add(10337,"DATA \"See also: MODE 1, CLSCHAR/SCROLL\"");
add(10338,"DATA \"\"");
add(10340,"REM === Page 18: MODE / Graphics / PRINTAT-CHARAT p2 ===");
add(10350,"DATA 7");
add(10351,"DATA \"PRINTAT / CHARAT - Part 2\"");
add(10352,"DATA \"Tip: To center: start=(cols-LEN)/2 (manual).\"");
add(10353,"DATA \"Tip: Redraw only the parts that change.\"");
add(10354,"DATA \"Tip: Keep a cursor state if you blink text.\"");
add(10355,"DATA \"Tip: Use constants for colors and codes.\"");
add(10356,"DATA \"See also: MODE 1, DIR Overlay\"");
add(10357,"DATA \"\"");
add(10360,"REM === Page 19: MODE / Graphics / CLSCHAR-SCROLL ===");
add(10370,"DATA 7");
add(10371,"DATA \"CLSCHAR / SCROLL\"");
add(10372,"DATA \"What: Fill the screen or move text rows.\"");
add(10373,"DATA \"Syntax: CLSCHAR code[,fg[,bg]]\"");
add(10374,"DATA \"Syntax: SCROLL dir[,rows]\"");
add(10375,"DATA \"Tip: Use SCROLL for pager effects.\"");
add(10376,"DATA \"See also: PRINTAT, Page Reader\"");
add(10377,"DATA \"\"");
add(10380,"REM === Page 20: Math & Random / Math & Trig p1 ===");
add(10390,"DATA 8");
add(10391,"DATA \"MATH & TRIG - Part 1\"");
add(10392,"DATA \"What: Common numeric functions.\"");
add(10393,"DATA \"Funcs: ABS, INT, SGN, EXP, LOG\"");
add(10394,"DATA \"Funcs: SIN, COS, TAN   (radians)\"");
add(10395,"DATA \"Type: PRINT ABS(-3), INT(3.9)\"");
add(10396,"DATA \"Tip: Use parentheses for clarity.\"");
add(10397,"DATA \"See also: Operators, RND\"");
add(10398,"DATA \"\"");
add(10400,"REM === Page 21: Math & Random / Math & Trig p2 ===");
add(10410,"DATA 7");
add(10411,"DATA \"MATH & TRIG - Part 2\"");
add(10412,"DATA \"What: More math helpers and tips.\"");
add(10413,"DATA \"Type: PRINT SGN(-5), EXP(1)\"");
add(10414,"DATA \"Tip: Compare floats with a small tolerance.\"");
add(10415,"DATA \"Tip: Use MOD for wrap-around indices.\"");
add(10416,"DATA \"See also: RND, Operators\"");
add(10417,"DATA \"\"");
add(10420,"REM === Page 22: Math & Random / RND ===");
add(10430,"DATA 7");
add(10431,"DATA \"RND\"");
add(10432,"DATA \"What: Random number generator.\"");
add(10433,"DATA \"Type: PRINT RND()         ' 0.0..1.0\"");
add(10434,"DATA \"Type: PRINT RND(6)       ' 1..6\"");
add(10435,"DATA \"Type: PRINT RND(2,5)     ' 2..5\"");
add(10436,"DATA \"See also: Math & Trig, Operators\"");
add(10437,"DATA \"\"");
add(10440,"REM === Page 23: Math & Random / Operators ===");
add(10450,"DATA 7");
add(10451,"DATA \"OPERATORS\"");
add(10452,"DATA \"What: + - * /  \\  MOD  ^  and comparisons.\"");
add(10453,"DATA \"Type: PRINT 3+4*2, 7 MOD 5, 5^2\"");
add(10454,"DATA \"Tip: '\\' is integer divide; trunc toward zero.\"");
add(10455,"DATA \"Tip: Use parentheses to control order.\"");
add(10456,"DATA \"See also: Math & Trig\"");
add(10457,"DATA \"\"");
add(10460,"REM === Page 24: Strings / Substring & LEN ===");
add(10470,"DATA 8");
add(10471,"DATA \"STRINGS - Substrings\"");
add(10472,"DATA \"What: Slice parts of a string.\"");
add(10473,"DATA \"Syntax: LEFT$(S$,N), RIGHT$(S$,N), MID$(S$,s,l)\"");
add(10474,"DATA \"Type: S$=\"\"HELLO\"\": PRINT LEFT$(S$,2)   ' HE\"");
add(10475,"DATA \"Type: PRINT MID$(S$,2,3)               ' ELL\"");
add(10476,"DATA \"Note: LEN is not provided in this build.\"");
add(10477,"DATA \"See also: CHR$/ASC, Concatenation, REPEAT$\"");
add(10478,"DATA \"\"");
add(10480,"REM === Page 25: Strings / CHR$ & ASC ===");
add(10490,"DATA 7");
add(10491,"DATA \"STRINGS - CHR$ & ASC\"");
add(10492,"DATA \"What: Convert between codes and characters.\"");
add(10493,"DATA \"Type: PRINT CHR$(65)      ' A\"");
add(10494,"DATA \"Type: PRINT ASC(\"\"A\"\")     ' 65\"");
add(10495,"DATA \"Tip: Useful for line chars or input parsing.\"");
add(10496,"DATA \"See also: Substrings, Concatenation\"");
add(10497,"DATA \"\"");
add(10500,"REM === Page 26: Strings / Concatenation ===");
add(10510,"DATA 8");
add(10511,"DATA \"STRINGS - Concatenation, semicolon or +\"");
add(10512,"DATA \"What: Join strings with +.\"");
add(10513,"DATA \"Type: NAME$=\"\"Ada\"\": PRINT \"\"Hi, \"\"+NAME$\"");
add(10514,"DATA \"Type: PRINT \"\"A=\"\" + STR$(3)\"");
add(10515,"DATA \"Type: PRINT REPEAT$(\"\"-\"\",5) ' -----\"");
add(10516,"DATA \"Semicolon = no line feed after string\"");
add(10517,"DATA \"Tip: Build long lines piece by piece.\"");
add(10518,"DATA \"See also: PRINT, Substrings, REPEAT$\"");
add(10520,"REM === Page 27: Data & Arrays / DATA-READ-RESTORE p1 ===");
add(10530,"DATA 8");
add(10531,"DATA \"DATA / READ / RESTORE - Part 1\"");
add(10532,"DATA \"What: Store constants in the code and read them.\"");
add(10533,"DATA \"Syntax: DATA ...  ;  READ A,B$  ;  RESTORE\"");
add(10534,"DATA \"Type: RESTORE: READ N$,X: PRINT N$,X\"");
add(10535,"DATA \"Type: DATA \"\"OK\"\", 42\"");
add(10536,"DATA \"Tip: Keep tables grouped at the end.\"");
add(10537,"DATA \"See also: Named Streams, Arrays\"");
add(10538,"DATA \"\"");
add(10540,"REM === Page 28: Data & Arrays / DATA-READ-RESTORE p2 ===");
add(10550,"DATA 8");
add(10551,"DATA \"DATA / READ / RESTORE - Part 2\"");
add(10552,"DATA \"What: Seek by rewinding then skipping blocks.\"");
add(10553,"DATA \"Step 1: RESTORE\"");
add(10554,"DATA \"Step 2: READ past headers and tables\"");
add(10555,"DATA \"Step 3: Skip pages by count to your target\"");
add(10556,"DATA \"This help program uses that exact pattern.\"");
add(10557,"DATA \"See also: Page Reader code path\"");
add(10558,"DATA \"\"");
add(10560,"REM === Page 29: Data & Arrays / Named Streams ===");
add(10570,"DATA 7");
add(10571,"DATA \"NAMED DATA STREAMS\"");
add(10572,"DATA \"What: Keep multiple logical DATA streams.\"");
add(10573,"DATA \"Syntax: RESTORE but no line #;   READ ...\"");
add(10574,"DATA \"\"");
add(10575,"DATA \"Use: Separate content tables by purpose.\"");
add(10576,"DATA \"See also: DATA/READ/RESTORE\"");
add(10577,"DATA \"\"");
add(10580,"REM === Page 30: Data & Arrays / Arrays topic p1 ===");
add(10590,"DATA 7");
add(10591,"DATA \"ARRAYS - Topic (Part 1)\"");
add(10592,"DATA \"What: Use arrays for menus and listings.\"");
add(10593,"DATA \"Type: DIM IDX(32): IDX(1)=7: PRINT IDX(1)\"");
add(10594,"DATA \"Tip: 1-based loops pair well with arrays.\"");
add(10595,"DATA \"Tip: Always check user input bounds.\"");
add(10596,"DATA \"See also: Arrays p2, INPUT\"");
add(10597,"DATA \"\"");
add(10600,"REM === Page 31: Data & Arrays / Arrays topic p2 ===");
add(10610,"DATA 7");
add(10611,"DATA \"ARRAYS - Topic (Part 2)\"");
add(10612,"DATA \"What: Store records in parallel arrays.\"");
add(10613,"DATA \"Type: DIM A(3),B$(3): A(1)=10: B$(1)=\"\"OK\"\"\"");
add(10614,"DATA \"\"");
add(10615,"DATA \"\"");
add(10616,"DATA \"See also: Data & Arrays\"");
add(10617,"DATA \"\"");
add(10620,"REM === Page 32: Editor & Files / Editor Commands p1 ===");
add(10630,"DATA 8");
add(10631,"DATA \"EDITOR COMMANDS - Part 1\"");
add(10632,"DATA \"What: Basic editor actions.\"");
add(10633,"DATA \"Type: LIST   : RUN   : NEW   : SAVE \"\"NAME\"\"\"");
add(10634,"DATA \"Use: COPY then :PASTE to move blocks of code\"");
add(10635,"DATA \"Use: DIR overlay to pick files\"");
add(10636,"DATA \"Tip: Keep frequent saves and backups.\"");
add(10637,"DATA \"See also: Shortcuts, DIR Overlay\"");
add(10638,"DATA \"\"");
add(10640,"REM === Page 33: Editor & Files / Editor Commands p2 ===");
add(10650,"DATA 7");
add(10651,"DATA \"EDITOR COMMANDS - Part 2\"");
add(10652,"DATA \"What: Edit by line number; retype to replace.\"");
add(10653,"DATA \"Use: LIST to view lines; NEW clears program\"");
add(10654,"DATA \"Use: RUN to execute; ESC to stop\"");
add(10655,"DATA \"Tip: Save often with SAVE \"\"NAME\"\"\"");
add(10656,"DATA \"SCREENEDIT or SE to load full screen editor.\"");
add(10657,"DATA \"See also: SAVE/LOAD\"");
add(10660,"REM === Page 34: Editor & Files / Editor Commands p3 ===");
add(10670,"DATA 7");
add(10671,"DATA \"EDITOR COMMANDS - Part 3\"");
add(10672,"DATA \"What: Debugging tips.\"");
add(10673,"DATA \"Use: Console logs for tracing (HTML)\"");
add(10674,"DATA \"Use: RUN to Run Program, ESC to stop\"");
add(10675,"DATA \"\"");
add(10676,"DATA \"See also: Shortcuts\"");
add(10677,"DATA \"\"");
add(10680,"REM === Page 35: Editor & Files / DIR Overlay ===");
add(10690,"DATA 7");
add(10691,"DATA \"DIR OVERLAY\"");
add(10692,"DATA \"What: Pick files from a directory overlay.\"");
add(10693,"DATA \"Keys: Arrows to move, ENTER select, ESC cancel\"");
add(10694,"DATA \"Tip: Pause editor input while overlay is open.\"");
add(10695,"DATA \"Tip: Validate names and paths.\"");
add(10696,"DATA \"See also: SAVE/LOAD\"");
add(10697,"DATA \"NOTE: Currently some oddities 9 Sept 2025\"");
add(10700,"REM === Page 36: Editor & Files / SAVE-LOAD ===");
add(10710,"DATA 8");
add(10711,"DATA \"SAVE / LOAD\"");
add(10712,"DATA \"What: Save a program and load it later.\"");
add(10713,"DATA \"Type: SAVE \"\"DEMO\"\"   :   LOAD \"\"DEMO\"\"\"");
add(10714,"DATA \"Tip: Avoid spaces or odd characters in \"");
add(10715,"DATA \"names.\"");
add(10716,"DATA \"Tip: Confirm overwrite; keep versions.\"");
add(10717,"DATA \"Tip: Consider auto-save on run or exit.\"");
add(10718,"DATA \"See also: Editor Commands, DIR Overlay\"");
add(10720,"REM === Page 37: Editor & Files / Shortcuts p1 ===");
add(10730,"DATA 7");
add(10731,"DATA \"SHORTCUTS - Part 1\"");
add(10732,"DATA \"F5 Dumps program to Console (HTML); ESC = STOP\"");
add(10733,"DATA \"Ctrl+C Copy   ;   Ctrl+V Paste (browser perms)\"");
add(10734,"DATA \"Command: HELP to open this help\"");
add(10735,"DATA \"Tip: Show hints in the status bar.\"");
add(10736,"DATA \"SE short for SCREENEDIT; Full screen editor\"");
add(10737,"DATA \"See also: Shortcuts p2\"");
add(10740,"REM === Page 38: Editor & Files / Shortcuts p2 ===");
add(10750,"DATA 7");
add(10751,"DATA \"SHORTCUTS - Part 2\"");
add(10752,"DATA \"Tips: Keep lines short; use gaps 10,20,30\"");
add(10753,"DATA \"Tips: Label output: PRINT \"\"A=\"\" ; A\"");
add(10754,"DATA \"Tips: Use comments with REM or '\"");
add(10755,"DATA \"Tips: Re-run often; save before big edits\"");
add(10756,"DATA \"See also: Editor Commands\"");
add(10757,"DATA \"\"");

}

================================================================================

/// @file scripts/help_build_topics/help_build_topics.gml

/// Build/refresh the in-memory help topics tree
function help_build_topics() {
    // Initialize help_state if it doesn't exist
    if (!variable_global_exists("help_state")) {
        global.help_state = { built: false };
    }
    
    // Initialize or recreate list
    if (!variable_global_exists("help_topics") || !ds_exists(global.help_topics, ds_type_list)) {
        global.help_topics = ds_list_create();
    } else {
        ds_list_clear(global.help_topics);
    }

    // ==== Topics ====
    
    // Topic 1: Editor Commands
    var t1 = { title: "Editor Commands", subs: [] };
    array_push(t1.subs, { 
        title: "RUN / NEW / CLEAR / LIST", 
        lines: [
            "RUN - Execute the current BASIC program.",
            "NEW or CLEAR - Remove all lines from memory.",
            "LIST [start-end] - Show program lines.",
            "F5 - Dump listing to console."
        ]
    });
    array_push(t1.subs, { 
        title: "FILES: SAVE / LOAD / DIR", 
        lines: [
            "SAVE \"name\" - Adds .BAS, writes to Documents/BasicInterpreter.",
            "LOAD \"name\" - Loads program.",
            "DIR - Interactive browser (arrows, Enter, D/X delete, ESC quit)."
        ]
    });
    ds_list_add(global.help_topics, t1);

    // Topic 2: Language Basics
    var t2 = { title: "Language Basics", subs: [] };
    array_push(t2.subs, { 
        title: "Lines, Variables, PRINT", 
        lines: [
            "Lines run in numeric order unless redirected.",
            "Numeric vars: A, X1; Strings: NAME$; Arrays: DIM A(10).",
            "PRINT text or values; ; keeps the cursor on the line."
        ]
    });
    array_push(t2.subs, { 
        title: "INPUT / INKEY$", 
        lines: [
            "INPUT prompts and waits; assigns to variable.",
            "INKEY$ returns last key (\"\" when none).",
            "Extended keys return 2-char sequences."
        ]
    });
    ds_list_add(global.help_topics, t2);

    // Topic 3: Control Flow
    var t3 = { title: "Control Flow", subs: [] };
    array_push(t3.subs, { 
        title: "IF / ELSE / ENDIF", 
        lines: [
            "Inline IF: IF X=1 THEN PRINT \"HI\"",
            "Block IF ... ELSE ... ENDIF is supported."
        ]
    });
    array_push(t3.subs, { 
        title: "FOR / NEXT, WHILE / WEND", 
        lines: [
            "FOR I=1 TO 10 [STEP S] ... NEXT",
            "WHILE condition ... WEND"
        ]
    });
    ds_list_add(global.help_topics, t3);

    // Topic 4: MODE 1 (Tile) Basics
    var t4 = { title: "MODE 1 (Tile) Basics", subs: [] };
    array_push(t4.subs, { 
        title: "PRINTAT / CHARAT / PSET", 
        lines: [
            "PRINTAT x,y,\"TEXT\"[,FG,BG]",
            "CHARAT x,y,code[,FG,BG] places a tile/char.",
            "PSET x,y,code[,FG,BG,BG] shorthand."
        ]
    });
    // Topic 5: Math & Random
    var t5 = { title: "Math & Random", subs: [] };
    array_push(t5.subs, { 
        title: "Math Functions", 
        lines: [
            "ABS, INT, SGN, EXP, LOG, LOG10",
            "SIN, COS, TAN (work in radians)",
            "^ for exponentiation",
            "Standard operator precedence"
        ]
    });
    array_push(t5.subs, { 
        title: "Random Numbers", 
        lines: [
            "RND(6) returns 1 to 6",
            "RND(1,10) returns range 1 to 10", 
            "RND or RND(1) returns 0 to 1"
        ]
    });
    ds_list_add(global.help_topics, t5);

    // Topic 6: Strings
    var t6 = { title: "Strings", subs: [] };
    array_push(t6.subs, { 
        title: "String Functions", 
        lines: [
            "LEFT$, RIGHT$, MID$ for substrings",
            "LEN for string length",
            "CHR$(65) converts to \"A\"",
            "ASC(\"A\") converts to 65"
        ]
    });
    ds_list_add(global.help_topics, t6);

    // Topic 7: Data & Arrays  
    var t7 = { title: "Data & Arrays", subs: [] };
    array_push(t7.subs, { 
        title: "DATA/READ/RESTORE", 
        lines: [
            "DATA statement stores values",
            "READ loads into variables", 
            "RESTORE resets to start",
            "Named streams: DATA @name: values"
        ]
    });
    array_push(t7.subs, { 
        title: "Arrays", 
        lines: [
            "DIM A(10) creates array 0 to 10",
            "Use in loops: FOR I=0 TO 10",
            "Multi-dimensional: DIM A(5,5)",
            "Dynamic sizing: DIM A(X+5)"
        ]
    });
    ds_list_add(global.help_topics, t7);

    // Topic 8: Input/Output
    var t8 = { title: "Input/Output", subs: [] };
    array_push(t8.subs, { 
        title: "PRINT Variations", 
        lines: [
            "PRINT X prints value and newline",
            "PRINT X; keeps cursor on line",
            "PRINT X,Y,Z uses tab columns",
            "PRINT without args = blank line"
        ]
    });
    array_push(t8.subs, { 
        title: "INPUT and Keys", 
        lines: [
            "INPUT \"Prompt: \",VAR waits for input",
            "INKEY$ returns last key pressed",
            "CLS clears screen",
            "COLOR FG,BG sets colors"
        ]
    });
    ds_list_add(global.help_topics, t8);

    // Topic 9: Editor & Files
    var t9 = { title: "Editor & Files", subs: [] };
    array_push(t9.subs, { 
        title: "File Operations", 
        lines: [
            "SAVE \"filename\" saves program",
            "LOAD \"filename\" loads program",
            "DIR opens file browser",
            "Drag & drop .BAS files to load"
        ]
    });
    array_push(t9.subs, { 
        title: "Editor Commands", 
        lines: [
            "LIST shows program lines",
            "RUN executes program",
            "NEW or CLEAR erases program",
            "F5 dumps to console"
        ]
    });
    ds_list_add(global.help_topics, t9);

    global.help_state.built = true;
}

================================================================================

/// @file scripts/help_launch/help_launch.gml

/// help_launch()
function help_launch() {
    // Always build the help topics to ensure they're current
    help_build_topics();
    
    // Save current program state
    help_snapshot_program();
    
    // Build the help browser program
    help_build_program();
    
    // Set help active flag
    global.help_active = true;
    
    // Initialize BASIC variables if they don't exist
    if (!variable_global_exists("basic_variables")) {
        global.basic_variables = ds_map_create();
    }
    
    // Set the help done flag to false initially
    global.basic_variables[? "HELP_DONE"] = 0;
    
    // Launch the interpreter with the help program
    run_program();
}

================================================================================

/// @file scripts/help_restore_program/help_restore_program.gml

/// help_restore_program()
function help_restore_program() {
    if (!variable_global_exists("help_snapshot_lines")) return;

    // wipe current
    if (ds_exists(global.program_lines, ds_type_map)) ds_map_clear(global.program_lines);
    if (ds_exists(global.line_numbers, ds_type_list)) ds_list_clear(global.line_numbers);

    // restore
    var key = ds_map_find_first(global.help_snapshot_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.help_snapshot_lines, key);
        ds_map_add(global.program_lines, key, val);
        key = ds_map_find_next(global.help_snapshot_lines, key);
    }
    for (var i = 0; i < ds_list_size(global.help_snapshot_nums); i++) {
        ds_list_add(global.line_numbers, ds_list_find_value(global.help_snapshot_nums, i));
    }

    // clean snapshot
    ds_map_destroy(global.help_snapshot_lines);
    ds_list_destroy(global.help_snapshot_nums);
    global.help_snapshot_lines = undefined;
    global.help_snapshot_nums  = undefined;
}



================================================================================

/// @file scripts/help_snapshot_program/help_snapshot_program.gml

/// help_snapshot_program()
function help_snapshot_program() {
    // destroy any old snapshot
    if (variable_global_exists("help_snapshot_lines") && ds_exists(global.help_snapshot_lines, ds_type_map)) {
        ds_map_destroy(global.help_snapshot_lines);
    }
    if (variable_global_exists("help_snapshot_nums") && ds_exists(global.help_snapshot_nums, ds_type_list)) {
        ds_list_destroy(global.help_snapshot_nums);
    }

    // deep copy maps/lists you mutate during load/run
    global.help_snapshot_lines = ds_map_create();
    var key = ds_map_find_first(global.program_lines);
    while (!is_undefined(key)) {
        var val = ds_map_find_value(global.program_lines, key);
        ds_map_add(global.help_snapshot_lines, key, val);
        key = ds_map_find_next(global.program_lines, key);
    }

    global.help_snapshot_nums = ds_list_create();
    for (var i = 0; i < ds_list_size(global.line_numbers); i++) {
        ds_list_add(global.help_snapshot_nums, ds_list_find_value(global.line_numbers, i));
    }
}



================================================================================

/// @file scripts/infix_to_postfix/infix_to_postfix.gml

/// @script infix_to_postfix
// === BEGIN: infix_to_postfix ===
function infix_to_postfix(tokens) {
    if (dbg_on(DBG_PARSE)) show_debug_message("Converting to postfix: " + string(tokens));

    var output = [];
    var stack  = [];

    var _TOKU = function(_t) { return string_upper(string(_t)); };

    var _push_all = function(_dst, _src) {
        for (var __i = 0; __i < array_length(_src); __i++) array_push(_dst, _src[__i]);
    };

    var _is_zero_arg_fn = function(_name) {
        var n = string_upper(_name);
        return (n == "TIMER" || n == "TIME$" || n == "DATE$" || n == "INKEY$");
    };

    var _is_STRING_fn = function(_name) {
        return string_upper(string(_name)) == "STRING$";
    };

    // pass tokens explicitly so we don't rely on closure capture
    var _read_paren_payload = function(_tokens, _start) {
        var _depth = 0, j = _start, inner = "", matched = false;
        while (j < array_length(_tokens)) {
            var tk = _tokens[j];
            if (tk == "(") {
                _depth++;
                if (_depth > 1) inner += tk;
            } else if (tk == ")") {
                _depth--;
                if (_depth == 0) { matched = true; break; }
                inner += tk;
            } else {
                inner += tk;
            }
            j++;
        }
        return [matched, inner, j];
    };

    for (var i = 0; i < array_length(tokens); i++) {
        var t  = tokens[i];

        if (t == ",") { if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Skipping comma token"); continue; }

        var tu = _TOKU(t);

        // 1) ARRAY READ COLLAPSE
        if (is_string(t)) {
            var first = string_char_at(t, 1);
            var can_be_name = is_letter(first);

            if (can_be_name && i + 1 < array_length(tokens) && tokens[i + 1] == "("
            && !(is_function(t) || _is_STRING_fn(t))) {
                if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Candidate for array collapse → '" + string(t) + "' followed by '('");
                var arr_info = _read_paren_payload(tokens, i + 1);
                var matched  = arr_info[0];
                var inner    = arr_info[1];
                var j        = arr_info[2];

                if (matched) {
                    var collapsed = string(t) + "(" + inner + ")";
                    array_push(output, collapsed);
                    if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: Collapsed array read token → '" + collapsed + "' (consumed through index " + string(j) + ")");
                    i = j;
                    continue;
                } else {
                    if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: WARNING — unmatched '(' after '" + string(t) + "'. Not collapsing.");
                }
            }
        }

        // 2) NUMERIC LITERAL
        if (is_numeric_string(t)) { array_push(output, t); if (dbg_on(DBG_PARSE)) show_debug_message("Added number to output: " + string(t)); continue; }

        // 3) KNOWN VARIABLE
        if (ds_map_exists(global.basic_variables, tu)) { array_push(output, tu); if (dbg_on(DBG_PARSE)) show_debug_message("Added variable name to output: " + tu); continue; }

        // 4) OPEN PAREN
        if (t == "(") { array_push(stack, t); if (dbg_on(DBG_PARSE)) show_debug_message("Pushed '(' onto operator stack"); continue; }

        // 5) CLOSE PAREN
        if (t == ")") {
            while (array_length(stack) > 0 && stack[array_length(stack) - 1] != "(") {
                var popped_close = array_pop(stack);
                array_push(output, popped_close);
                if (dbg_on(DBG_PARSE)) show_debug_message("Popped '" + string(popped_close) + "' from stack to output (closing ')')");
            }
            if (array_length(stack) > 0 && stack[array_length(stack) - 1] == "(") {
                array_pop(stack);
                if (dbg_on(DBG_PARSE)) show_debug_message("Discarded matching '(' from stack");
            } else {
                if (dbg_on(DBG_PARSE)) show_debug_message("INFIX: WARNING — stray ')' with no matching '('");
            }
            continue;
        }

        // 6) OPERATORS
        if (is_operator(t)) {
            if (dbg_on(DBG_PARSE)) show_debug_message("Found operator: " + string(t));
            while (array_length(stack) > 0) {
                var top = stack[array_length(stack) - 1];
                if (is_operator(top) && (get_precedence(top) > get_precedence(t)
                || (get_precedence(top) == get_precedence(t) && !is_right_associative(t)))) {
                    var popped_op = array_pop(stack);
                    array_push(output, popped_op);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Popped higher/equal precedence operator '" + string(popped_op) + "' to output");
                } else break;
            }
            array_push(stack, t);
            if (dbg_on(DBG_PARSE)) show_debug_message("Pushed operator '" + string(t) + "' onto stack");
            continue;
        }

        // 7) FUNCTIONS
        if (is_function(t) || _is_STRING_fn(t)) {
            var fn_name = tu;

            // Zero-arg functions emit directly
            if (_is_zero_arg_fn(fn_name)) {
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("Processed zero-arg function: " + fn_name);
                continue;
            }

            // Must be followed by '('
            if (!(i + 1 < array_length(tokens) && tokens[i + 1] == "(")) {
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("Function without '(': passing through → " + fn_name);
                continue;
            }

            // Read (...): pass tokens explicitly
            var f_info  = _read_paren_payload(tokens, i + 1);
            var f_ok    = f_info[0];
            var f_inner = f_info[1];
            var f_end   = f_info[2];

            if (!f_ok) {
                array_push(output, fn_name);
                if (dbg_on(DBG_PARSE)) show_debug_message("WARNING: unmatched '(' for function " + fn_name + " — passing through");
                continue;
            }

            // ---------- SPECIAL: STRING$(x, n) ----------
            if (fn_name == "STRING$") {
                var lvl = 0, part = "", parts = [];
                for (var ci = 1; ci <= string_length(f_inner); ci++) {
                    var ch = string_char_at(f_inner, ci);
                    if (ch == "(") { lvl++; part += ch; }
                    else if (ch == ")") { lvl--; part += ch; }
                    else if (ch == "," && lvl == 0) { array_push(parts, string_trim(part)); part = ""; }
                    else { part += ch; }
                }
                array_push(parts, string_trim(part));

                if (array_length(parts) == 2) {
                    var t1 = basic_tokenize_expression_v2(parts[0]);
                    var t2 = basic_tokenize_expression_v2(parts[1]);
                    var p1 = infix_to_postfix(t1);
                    var p2 = infix_to_postfix(t2);
                    _push_all(output, p1);
                    _push_all(output, p2);
                    array_push(output, fn_name);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed STRING$(x,n): args = [" + parts[0] + "], [" + parts[1] + "]");
                    i = f_end;
                    continue;
                }
                // fall through to generic handling if malformed
            }

            // ---------- SPECIAL: LEFT$/RIGHT$/MID$ (multi-arg) ----------
            if (fn_name == "LEFT$" || fn_name == "RIGHT$" || fn_name == "MID$") {
                var lvl2 = 0, part2 = "", parts_lr = [];
                for (var ci2 = 1; ci2 <= string_length(f_inner); ci2++) {
                    var ch2 = string_char_at(f_inner, ci2);
                    if (ch2 == "(") { lvl2++; part2 += ch2; }
                    else if (ch2 == ")") { lvl2--; part2 += ch2; }
                    else if (ch2 == "," && lvl2 == 0) { array_push(parts_lr, string_trim(part2)); part2 = ""; }
                    else { part2 += ch2; }
                }
                array_push(parts_lr, string_trim(part2));

                // LEFT$/RIGHT$ expect exactly 2 args
                if ((fn_name == "LEFT$" || fn_name == "RIGHT$") && array_length(parts_lr) == 2) {
                    var tA1 = basic_tokenize_expression_v2(parts_lr[0]);
                    var tA2 = basic_tokenize_expression_v2(parts_lr[1]);
                    var pA1 = infix_to_postfix(tA1);
                    var pA2 = infix_to_postfix(tA2);
                    _push_all(output, pA1);
                    _push_all(output, pA2);
                    array_push(output, fn_name);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed " + fn_name + "(" + parts_lr[0] + "," + parts_lr[1] + ")");
                    i = f_end;
                    continue;
                }

                // MID$ supports 2 or 3 args
                if (fn_name == "MID$" && (array_length(parts_lr) == 2 || array_length(parts_lr) == 3)) {
                    for (var mi = 0; mi < array_length(parts_lr); mi++) {
                        var tMi = basic_tokenize_expression_v2(parts_lr[mi]);
                        var pMi = infix_to_postfix(tMi);
                        _push_all(output, pMi);
                    }
                    array_push(output, fn_name);
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed MID$(" + string(parts_lr) + ")");
                    i = f_end;
                    continue;
                }
                // else fall through to generic one-arg below
            }

            // ---------- SPECIAL: RND (0/1/2-arg variants) ----------
            if (fn_name == "RND") {
                var inner_trim = string_trim(f_inner);

                // 0-arg: RND()
                if (string_length(inner_trim) == 0) {
                    array_push(output, "RND");
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed RND()");
                    i = f_end;
                    continue;
                }

                // Split on top-level commas
                var lvlR = 0, partR = "", partsR = [];
                for (var ri = 1; ri <= string_length(f_inner); ri++) {
                    var chR = string_char_at(f_inner, ri);
                    if (chR == "(") { lvlR++; partR += chR; }
                    else if (chR == ")") { lvlR--; partR += chR; }
                    else if (chR == "," && lvlR == 0) { array_push(partsR, string_trim(partR)); partR = ""; }
                    else { partR += chR; }
                }
                array_push(partsR, string_trim(partR));

                if (array_length(partsR) == 1) {
                    var tN = basic_tokenize_expression_v2(partsR[0]);
                    var pN = infix_to_postfix(tN);
                    _push_all(output, pN);
                    array_push(output, "RND1");
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed RND(" + partsR[0] + ") → RND1");
                    i = f_end;
                    continue;
                }

                if (array_length(partsR) == 2) {
                    var tA = basic_tokenize_expression_v2(partsR[0]);
                    var tB = basic_tokenize_expression_v2(partsR[1]);
                    var pA = infix_to_postfix(tA);
                    var pB = infix_to_postfix(tB);
                    _push_all(output, pA);
                    _push_all(output, pB);
                    array_push(output, "RND2");
                    if (dbg_on(DBG_PARSE)) show_debug_message("Processed RND(" + partsR[0] + "," + partsR[1] + ") → RND2");
                    i = f_end;
                    continue;
                }
                // malformed → fall through to generic
            }

            // Generic one-arg function: <inner> <FN>
            var inner_tokens  = basic_tokenize_expression_v2(f_inner);
            var inner_postfix = infix_to_postfix(inner_tokens);
            _push_all(output, inner_postfix);
            array_push(output, fn_name);
            if (dbg_on(DBG_PARSE)) show_debug_message("Processed 1-arg function " + fn_name + "(" + f_inner + ") → postfix emit <inner> " + fn_name);
            i = f_end;
            continue;
        }

        // 8) UNKNOWN TOKEN
        if (dbg_on(DBG_PARSE)) show_debug_message("Unknown token, adding to output: " + string(t));
        array_push(output, t);
    }

    // Drain operator stack
    while (array_length(stack) > 0) {
        var tail = array_pop(stack);
        array_push(output, tail);
        if (dbg_on(DBG_PARSE)) show_debug_message("Drained operator stack → appended '" + string(tail) + "'");
    }

    if (dbg_on(DBG_PARSE)) show_debug_message("Final postfix: " + string(output));
    return output;
}
// === END: infix_to_postfix ===


================================================================================

/// @file scripts/inkey_capture_keys/inkey_capture_keys.gml

// FILE: scripts/inkey_capture_keys.gml
// FUNCTION: inkey_capture_keys
// PURPOSE: Feed the INKEY$ queue with a single key per frame.
// POLICY:
//   - Block capture while BASIC INPUT is active (awaiting_input = true)
//     UNLESS we are in an INKEY$ modal wait (inkey_waiting = true).
//   - During INKEY$ modal wait, keep capturing so the state machine can unblock.
//   - Otherwise capture printable ASCII (32..126) and (optionally) touch on Android.

function inkey_capture_keys() {
    /// inkey_capture_keys()

    // --- INPUT/INKEY arbitration guard -------------------------------------
    // Block capture only when INPUT is live and we are NOT in a modal INKEY wait.
    var _block_capture = false;

    if (variable_global_exists("awaiting_input") && global.awaiting_input) {
        var _inkey_waiting = (variable_global_exists("inkey_waiting") && global.inkey_waiting);
        if (!_inkey_waiting) {
            _block_capture = true;  // INPUT owns the keyboard; don't feed INKEY$ queue
        }
    }

    if (_block_capture) {
		//TEMPORARY: REMOVE WHEN TESTING INKEY$
        //if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: blocked (awaiting_input && !inkey_waiting)");
        exit;
    }
    // -----------------------------------------------------------------------

    // Initialize queue if not exists (use your current global.__inkey_queue)
    if (!ds_exists(global.__inkey_queue, ds_type_queue)) {
        global.__inkey_queue = ds_queue_create();
        if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Initialized global.__inkey_queue");
    }

    // --- Scan for one printable key (ASCII 32..126) per frame ---------------
    for (var key = 32; key <= 126; key++) {
        if (keyboard_check_pressed(key)) {
            var ch = chr(key);
            if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Key " + string(key) + " pressed, char='" + ch + "'");

            // Limit queue length to 10 (same policy as before)
            if (ds_queue_size(global.__inkey_queue) < 10) {
                ds_queue_enqueue(global.__inkey_queue, ch);
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: '" + ch + "' queued. Size=" + string(ds_queue_size(global.__inkey_queue)));
            } else {
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Queue full (10), skipped '" + ch + "'");
            }
            break; // capture at most one key per frame
        }
    }

    // --- Optional: map simple touch regions to WASD on Android --------------
    if (os_type == os_android) {
        var w = display_get_width();
        var h = display_get_height();
        if (device_mouse_check_button_pressed(0, mb_left)) {
            var mx = device_mouse_x(0);
            var my = device_mouse_y(0);
            var ch2 = "";

            // Quadrant-ish mapping (center bands) → W/A/S/D
            if (my < h * 0.5 && mx > w * 0.25 && mx < w * 0.75) ch2 = "W";
            else if (my > h * 0.5 && mx > w * 0.25 && mx < w * 0.75) ch2 = "S";
            else if (mx < w * 0.5 && my > h * 0.25 && my < h * 0.75) ch2 = "A";
            else if (mx > w * 0.5 && my > h * 0.25 && my < h * 0.75) ch2 = "D";

            if (ch2 != "" && ds_queue_size(global.__inkey_queue) < 10) {
                ds_queue_enqueue(global.__inkey_queue, ch2);
                if (dbg_on(DBG_FLOW)) show_debug_message("INKEY$ CAPTURE: Touch→'" + ch2 + "', queued. Size=" + string(ds_queue_size(global.__inkey_queue)));
            }
        }
    }
}


================================================================================

/// @file scripts/is_function/is_function.gml

/// @script is_function
// === BEGIN: is_function ===
function is_function(t) {
    var fn = string_upper(string_trim(t));
    return  fn == "RND"    // your original BASIC call
         || fn == "RND1"   // internal 1-arg postfix token
         || fn == "RND2"   // internal 2-arg postfix token
         || fn == "STR$"
         || fn == "CHR$"
         || fn == "LEFT$"
         || fn == "RIGHT$"
         || fn == "MID$"
         || fn == "ABS"
         || fn == "INT"
         || fn == "EXP"
         || fn == "LOG"
         || fn == "LOG10"
         || fn == "SGN"
         || fn == "SIN"
         || fn == "COS"
         || fn == "TAN"
         || fn == "REPEAT$"
         || fn == "TIMER"
         || fn == "TIME$"
         || fn == "DATE$"
         || fn == "INKEY$"
         || fn == "ASC"
		 || fn == "LEN";   // <-- added
}
// === END: is_function ===


================================================================================

/// @file scripts/is_operator/is_operator.gml

function is_operator(op) {
    return (op == "+" || op == "-" || op == "*" || op == "/" || op == "\\" || op == "^" || 
            op == "%" || string_upper(op) == "MOD" ||
            op == "=" || op == "<>" || op == "<" || op == ">" || op == "<=" || op == ">=" ||
            string_upper(op) == "AND" || string_upper(op) == "OR");
}

================================================================================
